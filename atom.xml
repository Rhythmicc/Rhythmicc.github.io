<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RhythmLian&#39;s Blog</title>
  <icon>https://i.loli.net/2020/02/14/r2kUf4DVWNxcJAL.jpg</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://rhythmlian.cn/"/>
  <updated>2020-10-17T15:13:22.619Z</updated>
  <id>https://rhythmlian.cn/</id>
  
  <author>
    <name>RhythmLian</name>
    <email>RhythmLian@outlook.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【DianNao】一种小体积、高吞吐量的泛在机器学习加速器</title>
    <link href="https://rhythmlian.cn/2020/10/17/DianNao/"/>
    <id>https://rhythmlian.cn/2020/10/17/DianNao/</id>
    <published>2020-10-17T08:39:35.000Z</published>
    <updated>2020-10-17T15:13:22.619Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>&emsp;&emsp;机器学习任务正在广泛的领域和广泛的系统(从嵌入式系统到数据中心)中变得无处不在。与此同时，一小部分机器学习算法(特别是卷积和深度神经网络，即CNN和DNNs)在许多应用中被证明是最先进的。随着体系结构朝着由核和加速器混合组成的异构多核的方向发展，机器学习加速器可以实现罕见的效率(由于目标算法数量较少)和广泛的应用范围的组合。</p><p>&emsp;&emsp;到目前为止，大多数机器学习加速器的设计都集中在高效实现算法的计算部分。然而，目前最先进的CNN和DNN的特点是它们的尺寸很大。在这项研究中，我们设计了一个适用于大规模CNN和DNN的加速器，特别强调了内存对加速器设计、性能和能量的影响。</p><p>&emsp;&emsp;结果表明，在<script type="math/tex">3.02 mm^2</script>和<script type="math/tex">485 mW</script>的小面积内，可以设计出具有高吞吐量、能够执行<script type="math/tex">452GOP/s</script>(如突触权重乘法和神经元输出加法等关键神经网络运算)的加速器；与<script type="math/tex">128</script>位<script type="math/tex">2 GHz</script>的SIMD处理器相比，该加速器的速度提高了<script type="math/tex">117.87</script>倍，总能量降低了<script type="math/tex">21.08</script>倍。结果表明，该加速器具有较高的吞吐能力，能够在<script type="math/tex">3.02 mm^2</script>和<script type="math/tex">485 mW</script>的小面积内完成<script type="math/tex">452GOP/s</script>(如突触权重乘法和神经元输出加法等关键的神经网络运算)的设计。在<script type="math/tex">65 nm</script>处布局后，获得了加速器的特性。在很小的空间内获得如此高的吞吐量，可以在广泛的系统和广泛的应用程序中打开最先进的机器学习算法的使用。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>&emsp;&emsp;随着体系结构朝着由核和加速器混合组成的异构多核的方向发展，设计能够在灵活性和效率之间实现最佳折衷的加速器成为一个突出的问题。</p><p>&emsp;&emsp;第一个问题是，人们应该主要为哪一类应用设计加速器？随着加速器的架构趋势，高性能和嵌入式应用程序中的第二个同步而重要的趋势正在发展：许多新兴的高性能和嵌入式应用程序，从图像/视频/音频识别到自动翻译、商业分析，以及所有形式的机器人都依赖于机器学习技术。这一趋势甚至开始渗透到我们的社区，在那里，Parsec[2]的大约一半基准测试可以使用机器学习算法来实现。Parsec[2]是一个套件，部分引入该套件是为了突出新类型应用程序的出现。这一应用趋势与机器学习的第三个同样显著的趋势相结合，在过去几年中，基于神经网络(特别是卷积神经网络[27]和深度神经网络[16])的少量技术已被证明在广泛的应用范围内是最先进的[25]。因此，由于目标算法的数量有限，因此有一个独特的机会来设计能够实现两全其美的加速器：显著的应用范围以及高性能和高效率。</p><p>&emsp;&emsp;目前，这些工作负载大多在使用SIMD[41]的多核、GPU[5]或FPGA[3]上执行。然而，前述趋势已经被一些研究人员识别，他们提出了实现卷积神经网络[3]或多层感知器[38]的加速器；专注于其他领域(例如图像处理)的加速器也提出了机器学习算法所使用的一些原语的有效实现，例如卷积[33]。其他人已经提出了卷积神经网络的ASIC实现[13]，或者其他自定义神经网络算法的ASIC实现[21]。然而，所有这些工作都首先并且成功地专注于高效地实现计算原语，但是它们要么为了简单而自愿忽略存储器传输[33，38]，要么通过或多或少复杂的DMA将它们的计算加速器直接插入存储器[3，13，21]。</p><p>&emsp;&emsp;虽然计算原语的有效实现是第一步也是重要的一步，其结果很有希望，但低效的存储器传输可能会潜在地使加速器的吞吐量、能量或成本优势失效，即Amdahl定律效应，因此，它们应该像处理器一样成为一阶问题，而不是第二步加速器设计中考虑的因素。不过，与处理器不同的是，在目标算法中可以考虑内存传输的特定性质，就像加速计算一样。这在机器学习领域尤其重要，在机器学习领域，有一种明显的趋势是扩大神经网络的规模，以实现更好的准确性和更多的功能[16，26]。</p><p>&emsp;&emsp;在这项研究中，我们研究了一种能够适应最流行的最先进算法，即卷积神经网络(CNNS)和深度神经网络(DNNs)的加速器设计。我们将加速器的设计重点放在内存使用上，并研究了一种加速器体系结构和控制，以最大限度地减少内存传输并尽可能高效地执行它们。我们提出了一种65 nm的设计，在3.02mm2,485 mW的占地面积(不包括主存储器访问)下，每1.02 ns，即452GOP/s，可以并行执行496个16位定点运算。在最近CNN和DNN中发现的10个最大层上，该加速器比时钟频率为2 GHz的128位SIMD内核平均速度快117.87倍，能效(包括主存储器访问)高21.08倍。</p><p>&emsp;&emsp;总括而言，我们的主要贡献如下：</p><ul><li>一种用于大规模CNN和DNN的综合(放置和布线)加速器设计，最先进的机器学习算法。</li></ul><p><img src="https://api-img.alapi.cn/image/2020/10/17/c2be28bfb7ee009e05d0b30fde645ecf.png" alt=""></p><ul><li>该加速器在小面积、功耗和能量占用方面实现了高吞吐量。</li><li>加速器设计关注的是内存行为，测量并不局限于计算任务，它们将内存传输的性能和能量影响考虑在内。</li></ul><p>&emsp;&emsp;该文件组织如下。在第2节中，我们首先提供最近的机器学习技术的入门读物，并介绍组成CNN和DNN的主要层。在第三节中，我们分析和优化这些层的存储行为，为基线和加速器设计做准备。在第4节中，我们解释为什么大规模CNN或DNN的ASIC实现不能与小型NN的直接ASIC实现相同。我们在第5节介绍了我们的加速器设计。方法学介绍在第6节，第7节的实验结果，第8节的相关工作中。</p><h2 id="2-Primer-on-Recent-Machine-Learning-Techniques-最新机器学习技术入门读本"><a href="#2-Primer-on-Recent-Machine-Learning-Techniques-最新机器学习技术入门读本" class="headerlink" title="2. Primer on Recent Machine-Learning Techniques | 最新机器学习技术入门读本"></a>2. Primer on Recent Machine-Learning Techniques | 最新机器学习技术入门读本</h2><p>&emsp;&emsp;尽管神经网络在机器学习领域的作用一直不稳定，即最初在20世纪80/90年代被炒作，然后随着支持向量机的出现而逐渐淡出人们的视线[6]。自2006年以来，神经网络的一个子集已经出现，在广泛的应用中实现了最先进的机器学习精度，部分原因是计算机视觉的神经科学模型的进步，如HMAX[37]。该神经网络子集包括深度神经网络(DNNs)[25]和卷积神经网络(CNNs)[27]。DNN和CNN是强相关的，它们在卷积层的存在和/或性质上特别不同，见后面。</p><p>&emsp;&emsp;<strong>处理与培训。</strong>目前，我们在加速器上实现了输入的快速处理(前馈)，而不是训练(反向路径)。这源于技术和市场考虑。从技术上讲，人们经常有一种重要的误解，认为在线学习对于许多应用程序来说都是必要的。相反，对于许多工业应用而言，离线学习就足够了，其中神经网络首先针对一组数据进行训练，然后运送给客户，例如关于手写数字、车牌号、要识别的人脸或对象的数目等进行训练；网络可以周期性地离线并重新训练。虽然今天，机器学习研究人员和工程师特别需要加快培训速度的架构，但这只是一个很小的市场，目前，我们专注于更大的最终用户市场，他们需要快速/高效的前馈网络。有趣的是，最近涉足硬件加速器的机器学习研究人员也做出了同样的选择。尽管如此，由于训练中使用的计算和访问模式的性质(特别是反向传播)与前向路径的性质相当相似，我们计划稍后在加速器中增加支持训练的必要功能。</p><p><img src="https://api-img.alapi.cn/image/2020/10/17/b97024f2328a30e071d92ae118089b36.png" alt=""></p><p>&emsp;&emsp;<strong>一般结构。</strong>尽管深度神经网络和卷积神经网络有不同的形式，但它们有足够的共同性质，可以定义一个通用的公式。通常，这些算法由(可能大量)层组成；这些层是按顺序执行的，因此可以独立考虑(和优化)它们。每一层通常包含几个称为功能地图的子层；然后我们使用术语输入功能地图和输出功能地图。总体而言，有三种主要的层：层次的大部分由卷积和合并(也称为子采样)层组成，在网络的顶部有一个由一个或几个层组成的分类器。</p><p>&emsp;&emsp;<strong>卷积层。</strong>卷积层的作用是将一个或多个本地过滤器应用于来自输入(先前)层的数据。因此，输入和输出特征地图之间的连接是局部的，而不是完全的。考虑输入是图像的情况，卷积是输入层的<script type="math/tex">K_x × K_y</script>子集(窗口)和相同维度的核之间的2D变换，见图1。核值是输入层和输出(卷积)层之间的突触权重。由于一个输入层通常包含多个输入特征映射，并且由于输出特征映射点通常是通过对所有输入特征映射的同一窗口应用卷积来获得的，请参见图1，核是3D的，即<script type="math/tex">K_x × K_y × N_i</script>，其中<script type="math/tex">N_i</script>是输入特征映射的数目。请注意，在某些情况下，连接性是稀疏的，即并非所有输入特征映射都用于每个输出特征映射。卷积层的典型代码如图7所示，参见原始代码。将非线性函数应用于卷积输出，例如<script type="math/tex">f(X)=tanh(X)</script>。卷积层的特征还在于两个连续窗口(一维或二维)之间的重叠，参见步骤 <script type="math/tex">S_x，S_y</script>以了解循环 <script type="math/tex">x，y</script>。</p><p>在某些情况下，将相同的核应用于输入层的所有<script type="math/tex">K_x × K_y</script>窗口，即，在整个输入特征映射上隐式共享权重。这是CNN的特征，虽然内核可以特定于DNNs[26]中输出特征映射的每个点，但我们随后使用术语私有内核。</p><p>&emsp;&emsp;<strong>合并图层。</strong>池化层的作用是聚合一组邻居输入数据中的信息。同样，在图像的情况下，它仅用于在给定窗口内保留图像的显著特征和/或以不同的比例这样做，请参见图1。汇集图层的一个重要副作用是降低了要素地图的维度。池层的示例代码如图8所示(请参阅原始代码)。请注意，每个要素地图是单独池化的，即2D池化，而不是3D池化。合用可以以各种方式进行，一些优选的技术是平均值和最大运算；合用之后可以是非线性函数，也可以不是。</p><p><strong>&emsp;&emsp;分类器层。</strong>卷积和池层是在深层层次结构中交织的，而层次结构的顶部通常是一个分类器。分类器可以是线性或多层(通常是2层)感知器，见图1。如图5所示，示例感知器层见原始代码。像卷积层一样，非线性函数被应用到神经元输出中，通常是一个b型，例如：<script type="math/tex">f(x) = \frac{1}{1+e^{-x}}</script>；不同于卷积或池层，分类器通常聚合(平坦)所有特征映射，所以在分类器层中没有特征映射的概念。</p><h2 id="3-Processor-Based-Implementation-of-Large-Neural-Networks-基于处理器的-大型-神经网络的实现"><a href="#3-Processor-Based-Implementation-of-Large-Neural-Networks-基于处理器的-大型-神经网络的实现" class="headerlink" title="3. Processor-Based Implementation of (Large) Neural Networks | 基于处理器的(大型)神经网络的实现"></a>3. Processor-Based Implementation of (Large) Neural Networks | 基于处理器的(大型)神经网络的实现</h2><p>&emsp;&emsp;加速大规模神经网络的独特之处在于潜在的高内存流量。在本节中，我们详细分析了第2节中提到的不同层的局部性，我们对这些层的基于处理器的实现进行了调整，以便为我们的基线准备和加速器的设计和使用。我们将局部分析/优化应用到各个层次上，并通过4个基准层(1，CONV3，CONV5，POOL3)对这些变换的带宽影响进行了说明，并在第6节中详细说明了它们的特性。</p><p>&emsp;&emsp;对于这个部分的内存带宽测量，我们使用一个缓存模拟器，插入到一个虚拟计算结构中，我们没有假设，除非它能够处理<script type="math/tex">T_n</script>神经元，每个周期都有<script type="math/tex">tT_i</script>突触。缓存层次结构由intel core i7驱动：L1为64位，64字节行，8路；可选L2是2MB、64byte、8路。与核心i7不同，我们假设缓存有足够的银行/端口来为输入神经元提供<script type="math/tex">T_n×4</script>字节，并且对于突触来说，<script type="math/tex">T_n×T_i×4</script>字节。对于大型<script type="math/tex">T_n，T_i</script>来说，这种缓存的成本可能会令人望而却步，但它只用于我们对局部性和带宽的限制研究；我们使用<script type="math/tex">T_n=T_i=16</script>。</p><h3 id="3-1-Classifier-Layers-分类器层"><a href="#3-1-Classifier-Layers-分类器层" class="headerlink" title="3.1 Classifier Layers | 分类器层"></a>3.1 Classifier Layers | 分类器层</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for (int nnn &#x3D; 0; nnn ¡ Nn; nnn +&#x3D; Tnn) &#123; &#x2F;&#x2F; tiling for output neurons;</span><br><span class="line">for (int iii &#x3D; 0; iii ¡ Ni; iii +&#x3D; Tii) &#123; &#x2F;&#x2F; tiling for input neurons;</span><br><span class="line">for (int nn &#x3D; nnn; nn ¡ nnn + Tnn; nn +&#x3D; Tn) &#123;</span><br><span class="line">for (int n &#x3D; nn; n ¡ nn + Tn; n++)</span><br><span class="line">sum[n] &#x3D; 0;</span><br><span class="line">for (int ii &#x3D; iii; ii ¡ iii + Tii; ii +&#x3D; Ti) </span><br><span class="line">&#x2F;&#x2F; — Original code —</span><br><span class="line">for (int n &#x3D; nn; n &lt; nn + Tn; n++)</span><br><span class="line">for (int i &#x3D; ii; i &lt; ii + Ti; i++)</span><br><span class="line">sum[n] +&#x3D; synapse[n][i] * neuron[i];</span><br><span class="line">for (int n &#x3D; nn; n &lt; nn + Tn; n++)</span><br><span class="line">neuron[n] &#x3D; sigmoid(sum[n]);</span><br><span class="line">&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><center> <b>Figure 5.</b> <i>Pseudo-code for a classifier (here, percption) layer (original loop nest + locality optimization)</i> </center><p>&emsp;&emsp;我们考虑感知器分类器层，见图2和5；平铺循环<script type="math/tex">ii</script>和<script type="math/tex">nn</script>简单地反映了计算结构可以同时处理具有<script type="math/tex">T_i</script>突触的<script type="math/tex">T_n</script>神经元。内存传输总数为(加载的输入+加载的突触+写入的输出)：<script type="math/tex">N_i×N_n+N_i×N_n+N_n</script>。对于示例层CLASS1，相应的内存带宽很高，为120 Gb/s，请参见图6中的CLASS1-Original。下面我们将解释如何可能降低此带宽，有时会大幅降低。</p><p>&emsp;&emsp;<strong>输入/输出神经元。</strong>再次考虑图2和图5的代码。对于每个输出神经元，输入神经元被重复使用，但是由于输入神经元的数量可以在几十到几十万之间的任何范围内，它们通常不会在L1高速缓存中命中。因此，我们用平铺因子<script type="math/tex">T_{ii}</script>来平铺回路<script type="math/tex">ii</script>(输入神经元)。平铺的一个典型权衡是，改进一个参考(这里的神经元[i]是输入神经元)会增加另一个参考(输出神经元部分和的<script type="math/tex">sum[n]</script>)的重用距离，因此我们也需要平铺第二个参考，因此循环<script type="math/tex">nnn</script>和输出神经元部分和的平铺系数<script type="math/tex">T_{nn}</script>。正如预期的那样，瓦片大大降低了输入神经元的存储带宽需求，而输出神经元的存储带宽需求则有所增加，尽管幅度很小。层记忆行为现在由突触主导。</p><p><img src="https://api-img.alapi.cn/image/2020/10/17/fcf9a45d7b6aaf0a11263e1627c97aa6.png" alt=""></p><p>&emsp;&emsp;<strong>突触。</strong>在感知器层中，所有突触通常都是唯一的，因此在该层内不存在重用。另一方面，突触在网络调用之间重复使用，即，对于呈现给神经网络的每个新输入数据(也称为“输入行”)重复使用。因此，足够大的L2可以存储所有的网络突触，并利用该位置。对于具有私有内核的DNN来说，这是不可能的，因为突触的总数在数千万或数亿(迄今为止最大的网络有10亿个突触[26])。但是，对于具有共享内核的CNN和DNN，突触总数都在数百万个范围内，这在L2缓存的范围内。在图6中，请参阅<script type="math/tex">CLASS1-Tiled+L2</script>，我们模拟了这样一种情况，即只考虑感知器层即可跨网络调用重用；因此，总带宽需求现在已大幅降低。</p><h3 id="3-2-Convolutional-Layers-卷积层"><a href="#3-2-Convolutional-Layers-卷积层" class="headerlink" title="3.2 Convolutional Layers | 卷积层"></a>3.2 Convolutional Layers | 卷积层</h3><p>&emsp;&emsp;我们考虑二维卷积层，见图3和图7。卷积层相对于分类器层的两个显著特征是存在输入和输出特征映射(循环<script type="math/tex">i</script>和<script type="math/tex">n</script>)和核(循环<script type="math/tex">k_x, k_y</script>)。</p><p>&emsp;&emsp;<strong>输入/输出。</strong>输入和输出有两种重用机会：用于扫描(二维<script type="math/tex">(x，y)</script>)输入层的滑动窗口和跨<script type="math/tex">Nn</script>个输出特征映射的重用，见图3。前者最多对应于<script type="math/tex">\frac{K_x × K_y}{S_x × S_y}</script>重用，后者对应于NN重用。我们在图7中为前者平铺(平铺<script type="math/tex">T_x，T_y</script>)，但我们通常不需要为后者平铺，因为要重用的数据，即<script type="math/tex">K_x×K_y×N_i</script>的一个核，适合L1数据高速缓存，因为<script type="math/tex">K_x，K_y</script>通常是10的量级，而<script type="math/tex">N_i</script>可以在小于10到几百之间变化；当然，当不是这种情况时，我们可以平铺输入特征地图(<script type="math/tex">ii</script>)并再次引入第二级平铺循环<script type="math/tex">iii</script>。</p><p><strong>&emsp;&emsp;突触。</strong>对于具有共享内核的卷积层(参见第2节)，相同的内核参数(突触权重)在所有<script type="math/tex">xout，yout</script>输出特征映射位置上重复使用。因此，总带宽已经很低，如图6中的层CONV3所示。然而，由于总的共享内核容量是<script type="math/tex">K_x×K_y×N_i×N_o</script>，它可能会超过L1高速缓存容量，因此我们再次平铺输出特征地图(平铺<script type="math/tex">T_{nn}</script>)以将其降至<script type="math/tex">K_x×K_y×N_1×T_{nn}</script>。因此，总体内存带宽可以进一步减少，如图6所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">for(intyy&#x3D;0;yyiNyin;yy+&#x3D;Ty)&#123;</span><br><span class="line">  for(intxx&#x3D;0;xxiNxin;xx+&#x3D;Tx)&#123;</span><br><span class="line">    for(intnnn&#x3D;0;nnnjNn;nnn+&#x3D;Tnn)&#123;</span><br><span class="line">    &#x2F;&#x2F;-Original code-(excluding nn, ii loops)</span><br><span class="line">    int yout&#x3D;0;</span><br><span class="line">    for(inty&#x3D;yy;y&lt;yy+Ty;y+&#x3D;sy)&#123;&#x2F;&#x2F;tiling fory;</span><br><span class="line">    int xout&#x3D;0;</span><br><span class="line">    for(intx&#x3D;xx;x&lt;XX+Tx;X+&#x3D;sx)&#123;&#x2F;&#x2F;tiling forx;</span><br><span class="line">    for (int nn &#x3D; nnn; nnn + Tnn; nn+&#x3D;Tn)&#123;</span><br><span class="line">    for(intn&#x3D;nn;n&lt;nn+Tn;n++)</span><br><span class="line">    sum[n]&#x3D;0;</span><br><span class="line">    &#x2F;&#x2F;sliding window;</span><br><span class="line">    for(intky&#x3D;0;ky&lt;Ky;ky++)</span><br><span class="line">    for(intkx&#x3D;0;kx&lt;Kx;kx++)</span><br><span class="line">    for(intii&#x3D;0;ii&lt;Ni;ii+&#x3D;Ti)</span><br><span class="line">    for(intn&#x3D;nn;n&lt;nn+Tn;n++)</span><br><span class="line">    for(inti&#x3D;ii;i&lt;ii+Ti;i++)</span><br><span class="line">    &#x2F;&#x2F;version with shared kernels</span><br><span class="line">    sum[n]+&#x3D;synapse[ky][kx][n][i]</span><br><span class="line">    *neuron[ky+y][kx+x][i];</span><br><span class="line">    &#x2F;&#x2F;version with private kernels</span><br><span class="line">    sum[n]+&#x3D;synapse[yout][xout][ky][kx][n][i]&#125;</span><br><span class="line">    *neuron[ky+y][kx+x][i];</span><br><span class="line">    for(intn&#x3D;nn;n&lt;nn+Tn;n++)</span><br><span class="line">    neuron[yout][xout][n]&#x3D;non_linear_transform(sum[n]);</span><br><span class="line">  &#125;xout++;&#125;yout++;</span><br><span class="line">&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><center> <b>Figure 7.</b> <i>Pseudo-code for convolutional layer (original loop nest + locality optimization), both shared and private kernels versions</i> </center><p>&emsp;&emsp;对于具有私有内核的卷积层，突触都是唯一的，没有重用，就像分类器层一样，因此具有图6中CONV5的相似突触带宽。至于分类器层，如果L2容量足够的话，跨网络调用重用仍然是可能的。尽管阶跃系数(<script type="math/tex">S_x，S_y</script>)和输出特征图的稀疏输入(参见第2节)可以大幅减少私有内核突触权重的数量，但对于CONV5等非常大的层，它们的范围仍然在数百兆字节，因此将大大超过L2容量，这意味着高内存带宽，请参见图6。</p><p>&emsp;&emsp;值得注意的是，机器学习社区中关于共享内核与私有内核的争论正在进行[26，35]，拥有私有内核而不是共享内核的机器学习重要性仍然不清楚。由于它们可能导致显著不同的体系结构性能，这可能是体系结构/性能社区参与机器学习辩论的情况。</p><h3 id="3-3-Pooling-Layers-池化图层"><a href="#3-3-Pooling-Layers-池化图层" class="headerlink" title="3.3 Pooling Layers | 池化图层"></a>3.3 Pooling Layers | 池化图层</h3><p>&emsp;&emsp;现在我们考虑汇集层，见图4和图8。与卷积层不同，输入和输出特征图的数量是相同的，更重要的是，没有核，即没有要存储的突触权重，并且输出特征图元素仅由<script type="math/tex">K_x×K_y</script>输入特征图元素确定，即2D窗口(而不是用于卷积层的3D窗口)。因此，唯一的重用来源来自滑动窗口(而不是滑动窗口和输出特征映射的组合效果)。由于重用机会较少，输入神经元的存储带宽高于卷积层，并且<script type="math/tex">(T_x，T_y)</script>平铺带来的改进不那么显著，请参见图6。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">for(intyy&#x3D;0;yyiNyin;yy+&#x3D;Ty)&#123;</span><br><span class="line">  for(intxx&#x3D;0;xxiNxin;xx+&#x3D;Tx)&#123;</span><br><span class="line">    for(intii&#x3D;0;iii;Ni;ii+&#x3D;Tii)</span><br><span class="line">      &#x2F;&#x2F;-Original code-(excluding ii loop)</span><br><span class="line">      int yout &#x3D;0;</span><br><span class="line">      for(inty&#x3D;yy;y&lt;yy+Ty;y+&#x3D;sy)&#123;</span><br><span class="line">        int xout &#x3D; 0;</span><br><span class="line">        for(intx&#x3D;xx;x&lt;xx+Tx;X+&#x3D;SX)&#123;</span><br><span class="line">          for (int ii &#x3D; iii ; i &lt; ii + Tii ; ii + &#x3D; Ti )</span><br><span class="line">            for(inti&#x3D;ii;i&lt;ii+Ti;i++)</span><br><span class="line">            value[i]&#x3D;0;</span><br><span class="line">        for(intky&#x3D;0;ky&lt;Ky;ky++)</span><br><span class="line">        for(intkx&#x3D;0;kx&lt;Kx;kx++)</span><br><span class="line">        for(inti&#x3D;ii;i&lt;ii+Ti;i++)</span><br><span class="line">        &#x2F;&#x2F;version with average pooling;</span><br><span class="line">        value[i]+&#x3D;neuron[ky+y][kx+x][i];</span><br><span class="line">        &#x2F;&#x2F;version with max pooling;</span><br><span class="line">        value[i]&#x3D;max(value[i],neuron[ky+y][kx+x][i]);</span><br><span class="line">      &#125;&#125;&#125;&#125;</span><br><span class="line">      &#x2F;&#x2F;for average pooling;</span><br><span class="line">      neuron[xout][yout][i]&#x3D;value[i]&#x2F;(Kx*Ky);</span><br><span class="line">      xout++;&#125; yout++;</span><br><span class="line">&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><center> <b>Figure 8.</b> <i>Pseudo-code for pooling layer (original loop nest + locality optimization).</i> </center><h2 id="4-Accelerator-for-Small-Neural-Networks-用于小型神经网络的加速器"><a href="#4-Accelerator-for-Small-Neural-Networks-用于小型神经网络的加速器" class="headerlink" title="4. Accelerator for Small Neural Networks | 用于小型神经网络的加速器"></a>4. Accelerator for Small Neural Networks | 用于小型神经网络的加速器</h2><p>&emsp;&emsp;在这一部分中，我们首先评估一种实现硬件神经网络加速器的“幼稚”和“贪婪”的方法，其中所有神经元和突触都在硬件中布局，内存仅用于输入行和存储结果。虽然这些神经网络可以潜在地达到最佳的能源效率，但我们表明它们是不可伸缩的。尽管如此，我们仍然使用这样的网络来研究可以合理地在硬件中实现的神经元的最大数量。</p><h3 id="4-1-Hardware-Neural-Networks-硬件神经网络"><a href="#4-1-Hardware-Neural-Networks-硬件神经网络" class="headerlink" title="4.1 Hardware Neural Networks | 硬件神经网络"></a>4.1 Hardware Neural Networks | 硬件神经网络</h3><p>&emsp;&emsp;将神经网络映射到硅上最自然的方法是完全布局神经元和突触，以便硬件实现与神经网络的概念表示相匹配，请参见图9。每个神经元都实现为逻辑电路，而突触实现为锁存器或RAM。这种方法最近已经用于基于感知器或尖峰的硬件神经网络[30，38]。它与一些嵌入式应用程序兼容，在这些应用程序中，神经元和突触的数量可以很少，而且它可以提供高速和低能量，因为数据传输的距离非常小：从一个神经元到下一层的神经元，以及从一个突触锁存器到相关的神经元。例如，90-10-10(90个输入，10个隐藏，10个输出)感知器[38]的执行时间为15 ns，比核心能量降低974倍。</p><center class='half'>    <img src="https://api-img.alapi.cn/image/2020/10/17/b797bfe17935af8ee1496eee97bae183.png" style="zoom:50%;" />    <img src="https://api-img.alapi.cn/image/2020/10/17/9e9225a65d3ea25d25f87feae12a766b.png" style="zoom:50%;" /></center><h3 id="4-2-Maximum-Number-of-Hardware-Neurons-硬件神经元的最大数量？"><a href="#4-2-Maximum-Number-of-Hardware-Neurons-硬件神经元的最大数量？" class="headerlink" title="4.2 Maximum Number of Hardware Neurons ? | 硬件神经元的最大数量？"></a>4.2 Maximum Number of Hardware Neurons ? | 硬件神经元的最大数量？</h3><p>&emsp;&emsp;然而，面积、能量和延迟随神经元数量的增加呈二次曲线增长。我们综合了不同维度的神经网络层的ASIC版本，并在图10中报告了它们的面积、关键路径和能量。我们使用Synopsys ICC作为布局和布线，并使用TSMC 65 nm GP库，标准VT。硬件神经元执行以下操作：输入和突触相乘，所有这些相加，然后是S形，见图9。Tn×T1层是TN神经元的一层，每一层都有T1突触。16x16层需要小于0.71mm2，但32x32层已经需要2.66mm2。考虑到大规模神经网络的神经元数以千计，只有一层的完整硬件布局可能在数百或数千mm2的范围内，因此，这种方法对于大规模神经网络是不现实的。</p><p><img src="https://api-img.alapi.cn/image/2020/10/17/6c369217484589cced75f7fd7a4dfe4a.png" style="zoom:50%;" /></p><p>&emsp;&emsp;对于这样的神经网络，只有一小部分神经元和突触可以在硬件中实现。矛盾的是，旧的神经网络设计(如Intel ETANN[18])在20世纪90年代初就是这种情况，不是因为神经网络在当时已经很大，而是因为硬件资源(晶体管数量)自然要稀缺得多。其原理是分时扫描物理神经元，并使用片上RAM存储突触和隐藏层的中间神经元值。然而，在那个时候，许多神经网络都足够小，以至于所有的突触和中间神经元的值都可以在神经网络内存中ﬁt。由于这种情况已经不再是这样，大规模神经网络加速器设计的主要挑战之一已经成为计算和存储层次之间的相互作用。</p><h2 id="5-Accelerator-for-Large-Neural-Networks-用于大型神经网络的加速器"><a href="#5-Accelerator-for-Large-Neural-Networks-用于大型神经网络的加速器" class="headerlink" title="5. Accelerator for Large Neural Networks | 用于大型神经网络的加速器"></a>5. Accelerator for Large Neural Networks | 用于大型神经网络的加速器</h2><p>&emsp;&emsp;在这一部分中，我们借鉴第三节和第四节的分析，设计了一个适用于大规模神经网络的加速器。</p><p>&emsp;&emsp;加速器的主要部件如下：输入神经元的输入缓冲器(NBIN)，输出神经元的输出缓冲器(NBOUT)，以及第三个突触权重缓冲器(SB)，它们连接到我们称为神经功能单元(NFU)的计算块(执行突触和神经元计算)和控制逻辑(CP)，见图11。我们首先ﬁ下面描述NFU，然后我们集中讨论并解释加速器存储元件的原理。</p><h3 id="5-1-Computations-Neural-Functional-Unit-NFU-计算：神经功能单元-NFU"><a href="#5-1-Computations-Neural-Functional-Unit-NFU-计算：神经功能单元-NFU" class="headerlink" title="5.1 Computations: Neural Functional Unit (NFU) | 计算：神经功能单元(NFU)"></a>5.1 Computations: Neural Functional Unit (NFU) | 计算：神经功能单元(NFU)</h3><p>&emsp;&emsp;NFU的精神是将一层神经元分解成由<script type="math/tex">T_i</script>输入/突触和<script type="math/tex">T_n</script>输出神经元组成的计算块(ﬂblock)。这对应于用于ClassiﬁEr和卷积层两者的循环I和N，见图5和图7，并且对应于用于汇聚层的循环I，见图8。</p><p><img src="https://api-img.alapi.cn/image/2020/10/17/1819cb26021a4773df60bd5913227a49.png" style="zoom:50%;" /></p><p>&emsp;&emsp;<strong>算术运算符。</strong>每种图层类型的计算可以分2个阶段或3个阶段进行。对于Classiﬁer层：突触×输入的乘法，所有乘法的相加，S形。对于卷积层，级是相同的；最后一级(Sigmoid或其他非线性函数)的性质可以改变。对于池化层，没有乘法(没有突触)，并且池操作可以是平均值或最大值。请注意，加法器有多个输入，它们实际上是加法器树，见图11；第二级还包含用于合并层的移位器和最大运算符。</p><p>&emsp;&emsp;<strong>交错的管道。</strong>我们可以对所有2或3个操作进行流水线操作，但流水线必须交错：第一个或前两个阶段(分别用于池、分类器和卷积层)作为正常流水线级操作，但第三级仅在执行完所有添加之后才有效(对于分类器层和卷积层；对于池化层，在第三级中没有操作)。从现在开始，我们将NFU管道的第n阶段称为NFU-n。</p><p>&emsp;&emsp;<strong>NFU-3功能实现。</strong>如文献[23，38]所述，NFU-3(用于分类器和卷积层)的Sigmoid可以使用分段线性内插(<script type="math/tex">f(x)=a_i×x+b_i，x∈[x_i；x_{i+1}]</script>)有效地实现，精度损失可以忽略不计(16个段就足够了)[24]，见图9。就运算符而言，它对应于两个 16x1 16位多路复用器(用于段边界选择，即<script type="math/tex">x_i，x_{i+1}</script>)、一个16位乘法器(16位输出)和一个16位加法器来执行内插。16段系数(ai，bi)存储在小RAM中；这允许仅通过改变RAM段系数<script type="math/tex">a_i，b_i</script>来实现任何功能，而不仅仅是Sigmoid(例如，双曲正切、线性函数等)；段边界<script type="math/tex">(x_i，x_{i+1})</script>是硬连线的。</p><p>&emsp;&emsp;<strong>16位定点算术运算符。</strong>我们使用16位定点算术运算符，而不是字长(例如，32位)浮点运算符。虽然这看起来可能令人惊讶，但文献中有充分的证据表明，即使是更小的运算符(例如，8位或更少)对神经网络的准确性几乎没有影响[8，17，24]。为了说明和进一步支持ﬁRM这一概念，我们在UC Irvine机器学习存储库中的数据集上训练并测试了多层感知器，参见图12，在标准MNIST机器学习基准(手写数字)[27]上，参见表1，使用16位定点和32位浮点运算符；我们使用10倍交叉验证进行测试。对于定点运算符，整数部分使用6位，小数部分使用10位(我们在整篇文章中都使用这种定点配置)。结果如图12所示，在ﬁRm中，这种权衡对精度的影响非常小。目前我们保守地使用16位定点，但将来我们会探索更小的或可变大小的运算符。注意，算术运算符是截断的，即它们的输出是16位；我们使用具有校正常数的标准n位截断乘法器[22]。如表2所示，其面积比65 nm的32位浮点乘法器小6.10倍，功耗低7.33倍，CAD工具方法见第6节。</p><h3 id="5-2-Storage-NBin-NBout-SB-and-NFU-2-Registers-存储：NBIN、NBOUT、SB和NFU-2寄存器"><a href="#5-2-Storage-NBin-NBout-SB-and-NFU-2-Registers-存储：NBIN、NBOUT、SB和NFU-2寄存器" class="headerlink" title="5.2 Storage: NBin, NBout, SB and NFU-2 Registers | 存储：NBIN、NBOUT、SB和NFU-2寄存器"></a>5.2 Storage: NBin, NBout, SB and NFU-2 Registers | 存储：NBIN、NBOUT、SB和NFU-2寄存器</h3><p>&emsp;&emsp;加速器的不同存储结构可以被解释为便签本的修改过的(modiﬁ)缓冲器。虽然高速缓存是通用处理器的优秀存储结构，但由于高速缓存访问开销(标签检查、关联性、行大小、推测性读取等)和高速缓存冲突[39]，它是利用重用的次优方式。高效的替代方案，便签簿，在VLIW处理器中使用，但是众所周知，它很难编译。然而，专用加速器中的便签簿实现了这两个领域的最佳效果：高效的存储和高效且容易地利用本地，因为只有少数算法需要手动调整。在这种情况下，我们几乎可以直接将第3节中介绍的位置转换转换为缓冲区的映射命令，主要是调制平铺因子。第5.3.2节提供了一个代码映射示例。</p><p>&emsp;&emsp;下面我们解释加速器的存储部分是如何组织的，以及它克服了缓存体系结构的哪些限制。</p><h4 id="5-2-1-Split-buffers-拆分缓冲区"><a href="#5-2-1-Split-buffers-拆分缓冲区" class="headerlink" title="5.2.1 Split buffers | 拆分缓冲区"></a>5.2.1 Split buffers | 拆分缓冲区</h4><p>&emsp;&emsp;如前所述，我们将存储划分为三个结构：输入缓冲区(NBIN)、输出缓冲区(NBOUT)和突触缓冲区(SB)。</p><p><img src="https://api-img.alapi.cn/image/2020/10/17/98205d0b2c5bc02c47567dc3a634c0bd.png" style="zoom:50%;" /></p><p><em>&emsp;&emsp;宽度。</em>拆分结构的第一个好处(ﬁt)是将SRAM调整为适当的读/写宽度。NBIN和NBOUT的宽度均为<script type="math/tex">T_n×2</script>字节，而SB的宽度为<script type="math/tex">T_n×T_n×2</script>字节。单个读取宽度大小(例如，与高速缓存线大小一样)将是较差的折衷。如果将其调整为突触，即如果行大小为<script type="math/tex">T_n×T_n×2</script>，则从<script type="math/tex">T_n×T_n×2</script>宽的数据库中读取<script type="math/tex">T_n×2</script>字节会产生显著的能量损失，见图13，图13显示了65 nm处TSMC工艺的SRAM读取能量作为存储体宽度的函数。如果将行大小调整为神经元，即如果行大小为<script type="math/tex">T_n×2</script>，则读出<script type="math/tex">T_n×T_n×2</script>字节具有显著的时间代价。将存储拆分为专用结构允许为每个读取请求获得最佳时间和精力。</p><p><em>&emsp;&emsp;冲突。</em>分割存储结构的第二个好处(ﬁt)是避免将在高速缓存中发生的冲突。这一点尤其重要，因为出于成本和能源(泄漏)的原因，我们希望使存储结构的尺寸保持较小。另一种解决方案是使用高度关联的高速缓存。考虑这些约束：高速缓存线(或端口数)需要很大(<script type="math/tex">T_n×T_n×2</script>)才能以高速率为突触提供服务；由于我们希望保持较小的高速缓存大小，因此容忍如此长的高速缓存线的唯一替代方案是高关联性。然而，在n路高速缓存中，通过推测性地并行读取所有n路/存储体来实现快速读取；结果，关联高速缓存的能量成本迅速增加。即使从8路关联32KB高速缓存读取64字节的能量也比从65 nm的直接映射高速缓存读取32字节的能耗高3.15倍；使用Cacti[40]进行测量。即使只有64字节行，Corei7的一级32KB数据高速缓存也已经是8路关联的，因此我们需要更大的关联性来处理非常大的行(对于<script type="math/tex">T_n=16</script>，行大小将是512字节长)。换句话说，在我们的情况下，高度关联的高速缓存将是一种昂贵的能源解决方案。拆分式存储和对本地行为的精确了解允许完全消除数据冲突。</p><p><img src="https://api-img.alapi.cn/image/2020/10/17/2c8065ac458d6067ce2a98e12e644059.png" style="zoom:80%;" /></p><h4 id="5-2-2-Exploiting-the-locality-of-inputs-and-synapses-利用输入和突触的局部性。"><a href="#5-2-2-Exploiting-the-locality-of-inputs-and-synapses-利用输入和突触的局部性。" class="headerlink" title="5.2.2 Exploiting the locality of inputs and synapses. | 利用输入和突触的局部性。"></a>5.2.2 Exploiting the locality of inputs and synapses. | 利用输入和突触的局部性。</h4><p><strong>&emsp;&emsp;DMA。</strong>为了利用空间局部性，我们实现了三个DMA，每个缓冲区一个(两个加载DMA，一个用于输出的存储DMA)。DMA请求以指令的形式向NBIN发出，稍后将在第5.3.2节中介绍。这些请求缓存在与每个缓冲区相关的单独FIFO中，请参见图11，一旦DMA发送了前一条指令的所有内存请求，它们就会立即发出。这些DMA请求FIFO可使向所有缓冲区和NFU发出的请求与当前缓冲区和NFU操作解耦。因此，只要有足够的缓冲区容量，就可以提前很长时间预加载DMA请求，以容忍较长的延迟；这种预加载类似于预取，尽管没有推测。由于NBIN(和SB)同时用作重复使用和预加载缓冲区的便签簿，因此我们使用双端口SRAM；TSMC 65 nm库将64条目NB的双端口SRAM的读取能量开销评为24%。</p><p>&emsp;&emsp;<strong>旋转NBIN缓冲器，</strong>用于输入神经元的临时重用。所有层的输入被分割成块，这些块在nbin中被ﬁt，并通过实现nbin作为循环缓冲区来重用。实际上，轮换是通过改变寄存器索引自然实现的，很像在软件实现中，不存在缓冲器条目的物理(和昂贵的)移动。</p><p><strong>&emsp;&emsp;NBIN中的局部转置用于合并图层。</strong>对于(输入)神经元的数据结构组织，在卷积层和池层之间存在张力。如前所述，Kx，Ky通常很小(通常小于10)，而Ni大约大一个数量级。因此，使用输入特征映射作为三维神经元数据结构的最内层索引，内存获取效率更高(大跨度-1访问)。然而，这对于合并图层是不方便的，因为每个输入特征地图计算一个输出，即，仅使用K x×Ky数据(而在卷积图层中，计算一个输出数据需要所有K x×K y×Ni数据)。因此，对于池化层，逻辑数据结构组织是将kx，ky作为最里面的维度，以便计算一个输出所需的所有输入都连续地存储在NBIN缓冲器中。我们通过在NBIN中引入映射函数来解决此问题，该映射函数具有本地调换循环k y、k x和循环i的效果，以便数据沿着循环i加载，但它存储在NBIN中，因此首先沿着循环k y、k x发送到NFU；这是通过在加载时交错NBIN中的数据来实现的，请参见图14。</p><p>&emsp;&emsp;对于突触和SB，如第3节所述，要么没有重用(分类器层、具有私有内核的卷积层和池层)，要么在卷积层中重用共享内核。对于OUTPUT和NBOUT，我们需要重用部分和，即参见图5中的参考SUM[n]。此重用需要下一节所述的额外硬件修改ﬁ阳离子。</p><h4 id="5-2-3-Exploiting-the-locality-of-outputs-利用输出的局部性"><a href="#5-2-3-Exploiting-the-locality-of-outputs-利用输出的局部性" class="headerlink" title="5.2.3 Exploiting the locality of outputs. | 利用输出的局部性"></a>5.2.3 Exploiting the locality of outputs. | 利用输出的局部性</h4><p>&emsp;&emsp;在分类器层和卷积层，对于NBIN中包含的一组输入神经元，计算Tn个输出神经元的部分输出和。然后，输入神经元被用于另一块Tn输出神经元，等等。这就产生了两个问题。</p><p>&emsp;&emsp;<strong>专用寄存器。</strong>首先，虽然输入神经元的块是从NBIN加载并用于计算部分和的，但是让部分和离开NFU流水线，然后为NBIN缓冲器的每个条目将其重新加载到流水线中将是低效的，因为数据传输是能量消耗的主要来源[14]。因此，我们在NFU-2中引入了专用寄存器来存储部分和。</p><p>&emsp;&emsp;<strong>循环缓冲区。</strong>其次，一个更复杂的问题是，当NBIN中的输入神经元被重新用于一组新的Tn输出神经元时，如何处理Tn部分和。我们不是将这些Tn部分和发送回内存(稍后在下一块输入神经元加载到NBIN时重新加载它们)，而是暂时将它们轮换出到NBOUT。先验地，这是nbout的冲突角色，nbout还用于存储要写回内存(写缓冲区)的最终输出神经元。但在实践中，只要没有将所有输入神经元都整合到部分和中，NBout就是空闲的。因此，我们可以通过将Tn部分和轮换到NBout来将其用作临时存储缓冲区，如图11所示。自然，在输出神经元上迭代的循环必须平铺，以便同时计算其部分和的输出神经元不会超过NBout的容量，但这是通过类似于图5和图7中的循环nnn的二级平铺来实现的。因此，NBout不仅连接到NFU-3和存储器，而且还连接到NFU-2：NBout的一个条目可以加载到NFU-2的专用寄存器中，并且这些寄存器可以存储在NBout中。</p><h3 id="5-3-Control-and-Code-控件和代码"><a href="#5-3-Control-and-Code-控件和代码" class="headerlink" title="5.3 Control and Code | 控件和代码"></a>5.3 Control and Code | 控件和代码</h3><h4 id="5-3-1-CP"><a href="#5-3-1-CP" class="headerlink" title="5.3.1 CP"></a>5.3.1 CP</h4><p>&emsp;&emsp;在本节中，我们将介绍加速器的控制。控制的一种方法是硬连线三个目标层。虽然这仍然是未来的一个选择，但目前，我们已经决定使用控制指令来探索层的不同实现(例如，分区和调度)，并为机器学习研究人员提供尝试不同层实现的灵活性。</p><p><img src="https://api-img.alapi.cn/image/2020/10/17/c0d8057af0589c4498f459f34159c86e.png" style="zoom:80%;" /></p><p>&emsp;&emsp;一层执行被分解成一组指令。粗略地说，一条指令对应于分类器层和卷积层的环路II，i，n，见图5和7，以及池层中的环路II，i(使用第5.2.3节所述的交织机制)，见图8。指令存储在与控制处理器(CP)相关的SRAM中，见图11。CP驱动三个缓冲器和NFU的DMA的执行。术语“处理器”只涉及前面提到的“指令”，稍后将在第5.3.2节中介绍，但它几乎没有处理器的传统功能(主要是一台PC和一个用于循环索引和地址计算的加法器)；从硬件的角度来看，它更像是一个可配置的FSM。</p><h4 id="5-3-2-Layer-Code-图层代码"><a href="#5-3-2-Layer-Code-图层代码" class="headerlink" title="5.3.2 Layer Code. | 图层代码"></a>5.3.2 Layer Code. | 图层代码</h4><p>&emsp;&emsp;每条指令都有对应于CP本身、三个缓冲器和ﬁ的NFUVE槽，参见表3。</p><p>&emsp;&emsp;因为有CP指令，所以需要代码生成，但在我们的例子中，编译器就太过分了，因为只需要生成三种主要类型的代码。因此，我们为这三层实现了三个专用的代码生成器。在表4中，我们给出了一个为分类器/感知器层生成的代码示例。由于Tn=16(每缓存行16×16位数据)，并且NBIN有64行，所以它的容量是2KB，所以它不能包含所有的输入神经元(Ni=8192，所以16KB)。结果，代码被分解为在2KB的块上操作；注意，NBIN的第一条指令是LOAD(从存储器中取出的数据)，并且它被标记为重用(紧接在加载之后的标志)；下一条指令是READ，因为这些输入神经元在缓冲器中被旋转用于Tn神经元的下一块，并且READ也被标记为被重用，因为有8个这样的旋转(16KB2KB)；同时，请注意，第一条(和下一条)指令的NFU-2输出为NBOUT，即部分输出神经元和旋转为NBOUT，如第5.2.3节所述，这就是NBOUT指令为WRITE的原因；另请注意，NFU-2的输入已复位(第一块输入神经元，寄存器复位)。最后，当最后一块输入神经元被发送时(表中的最后一条指令)，NBout的(存储)DMA被设置为写入512字节(256个输出)，并且NBout指令被存储；下一条指令的NBout写入操作将是NOP(在第一个块设置DMA，并自动将数据存储回存储器，直到DMA结束)。</p><p>&emsp;&emsp;注意，该体系结构可以实现每个图像或批处理[41]，只有生成的层控制代码会改变。</p><h2 id="6-Experimental-Methodology-实验方法论"><a href="#6-Experimental-Methodology-实验方法论" class="headerlink" title="6. Experimental Methodology | 实验方法论"></a>6. Experimental Methodology | 实验方法论</h2><p><strong>&emsp;&emsp;尺寸。</strong>我们使用三种不同的工具来测量性能/能量。</p><p>&emsp;&emsp;<em>加速器模拟器。</em>我们实现了加速器结构的自定义周期精确度、位精确度的C++模拟器，最初用于架构探索，后来用作Verilog实现的规范。该模拟器还用于测量循环次数的时间。它被插入到允许高达250 Gb/s带宽的主内存模型中。</p><p>&emsp;&emsp;<em>CAD工具。</em>对于面积、能量和关键路径延迟(周期时间)测量，我们实现了一个Verilog版本的加速器，我们首先使用Synopsys Design Compiler使用TSMC 65 nm GP标准VT库进行合成，然后使用Synopsys ICC编译器进行放置和布线。然后，我们使用Synopsys VCS对设计进行了仿真，并使用黄金时间px估计了功耗。</p><p>SIMD。对于SIMD基线，我们使用GEM5+McPAT[28]组合。我们使用4个问题的超标量x86内核，带有128位(8×16位)SIMD单元(SSE/SSE2)，时钟频率为2 GHz。内核具有192个条目的ROB和64个条目的加载/存储队列。一级数据(和指令)高速缓存为32KB，二级高速缓存为2MB；这两个高速缓存均为8路联合高速缓存，并使用64字节线；这些高速缓存特性与英特尔酷睿i7的高速缓存特性相对应。到L2的L1未命中等待时间为10个周期，到存储器的L2未命中等待时间为250个周期；存储器总线宽度为256位。通过使用McPAT提供的数据(例如，256位读取存储器访问的能量成本为17.6nJ)，我们已经对加速器和模拟器的主存储器访问的能量成本进行了调整。</p><p>&emsp;&emsp;我们实现了不同层代码的SIMD版本，如第3节所述，我们手动调优了它的局部性(对于每一层，我们执行随机探索以找到好的平铺因子)；我们使用DEFAULT-O优化级别编译这些程序，但内部循环是用汇编语言编写的，以最大限度地利用SIMD单元。为了评估SIMD内核的性能，我们还实现了下面给出的不同基准层的标准C++版本，平均(几何平均值)，我们观察到SIMD内核的执行时间是x86内核的3.92倍，能耗是x86内核的3.74倍。</p><p><img src="https://api-img.alapi.cn/image/2020/10/17/27ecfca0fbd9e0a181a7e43b4ede545e.png" style="zoom:50%;" /></p><p><strong>&emsp;&emsp;基准。</strong>对于基准，我们选择了几个最新的大型神经网络结构中最大的卷积、汇集和/或分类器层。表5显示了这10个层的特征以及相关神经网络和任务的描述。</p><h2 id="7-Experimental-Results-实验结果"><a href="#7-Experimental-Results-实验结果" class="headerlink" title="7. Experimental Results | 实验结果"></a>7. Experimental Results | 实验结果</h2><h3 id="7-1-Accelerator-Characteristics-after-Layout-布局后的加速器特性"><a href="#7-1-Accelerator-Characteristics-after-Layout-布局后的加速器特性" class="headerlink" title="7.1 Accelerator Characteristics after Layout | 布局后的加速器特性"></a>7.1 Accelerator Characteristics after Layout | 布局后的加速器特性</h3><p>&emsp;&emsp;当前版本使用Tn=16(16个硬件神经元，每个具有16个突触)，因此该设计在NFU-1中包含256个16位截断乘法器(用于分类器和卷积层)，在NFU-2中包含16个加法器树，每个加法器包含15个加法器(对于相同的层，如果使用平均值，则加上合并层)，以及NFU-2中的16输入移位器和最大值(用于合并层)，以及16位截断乘法器加上NFU-3中的16个加法器(用于分类器和卷积层，以及可选的用于合并层)。对于分类器和卷积层，NFU-1和NFU-2每个周期都是活动的，每个周期实现256+16×15=496次定点运算；在0.98 GHz，这相当于452 GOP/s(每秒千兆定点运算)。在层的末尾，当NFU-1和NFU-2处理剩余数据时，NFU-3也将处于活动状态，在短时间内达到496+2×16=528次/周期(482GOP/s)的峰值活动。</p><p>&emsp;&emsp;我们使用Synopsys工具完成了65 nm处Tn=16和64入口缓冲器的综合和布局，见图15。主要特性和按元件类型和功能块细分的功耗/面积如表6所示。我们通过在NFU-1(乘法器)、NFU-2(加法器树)和NFU-3(分段线性函数近似)中引入3级流水线，将关键路径延迟降至1.02 ns，共8个流水线级。在NFU-1(乘法器)、NFU-2(加法器树)和NFU-3(分段线性函数近似)中引入3级流水线，使关键路径延迟降至1.02 ns。目前，关键路径在负责从NBIN/NBOUT中读取数据的问题逻辑中；下一个版本将重点介绍如何减少或输送此关键路径。总RAM容量(NBIN+NBOUT+SB+CP指令)为44KB(CP RAM为8KB)。面积和功耗分别由缓冲器(NBIN/NBOUT/SB)控制，分别为56%和60%，NFU紧随其后，分别为28%和27%。小区总功率的百分比为59.47%，但路由网络(包括在表细分的不同组成部分中)在总功率中所占的比例很大，为38.77%。在65 nm处，由于加速器的高翻转率，漏功率在1.73%几乎可以忽略不计。</p><p>&emsp;&emsp;最后，我们还评估了Tn=8的设计，因此在NFU-1中有64个乘法器。该设计的总面积为0.85mm2，即由于缓冲器宽度减小和算术运算符数量减少，比Tn=16小3.59倍。我们计划在不久的将来研究Tn=32或64的更大的设计。</p><h3 id="7-2-Time-and-Throughput-时间和吞吐量"><a href="#7-2-Time-and-Throughput-时间和吞吐量" class="headerlink" title="7.2 Time and Throughput | 时间和吞吐量"></a>7.2 Time and Throughput | 时间和吞吐量</h3><p>&emsp;&emsp;在图16中，我们报告了加速器在SIMD上的加速比，请参阅SIMD/ACC。回想一下，我们使用的是128位SIMD处理器，因此每个周期能够执行多达8个16位操作(我们在SIMD中自然也使用16位定点操作)。如7.1节所述，加速器每个周期为分类器层和卷积层执行496次16位操作，即比SIMD内核多62倍(4968)。我们经验地观察到，在这两种类型的层上，加速器的速度平均是SIMD核的117.87倍，因此比计算运算符的比率(62倍)高出约2倍。我们测量到，对于分类器层和卷积层，SIMD内核平均每个周期执行2.01个16位运算，而不是每个周期8个运算的上限。我们将其追溯到两个主要原因。</p><p><img src="https://api-img.alapi.cn/image/2020/10/17/7d966085beb97ba46a799eff95dc25f6.png" style="zoom:80%;" /></p><p>&emsp;&emsp;首先，NBIN和SB缓冲区中的预加载和重用的适当组合带来了更好的延迟容忍度；请注意，我们没有在SIMD内核中实现预取器，这将在一定程度上弥补这一差距。这解释了具有最大特征地图大小的层1、类3和层5的高性能差距，这些层具有最大的特征地图大小，因此具有最大的空间局部性，从而使ﬁ从预加载中受益最大，从而使它们的性能提升平均为629.92倍，大约是其他卷积层的3倍；我们预计SIMD核中的预取器将抵消这种性能提升。DMA沿着输入特征映射维度利用NBIN中的空间局部性，并且对于较小的NI，DMA必须发出许多短内存请求，这降低了效率。其余卷积层(CONV1到CONV4)的平均加速比为195.15倍；由于私有内核和较小的空间局部性，CONV2的性能较差(130.64倍)。由于仅使用NFU-2中的加法器树(496个运算符中有240个运算符)，POOL3和POOL5分别使用25.73x和25.52x，因此池化层的整体性能较低。</p><p><img src="https://api-img.alapi.cn/image/2020/10/17/fb0b51cd8dd03c9318aa6252f12930e0.png" style="zoom:80%;" /></p><p>&emsp;&emsp;为了进一步分析POOL1的相对较差的行为(仅为SIMD的2.17倍)，我们测试了加速器的一种配置，其中所有操作数(输入和突触)都为NFU做好了准备，即NBIN、SB和NBOUT的理想行为；我们称此版本为“理想”，参见图16。我们看到，POOL1和CONV2上的加速器明显慢于理想配置(分别为66.00x和16.14x)。这是由于它们的输入/输出特征映射的大小较小(例如，对于POOL1，N1=12)，并且用于POOL1的运算符较少。到目前为止，加速器面向的是大型层，但我们可以通过实现2D或3D DMA(<script type="math/tex">i, k_x, k_y</script>循环上的DMA请求)来解决这一弱点；我们将此优化留到以后的工作中。</p><p>&emsp;&emsp;SIMD的加速比超过62倍的第二个原因在于控制和调度开销。在加速器中，我们试图将丢失的周期降到最低。例如，当输出神经元部分和旋转到NBOUT(在发送回NFU-2之前)时，最旧的缓冲行(<script type="math/tex">T_n</script>部分和)会急切地向外旋转到NBOUT/NFU-2输入锁存器，并且NFU-2中的多路复用器确保此锁存器或NFU-2寄存器用作NFU-2级计算的输入；这允许在没有任何流水线停滞的情况下旋转。几个这样的设计优化帮助实现了仅比理想加速器慢4.36倍的速度，参见图16，事实上，只有在不包括CONV2和POOL1的情况下，慢速才是2.64倍。</p><h3 id="7-3-Energy-能源"><a href="#7-3-Energy-能源" class="headerlink" title="7.3 Energy | 能源"></a>7.3 Energy | 能源</h3><p>&emsp;&emsp;在图17中，我们提供了SIMD内核和加速器之间的能量比。虽然平均能量比高达21.08x，但实际上比之前报道的处理器和加速器之间的能量比小了一个数量级以上；例如，Hameed等人。[14]报告能量比约为500x，小型多层感知器的能量比为974x[38]。较小的比率很大程度上是由于在存储器访问上花费的能量，这一点在上述两项研究中自愿没有考虑在内。与这两个加速器和其他加速器一样，通过更高效的计算运算符(特别是在我们的例子中，大量小型16位定点截断乘法器)和靠近运算符的小型自定义存储(64条目NBIN、NBOUT、SB和NFU-2寄存器)的组合，计算的能源成本已大大降低。因此，现在存在能量的Amdahl定律效应，只有通过降低主存储器访问的能量成本才能实现任何进一步的改进。我们试图人为地将SIMD和加速器中的主存储器访问的能量成本设置为0，我们观察到加速器的平均能量降低增加了一个数量级以上，与之前的结果一致。</p><p><img src="https://api-img.alapi.cn/image/2020/10/17/db74b50ece48eb0264aad2b6509886eb.png" style="zoom:67%;" /></p><p>&emsp;&emsp;图18中加速器消耗的能量细目进一步说明了这一点，其中主存储器访问的能量显然占主导地位。一个遥远的第二个是具有共享核(CONV1，CONV3，CONV4)的卷积层的NBIN/NBOUT的能量。在这种情况下，一组共享内核保留在SB中，因此由于突触导致的内存流量变得非常低，如第3节(共享内核+平铺)中所解释的，但是仍然必须为每组新的共享内核重新加载输入神经元，因此仍然存在明显的能量消耗。池化层(POOL1、POOL3、POOL5)中的计算逻辑的能量同样是一个遥远的第二开销，这一次是因为没有要加载的突触。池层的能耗降低稍高(平均为22.17倍)，参见图17，这是由于未使用SB缓冲区(无突触)，而且由于NBIN的宽度较小，单独访问NBIN的成本相对较低，参见图13。</p><p>&emsp;&emsp;SIMD的能量细分形成鲜明对比，如图19所示，大约三分之二的能量花在计算上，只有三分之一的能量花在存储器访问上。虽然找到一种计算效率更高的SIMD方法是有意义的，但加速器未来的工作应该集中在减少内存访问所花费的能量上。</p><h2 id="8-Related-Work-相关工作"><a href="#8-Related-Work-相关工作" class="headerlink" title="8. Related Work | 相关工作"></a>8. Related Work | 相关工作</h2><p>&emsp;&emsp;由于严格的能源限制，如Dark Silicon[10，32]，越来越多的人一致认为，未来的高性能微体系结构将采用异构多核的形式，即核和加速器的组合。加速器的范围可以从针对某些任务调谐的处理器到诸如H264[14]的类似ASIC的电路，或者能够针对广泛但不是所有任务[12，44] 诸如QsCores[42]的更灵活的加速器，或者用于图像处理[33]的加速器。</p><p>&emsp;&emsp;本文中提出的加速器遵循了这种精神，即针对特定但广泛的领域，即这里的机器学习任务。由于机器学习的最新进展，某些类型的神经网络，特别是深度神经网络[25]和卷积神经网络[27]，已经在诸如网络搜索[19]、图像分析[31]或语音识别[7]的广泛应用中成为最先进的机器学习技术[26]。</p><p>&emsp;&emsp;虽然在过去的二十年里已经研究了许多硬件神经元和神经网络的实现[18]，但是硬件神经网络的主要目的是快速建模生物神经网络[20，34]，以实现具有数千个连接的神经元。虽然这些神经形态结构中有几个已经应用于计算任务[30，43]，但它们所依赖的特定生物启发信息表示(尖峰神经网络)可能无法与最先进的神经网络竞争，尽管这在神经科学和机器学习之间仍然是一个开放的辩论。</p><p>&emsp;&emsp;然而，最近，由于应用、机器学习和技术限制的同步趋势，硬件神经网络已经越来越多地被认为是潜在的加速器，要么是用于处理器内非常专用的功能，如分支预测[1]，要么是因为它们的容错特性[15，38]。后一种特性也被用来通过硬件神经处理单元[9，11]来交换应用程序的准确性以换取能效[9，11]。</p><p>&emsp;&emsp;我们的加速器的重点是大规模的机器学习任务，有数千层神经元和数百万个突触，因此特别强调与记忆的互动。我们的研究不仅与ﬁRMS以前观察到的专用存储是实现良好性能和功耗的关键[14]相反，而且它还强调，除了在靠近计算运算符的寄存器级别利用局部性[33，38]之外，将内存视为素数阶考虑可以深刻地影响加速器设计。</p><p>&emsp;&emsp;前面提到的许多研究都源于架构界。一项对称的努力已经在机器学习领域开始了，在那里，一些研究人员一直在研究加速神经网络处理的硬件设计，特别是对于实时应用。NeuFlow[13]是用于视觉系统的CNN前馈路径的快速和低功耗实现的加速器。它根据卷积层和池层的滑动窗口特性来组织计算和寄存器级存储，但在这方面，它也忽略了来自输入和输出特征映射的大部分一阶局部性。虽然DMA能够执行复杂的访问模式，但它与存储器的相互作用仍然局限于DMA，没有重要的片上存储。Kim等人提出了一种更复杂的架构，尽管其性能与NeuFlow相似。[21]并且由128个SIMD处理器组成，每个处理器16个PE；该体系结构明显更大，并且实现了特定的神经视觉模型(既不是CNN也不是DNNs)，但是它可以实现多达10个不同对象的60帧/秒(实时)多对象识别。Maashri等人。[29]还研究了另一种神经网络模型—用于视觉处理的仿生HMAX模型的实现，该模型使用一组布置在交换结构周围的自定义加速器；在文章中，作者提到了跨不同方向的局部性优化，其大致相当于特征映射的HMAX。Chakradhar等人再次接近我们的社区，但只关注CNNs。[3]还研究了CNN在可重构电路上的实现，虽然对局部性开发的重视较少，但为了提高带宽利用率，他们特别注意对CNN进行适当的映射。</p><h2 id="9-结论"><a href="#9-结论" class="headerlink" title="9.结论"></a>9.结论</h2><p>&emsp;&emsp;在本文中，我们将重点放在机器学习的加速器上，因为加速器的应用范围很广，而且很少有关键的最先进的算法，这为将高效率和广泛的应用范围结合起来提供了难得的机会。由于最先进的CNN和DNN意味着非常大的网络，我们特别关注大规模层的实现。通过仔细利用这些层的局部性属性，并通过引入定制设计的存储结构来利用这些属性，我们展示了在非常小的占地面积内设计能够高性能的机器学习加速器是可能的。我们的测量结果并不局限于加速器结构，它们将主内存传输的性能和能量开销考虑在内；不过，我们表明，在采用普通高速缓存层次结构的128位2 GHz SIMD内核上，可以实现117.87倍的加速比和21.08倍的能耗降低。我们已经得到了65 nm的设计版图。</p><p>&emsp;&emsp;除了计划的磁带输出之外，未来的工作还包括改进短层的加速器行为、略微更改NFU以包括一些最新的算法改进，如本地响应标准化、进一步降低主内存传输的影响、调查可伸缩性(特别是增加<script type="math/tex">T_n</script>)，以及实施硬件培训。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;
        
      
    
    </summary>
    
    
      <category term="论文翻译" scheme="https://rhythmlian.cn/categories/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="机器学习" scheme="https://rhythmlian.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>通过云服务器实现远程登录内网服务器</title>
    <link href="https://rhythmlian.cn/2020/08/18/ssh-to-intranet/"/>
    <id>https://rhythmlian.cn/2020/08/18/ssh-to-intranet/</id>
    <published>2020-08-18T12:14:58.000Z</published>
    <updated>2020-08-18T13:29:08.524Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>相信总会有小伙伴苦恼如何登录上公司或学校的内网服务器，为了解决这个问题我近期也是踩了不少坑，终于有一套方案是可行的。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="https://shop.io.mi-img.com/app/shop/img?id=shop_100be6e5044612dfdad634a7335b6cd8.png" alt=""></p><p>如图，我们的目的是从<code>D</code>连接到<code>A</code>，但是由于<code>A</code>在内网中，并不具备公网ip，因此实际上<code>D</code>无法主动建立<code>D-&gt;B-&gt;A</code>的通路。但是还有一种方案是：</p><ul><li><code>A</code>主动建立<code>A-&gt;B-&gt;C</code>的双向通路</li><li><code>D</code>主动建立<code>D-&gt;C</code>的双向通路</li><li><code>C</code>负责转发来自<code>A-&gt;B-&gt;C</code>和<code>D-&gt;C</code>的数据</li></ul><p>这样，我们建立起来了<code>A&lt;-&gt;B&lt;-&gt;C&lt;-&gt;D</code>的通路。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ol><li>一台你的具备公网ip的服务器</li><li>两台可能都在内网的电脑、服务器</li></ol><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="配置公网服务器"><a href="#配置公网服务器" class="headerlink" title="配置公网服务器"></a>配置公网服务器</h3><ol><li><p>首先，开放一个公网服务器的空闲端口，假设为<code>8022</code></p></li><li><p>修改<code>/etc/ssh/sshd_config</code>中<code>GatewayPorts</code>、<code>AllowAgentForwarding</code>为<code>yes</code>，并重启<code>sshd</code>服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure></li><li><p>从防火墙 | 路由表开放<code>8022</code>端口：</p><ul><li>如果使用<code>firewall</code>:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl start firewalld</span><br><span class="line">firewall-cmd --add-port=8022/tcp --permanent</span><br><span class="line">firewall-cmd --add-port=8022/udp --permanent</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">firewall-cmd --zone=public --query-port=8022/tcp</span><br></pre></td></tr></table></figure><ul><li>如果使用<code>iptables</code>:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p udp -d 0/0 -s 0/0 --dport 8022  -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp -d 0/0 -s 0/0 --dport 8022  -j ACCEPT</span><br><span class="line">netfilter-persistent save</span><br><span class="line">netfilter-persistent reload</span><br></pre></td></tr></table></figure></li></ol><h3 id="建立SSH隧道"><a href="#建立SSH隧道" class="headerlink" title="建立SSH隧道"></a>建立SSH隧道</h3><ol><li><p>在需要被访问的内网服务器上执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nohup ssh -fR 8022:127.0.0.1:内网服务器SSH端口 root@远程服务器IP -p 远程服务器SSH端口 "vmstat 30"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 内网服务器SSH端口默认值: 22</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 远程服务器SSH端口默认值: 22</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> vmstat 30 是防止远程服务器主动断开长时间未通信的链接</span></span><br></pre></td></tr></table></figure></li><li><p>可能需要输入密码建立连接</p></li></ol><h3 id="登录内网服务器"><a href="#登录内网服务器" class="headerlink" title="登录内网服务器"></a>登录内网服务器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 8022 内网用户名@公网服务器IP</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;
        
      
    
    </summary>
    
    
      <category term="攻略" scheme="https://rhythmlian.cn/categories/%E6%94%BB%E7%95%A5/"/>
    
    
      <category term="攻略" scheme="https://rhythmlian.cn/tags/%E6%94%BB%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>将静态博客托管到腾讯云</title>
    <link href="https://rhythmlian.cn/2020/08/15/deploy-blog-on-tencentcloud/"/>
    <id>https://rhythmlian.cn/2020/08/15/deploy-blog-on-tencentcloud/</id>
    <published>2020-08-15T13:09:33.000Z</published>
    <updated>2020-08-15T14:11:23.556Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>为什么要将静态博客托管到腾讯云呢？</p><ol><li>依赖于良心云Serverless以及cdn技术可以大幅加快国内的访问速度；</li><li>对比coding page以及GitHub page，尽管良心云托管静态网站并不是完全免费的，但对于小规模流量的静态博客来讲几乎是白嫖；（关键是它快呀.jpg</li></ol><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol><li>你的静态博客的前端内容，比如<code>hexo</code>框架下，前端内容是<code>public</code>文件夹下的全部内容</li><li>一个可用的域名（否则无法使用cdn）</li><li>一个腾讯云账号</li><li>npm环境</li></ol><h2 id="安装命令工具cloudbase"><a href="#安装命令工具cloudbase" class="headerlink" title="安装命令工具cloudbase"></a>安装命令工具<code>cloudbase</code></h2><p>为了用户们能更好的利用良心云的serverless服务，良心云提供了个<code>cloudbase</code>的SDK，安装方法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g @cloudbase/cli</span><br></pre></td></tr></table></figure><p>如果你遇到了权限问题，可以考虑：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g @cloudbase/cli</span><br></pre></td></tr></table></figure><p>完成命令后如果没有错误提示，代表安装成功，你可以采用如下命令验证：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cloudbase -v</span><br></pre></td></tr></table></figure><p>看到有版本号输出则说明安装成功。（<code>tcb</code>命令与<code>cloudbase</code>命令等价）</p><p>在正式使用<code>cloudbase</code>前，你需要进行登录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcb login</span><br></pre></td></tr></table></figure><h2 id="静态托管"><a href="#静态托管" class="headerlink" title="静态托管"></a>静态托管</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>良心云连续两月每月赠送<code>5GB</code>流量和<code>1G</code>的存储空间用于托管静态网站（对于普通用户足够了），你可以通过<a href="https://console.cloud.tencent.com/tcb/hosting/index" target="_blank" rel="noopener">链接</a>创建你的<code>静态网站托管</code>项目，成功后，左上角会有一串id用来独立标识你的静态网站项目（你需要将它保存）。</p><p><img src="https://p.pstatp.com/origin/ffd20001bc2a12095e46" alt=""></p><p>通过<code>命令行/终端</code>进入你的静态网站内容所在的文件夹，并运行如下命令将内容上传至腾讯云：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cloudbase hosting:deploy hosting -e [你刚刚保存的id]</span><br></pre></td></tr></table></figure><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>点击腾讯云控制台左上角的<code>基础配置</code>，可以看到：</p><p><img src="https://p.pstatp.com/origin/137a60001055423200cbd" alt=""></p><p>点击<code>添加域名</code>，并填入你的域名（注意，由于腾讯云需要支持https访问，因此你需要具备一个SSL证书，如果你没有，你可以通过腾讯云免费申请）。完成后，进入你的域名配置，添加一条<code>CNAME</code>解析记录，并将值填为上图中<code>CNAME下显示的地址</code>，等待几分钟即可。绑定成功后，<code>状态</code>下将显示<code>已启动</code>。</p><p>至此，你已经完成了将静态博客托管到腾讯云（容易的一批）；通过你设置的域名即可访问静态博客了。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;
        
      
    
    </summary>
    
    
      <category term="攻略" scheme="https://rhythmlian.cn/categories/%E6%94%BB%E7%95%A5/"/>
    
    
      <category term="攻略" scheme="https://rhythmlian.cn/tags/%E6%94%BB%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>QuickStart_Rhy中文文档</title>
    <link href="https://rhythmlian.cn/2020/08/09/QuickStart-Rhy-zh/"/>
    <id>https://rhythmlian.cn/2020/08/09/QuickStart-Rhy-zh/</id>
    <published>2020-08-08T19:31:58.000Z</published>
    <updated>2020-09-07T03:32:33.075Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="/2020/02/14/QuickStart-Rhy/">English Document</a> | 中文文档 </p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install quickstart-rhy [--upgrade]</span><br></pre></td></tr></table></figure><h3 id="qs的配置表：-qsrc"><a href="#qs的配置表：-qsrc" class="headerlink" title="qs的配置表：.qsrc"></a>qs的配置表：<code>.qsrc</code></h3><ul><li>自qs 0.3.0版本起，当您初次安装QuickStart_Rhy并通过命令运行<code>qs</code>时，<code>qs</code>将在如下位置生成qs的配置表<code>.qsrc</code></li></ul><div class="table-container"><table><thead><tr><th>系统</th><th>位置</th></tr></thead><tbody><tr><td>Windows</td><td>C:\Users\<code>你的用户名</code>\.qsrc</td></tr><tr><td>*nix</td><td>/Users/<code>你的用户名</code>/.qsrc</td></tr></tbody></table></div><ul><li><code>.qsrc</code>是以json格式存储的配置表，当它初次被生成时，内容为：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 文档中的注释内容在文件中不存在 */</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"basic_settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"default_language"</span>: <span class="string">"zh"</span>,                              <span class="comment">/* !默认语言，zh表示中文，en为英文    */</span></span><br><span class="line">    <span class="attr">"default_translate_engine"</span>: &#123;                          <span class="comment">/* !默认语言引擎，请勿修改support    */</span></span><br><span class="line">      <span class="attr">"index"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"support"</span>: [<span class="string">"default"</span>, <span class="string">"TencentCloud"</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"default_proxy"</span>: <span class="string">"用户名:密码@ip:端口 或 ip:端口"</span>         <span class="comment">/* 设置下载代理，启用`-px`时通过代理下载 */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"API_settings"</span>: &#123;                                        <span class="comment">/* 填入你需要用的API KEY              */</span></span><br><span class="line">    <span class="attr">"rmbg"</span>: <span class="string">"GET: https://www.remove.bg"</span>,</span><br><span class="line">    <span class="attr">"smms"</span>: <span class="string">"GET: https://sm.ms"</span>,</span><br><span class="line">    <span class="attr">"darksky"</span>: <span class="string">"GET: https://darksky.net/"</span>,</span><br><span class="line">    <span class="attr">"aliyun_oss_acid"</span>: <span class="string">"GET: https://www.aliyun.com/product/oss"</span>,</span><br><span class="line">    <span class="attr">"aliyun_oss_ackey"</span>: <span class="string">"GET: https://www.aliyun.com/product/oss"</span>,</span><br><span class="line">    <span class="attr">"aliyun_oss_bucket_url"</span>: <span class="string">"GET: https://www.aliyun.com/product/oss"</span>,</span><br><span class="line">    <span class="attr">"aliyun_oss_df_bucket"</span>: <span class="string">"GET: https://www.aliyun.com/product/oss"</span>,</span><br><span class="line">    <span class="attr">"txyun_scid"</span>: <span class="string">"GET: https://console.cloud.tencent.com/"</span>,</span><br><span class="line">    <span class="attr">"txyun_sckey"</span>: <span class="string">"GET: https://console.cloud.tencent.com/"</span>,</span><br><span class="line">    <span class="attr">"txyun_cos_df_bucket"</span>: <span class="string">"GET: https://console.cloud.tencent.com/"</span>,</span><br><span class="line">    <span class="attr">"txyun_df_region"</span>: <span class="string">"GET: ap-[location]"</span>,</span><br><span class="line">    <span class="attr">"qiniu_ac_key"</span>: <span class="string">"GET: http://qiniu.com/"</span>,</span><br><span class="line">    <span class="attr">"qiniu_sc_key"</span>: <span class="string">"GET: http://qiniu.com/"</span>,</span><br><span class="line">    <span class="attr">"qiniu_bk_name"</span>: <span class="string">"GET: [Qiniu Bucket Name]"</span>,</span><br><span class="line">    <span class="attr">"gitee"</span>: <span class="string">"GET: http://gitee.com/"</span>,</span><br><span class="line">    <span class="attr">"ipinfo"</span>: <span class="string">"GET: https://ipinfo.io/"</span>,</span><br><span class="line">    <span class="attr">"AipImageAPP_ID"</span>: <span class="string">"GET: https://cloud.baidu.com/product/imageprocess"</span>,</span><br><span class="line">    <span class="attr">"AipImageAPP_KEY"</span>: <span class="string">"GET: https://cloud.baidu.com/product/imageprocess"</span>,</span><br><span class="line">    <span class="attr">"AipImageSECRET_KEY"</span>: <span class="string">"GET: https://cloud.baidu.com/product/imageprocess"</span>,</span><br><span class="line">    <span class="attr">"AipNlpAPP_ID"</span> : <span class="string">"GET: https://cloud.baidu.com/product/nlp_apply"</span>,</span><br><span class="line">    <span class="attr">"AipNlpAPP_KEY"</span>: <span class="string">"GET: https://cloud.baidu.com/product/nlp_apply"</span>,</span><br><span class="line">    <span class="attr">"AipNlpSECRET_KEY"</span>: <span class="string">"GET: https://cloud.baidu.com/product/nlp_apply"</span>,</span><br><span class="line">    <span class="attr">"seafile_communicate_path"</span>: <span class="string">"GET: /Path/to/file"</span>,</span><br><span class="line">    <span class="attr">"alapi_token"</span>: <span class="string">"GET: https://www.alapi.net/"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关于默认语言：</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">标志</th><th style="text-align:center">语言</th><th style="text-align:center">标志</th><th style="text-align:center">语言</th><th style="text-align:center">标志</th><th style="text-align:center">语言</th></tr></thead><tbody><tr><td style="text-align:center">zh</td><td style="text-align:center">🇨🇳</td><td style="text-align:center">en</td><td style="text-align:center">🇬🇧</td><td style="text-align:center">jp</td><td style="text-align:center">🇯🇵</td></tr><tr><td style="text-align:center">kor</td><td style="text-align:center">🇰🇷</td><td style="text-align:center">fra</td><td style="text-align:center">🇫🇷</td><td style="text-align:center">spa</td><td style="text-align:center">🇪🇸</td></tr><tr><td style="text-align:center">th</td><td style="text-align:center">🇹🇭</td><td style="text-align:center">ara</td><td style="text-align:center">阿拉伯</td><td style="text-align:center">ru</td><td style="text-align:center">🇷🇺</td></tr><tr><td style="text-align:center">pt</td><td style="text-align:center">🇵🇹</td><td style="text-align:center">de</td><td style="text-align:center">🇩🇪</td><td style="text-align:center">it</td><td style="text-align:center">🇮🇹</td></tr><tr><td style="text-align:center">el</td><td style="text-align:center">🇬🇷</td><td style="text-align:center">nl</td><td style="text-align:center">🇵🇱</td><td style="text-align:center">bul</td><td style="text-align:center">🇧🇬</td></tr><tr><td style="text-align:center">est</td><td style="text-align:center">🇪🇪</td><td style="text-align:center">dan</td><td style="text-align:center">🇩🇰</td><td style="text-align:center">fin</td><td style="text-align:center">🇫🇮</td></tr><tr><td style="text-align:center">cs</td><td style="text-align:center">🇨🇿</td><td style="text-align:center">rom</td><td style="text-align:center">🇷🇴</td><td style="text-align:center">slo</td><td style="text-align:center">🇸🇮</td></tr><tr><td style="text-align:center">swe</td><td style="text-align:center">🇸🇪</td><td style="text-align:center">hu</td><td style="text-align:center">🇭🇺</td><td style="text-align:center">vie</td><td style="text-align:center">🇻🇳</td></tr></tbody></table></div><ul><li>关于<a href="#API">API</a>，某些API需要依赖官方提供的Python第三方库，但并不是每位用户都会用到它们，为了保持qs安装时的轻松畅快，qs在安装时不会将这些Python第三方库作为依赖项预先安装。因此，如果你需要使用相关的API，请在下方的API对照表中选择安装。</li><li><code>*特殊说明</code>：qs的某些方便功能高度依赖alapi.net，因此你可以考虑注册成为alapi的免费用户以获得更好的使用体验。</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><div class="table-container"><table><thead><tr><th>命令</th><th>含义</th><th>类别</th></tr></thead><tbody><tr><td><code>qs -u url</code></td><td>使用默认浏览器打开多个链接</td><td>基础</td></tr><tr><td><code>qs -a app [files]</code></td><td>打开应用或使用应用打开文件（仅支持Mac OS）</td><td>基础</td></tr><tr><td><code>qs -f file</code></td><td>使用合适的应用打开文件</td><td>基础</td></tr><tr><td><code>qs -cal exp</code></td><td>计算算术表达式</td><td>基础</td></tr><tr><td><code>qs -time</code></td><td>查看当前时间</td><td>基础</td></tr><tr><td><code>qs -top</code></td><td>CPU和内存监控器</td><td>系统</td></tr><tr><td><code>qs -clear</code></td><td>释放本机内存</td><td>系统</td></tr><tr><td><code>qs -mktar path ...</code></td><td>使用多个文件或文件夹创建tar压缩包</td><td>系统</td></tr><tr><td><code>qs -untar path ...</code></td><td>解压各种格式的tar包</td><td>系统</td></tr><tr><td><code>qs -mkzip path ...</code></td><td>使用多个文件或文件夹创建zip压缩包</td><td>系统</td></tr><tr><td><code>qs -unzip path ...</code></td><td>解压zip压缩包</td><td>系统</td></tr><tr><td><code>qs -unrar path ...</code></td><td>解压rar压缩包</td><td>系统</td></tr><tr><td><code>qs -http [ip:port] [-bind url]</code></td><td>在当前路径下开启简单的多线程http服务</td><td>网络</td></tr><tr><td><code>qs -netinfo [url ...]</code></td><td>获取命令参数或剪切板中链接或ip的信息</td><td>网络</td></tr><tr><td><code>qs -wifi</code></td><td>扫描附近WiFi并选择连接</td><td>网络</td></tr><tr><td><code>qs -dl [urls] [--help]</code></td><td>从命令参数或剪切板中链接下载文件 (<a href="https://rhythmlian.cn/2020/03/23/qs-dl/">qs下载策略</a>)</td><td>网络</td></tr><tr><td><code>qs -upload</code></td><td>上传你的pypi仓库</td><td>网络</td></tr><tr><td><code>qs -upgrade</code></td><td>更新qs</td><td>网络</td></tr><tr><td><code>qs -trans [words]</code></td><td>翻译命令参数或剪切板中的内容</td><td>API</td></tr><tr><td><code>qs -rmbg picture</code></td><td>移除图片背景</td><td>API</td></tr><tr><td><code>qs -smms picture/*.md</code></td><td>将图片或Markdown中图片上传至sm.ms</td><td>API</td></tr><tr><td><code>qs -upimg -help</code></td><td>将图片或Markdown中图片上传至多平台（暂无需token）</td><td>API</td></tr><tr><td><code>qs -alioss -help</code></td><td>获取阿里云对象存储的使用帮助</td><td>API</td></tr><tr><td><code>qs -txcos -help</code></td><td>获取腾讯云对象存储的使用帮助</td><td>API</td></tr><tr><td><code>qs -qiniu -help</code></td><td>获取七牛云对象存储的使用帮助</td><td>API</td></tr><tr><td><code>qs -weather [address]</code></td><td>获取当地天气（或指定地址天气）</td><td>API</td></tr><tr><td><code>qs -LG image</code></td><td>通过百度图像效果增强放大图片</td><td>API</td></tr><tr><td><code>qs -nlp [words]</code></td><td>通过百度NLP对<code>words</code>或剪切板内容纠错</td><td>API</td></tr><tr><td><code>qs -sea get/post [msg]</code></td><td>通过Seafile获取或传递内容</td><td>API</td></tr><tr><td><code>qs -pasteme get/post [password/content]</code></td><td>通过pasteme.cn获取或传递内容</td><td>API</td></tr><tr><td><code>qs -bcv [url/video code]</code></td><td>获取B站视频、直播封面图片</td><td>API</td></tr><tr><td><code>qs -gbc garbage...</code></td><td>中国垃圾分类查询 (仅支持中文)</td><td>API</td></tr><tr><td><code>qs -svi url</code></td><td>获取命令参数或剪切板内短视频分享链接的信息</td><td>API</td></tr><tr><td><code>qs -svd url</code></td><td>通过命令参数或剪切板内短视频分享链接下载视频</td><td>API</td></tr><tr><td><code>qs -stbg picture to [from]</code></td><td>替换图片颜色（from默认为透明）</td><td>图像</td></tr><tr><td><code>qs -v2gif video [sz] [fps]</code></td><td>将视频导出为gif</td><td>图像</td></tr><tr><td><code>qs -v2mp4 video</code></td><td>将视频导出为mp4</td><td>图像</td></tr><tr><td><code>qs -rmaudio video</code></td><td>删除视频的音频（仅返回mp4文件）</td><td>图像</td></tr></tbody></table></div><p>(顺便说一下，如果你是中国石油大学(北京)的学生，可以运行<code>qs -i</code>登录学校网)</p><h2 id="新功能-bcv-gbc-svi-svd"><a href="#新功能-bcv-gbc-svi-svd" class="headerlink" title="新功能: bcv, gbc, svi/svd!"></a>新功能: <code>bcv</code>, <code>gbc</code>, <code>svi/svd</code>!</h2><h3 id="bcv：BiliBili视频背景"><a href="#bcv：BiliBili视频背景" class="headerlink" title="bcv：BiliBili视频背景"></a>bcv：BiliBili视频背景</h3><div class="table-container"><table><thead><tr><th style="text-align:center">Use</th><th style="text-align:center">Result</th></tr></thead><tbody><tr><td style="text-align:center"><img src="https://upload.ouliu.net/i/20200728234446hjej1.png" alt=""></td><td style="text-align:center"><img src="https://p.pstatp.com/origin/ffb6000140d19240ffc9" style="zoom:50%;" /></td></tr></tbody></table></div><ul><li>下载Bilibili视频图像，支持<code>视频网址</code>比如<code>https://www.bilibili.com/video/BV1J4y197Ht</code>或<code>视频号</code>比如<code>BV1J4y197Ht</code>。</li></ul><h3 id="gbc：垃圾分类"><a href="#gbc：垃圾分类" class="headerlink" title="gbc：垃圾分类"></a>gbc：垃圾分类</h3><p><img src="https://p.pstatp.com/origin/1382d00003d8573540947" alt=""></p><ul><li>垃圾分类查询~（仅支持中文搜索）</li></ul><h3 id="svi-svd"><a href="#svi-svd" class="headerlink" title="svi/svd"></a>svi/svd</h3><p><img src="https://p.pstatp.com/origin/137260001501a2a0feb66" alt=""></p><ul><li>svd: 解析短视频的分享链接，输出视频与封面的直链地址并下载为mp4（采用qs内置下载引擎，生成mp4依赖<code>moviepy</code>库，需自行安装）</li><li>svi: 仅解析短视频链接，输出视频相关信息，不做下载。</li></ul><h2 id="好消息"><a href="#好消息" class="headerlink" title="好消息!"></a>好消息!</h2><ul><li>您可以在app <a href="https://u.tools" target="_blank" rel="noopener">uTools</a>上搜索这个项目的文档!</li></ul><p><img src="http://p9.qhimg.com/t012c5a3773e80c2008.jpg" alt=""></p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><ul><li><strong>QuickStart-Rhy提供一些流行的在线平台的api，所以你可以用qs做令人惊奇的事情!</strong></li><li><strong>您需要亲自到适当的网站注册，并填写所需的API密钥，以确保正确调用qs</strong></li><li><strong>编辑的<code>~ /.qsrc</code>来设置你的API!</strong></li></ul><h3 id="支持的-API"><a href="#支持的-API" class="headerlink" title="支持的 API"></a>支持的 API</h3><div class="table-container"><table><thead><tr><th style="text-align:center">API</th><th style="text-align:center">官网</th><th style="text-align:center">Pypi库</th><th style="text-align:center">键值</th></tr></thead><tbody><tr><td style="text-align:center">remove bg</td><td style="text-align:center"><a href="https://www.remove.bg/zh" target="_blank" rel="noopener">link</a></td><td style="text-align:center">None</td><td style="text-align:center">“rmbg”</td></tr><tr><td style="text-align:center">smms</td><td style="text-align:center"><a href="https://sm.ms" target="_blank" rel="noopener">link</a></td><td style="text-align:center">None</td><td style="text-align:center">“smms”</td></tr><tr><td style="text-align:center"><br />Aliyun OSS</td><td style="text-align:center"><br /><a href="https://www.aliyun.com/product/oss" target="_blank" rel="noopener">link</a></td><td style="text-align:center"><br /><code>oss2</code></td><td style="text-align:center">“aliyun_oss_acid”<br />“aliyun_oss_ackey”<br />“aliyun_oss_df_bucket”<br />“aliyun_oss_bucket_url”</td></tr><tr><td style="text-align:center"><br />Qiniu OSS</td><td style="text-align:center"><br /><a href="http://qiniu.com/" target="_blank" rel="noopener">link</a></td><td style="text-align:center"><br /><code>qiniu</code></td><td style="text-align:center">“qiniu_ac_key”<br />“qiniu_sc_key”<br />“qiniu_bk_name”</td></tr><tr><td style="text-align:center"><br />Tencent  COS</td><td style="text-align:center"><br /><a href="https://console.cloud.tencent.com/cos5" target="_blank" rel="noopener">link</a></td><td style="text-align:center"><br /><code>cos-python-sdk-v5</code></td><td style="text-align:center">“txyun_scid”<br />“txyun_sckey”<br />“txyun_df_region”<br />“txyun_cos_df_bucket”<br /></td></tr><tr><td style="text-align:center">IPinfo</td><td style="text-align:center"><a href="https://ipinfo.io" target="_blank" rel="noopener">link</a></td><td style="text-align:center"><code>ipinfo</code></td><td style="text-align:center">“ipinfo”</td></tr><tr><td style="text-align:center">Baidu Image <br />Process</td><td style="text-align:center"><br /><a href="https://cloud.baidu.com/product/imageprocess" target="_blank" rel="noopener">link</a></td><td style="text-align:center"><br /><code>aip</code></td><td style="text-align:center">“AipImageAPP_ID”<br />“AipImageAPP_KEY”<br />“AipImageSECRET_KEY”</td></tr><tr><td style="text-align:center"><br />Baidu NLP</td><td style="text-align:center"><br /><a href="https://cloud.baidu.com/product/imageprocess" target="_blank" rel="noopener">link</a></td><td style="text-align:center"><br /><code>aip</code></td><td style="text-align:center">“AipNlpAPP_ID”<br />“AipNlpAPP_KEY”<br />“AipNlpSECRET_KEY”</td></tr><tr><td style="text-align:center">Tencent translate</td><td style="text-align:center"><a href="https://cloud.tencent.com/product/tmt" target="_blank" rel="noopener">link</a></td><td style="text-align:center"><code>tencentcloud-sdk-python</code></td><td style="text-align:center">“txyun_scid”<br />“txyun_sckey”<br />“txyun_df_region”</td></tr><tr><td style="text-align:center">alapi</td><td style="text-align:center"><a href="https://www.alapi.net" target="_blank" rel="noopener">link</a></td><td style="text-align:center">None</td><td style="text-align:center">“alapi_token”</td></tr></tbody></table></div><h3 id="API-用法"><a href="#API-用法" class="headerlink" title="API 用法"></a>API 用法</h3><h4 id="rmbg"><a href="#rmbg" class="headerlink" title="rmbg"></a>rmbg</h4><div class="table-container"><table><thead><tr><th style="text-align:center">Raw</th><th style="text-align:center">Processed</th></tr></thead><tbody><tr><td style="text-align:center"><img src="https://vip1.loli.net/2020/02/29/qwYb2JkSEeIlB9V.jpg" style="zoom:60%;" /></td><td style="text-align:center"><img src="https://vip1.loli.net/2020/02/29/wTRszv6EofNSr9K.png" alt=""></td></tr></tbody></table></div><h4 id="smms"><a href="#smms" class="headerlink" title="smms"></a>smms</h4><ul><li>上传图片:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜ Desktop $ qs -smms IMG_4758.jpeg  </span><br><span class="line">+---------------+--------+---------------------------+</span><br><span class="line">|      File     | Status |            url            |</span><br><span class="line">+---------------+--------+---------------------------+</span><br><span class="line">| IMG_4758.jpeg |  True  | https://*.loli.net/*t.jpg |</span><br><span class="line">+---------------+--------+---------------------------+</span><br></pre></td></tr></table></figure><ul><li>将markdown文件中图像上传，并将图像路径替换为url。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜ Desktop $ qs -smms test.md  </span><br><span class="line">+---------------+--------+---------------------------+</span><br><span class="line">|      File     | Status |            url            |</span><br><span class="line">+---------------+--------+---------------------------+</span><br><span class="line">|     1.jpg     |  True  | https://*.loli.net/1.jpg  |</span><br><span class="line">|     2.jpg     |  True  | https://*.loli.net/2.jpg  |</span><br><span class="line">|     3.jpg     |  True  | https://*.loli.net/3.jpg  |</span><br><span class="line">+---------------+--------+---------------------------+</span><br></pre></td></tr></table></figure><h4 id="Aliyun-OSS"><a href="#Aliyun-OSS" class="headerlink" title="Aliyun OSS"></a>Aliyun OSS</h4><div class="table-container"><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>qs -alioss -up file [bucket]</code></td><td>上传文件到桶/默认桶</td></tr><tr><td><code>qs -alioss -rm file [bucket]</code></td><td>删除桶中的文件</td></tr><tr><td><code>qs -alioss -dl file [bucket]</code></td><td>从桶中下载文件</td></tr><tr><td><code>qs -alioss -ls [bucket]</code></td><td>获取桶中的文件信息</td></tr></tbody></table></div><h5 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Bucket Url: https://***.aliyuncs.com/</span><br><span class="line">+--------------------------------+------------+</span><br><span class="line">|              File              |    Size    |</span><br><span class="line">+--------------------------------+------------+</span><br><span class="line">| 单片机原理及应用教程第3版.pdf      |  25.156 MB |</span><br><span class="line">| 计算机网络（第7版）-谢希仁.pdf     |  70.780 MB |</span><br><span class="line">|        软件工程导论.pdf          | 100.819 MB |</span><br><span class="line">+--------------------------------+------------+</span><br></pre></td></tr></table></figure><h4 id="Qiniu-OSS"><a href="#Qiniu-OSS" class="headerlink" title="Qiniu OSS"></a>Qiniu OSS</h4><div class="table-container"><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>qs -qiniu -up file [bucket]</code></td><td>上传文件到桶/默认桶</td></tr><tr><td><code>qs -qiniu -rm file [bucket]</code></td><td>删除桶中的文件</td></tr><tr><td><code>qs -qiniu -cp url  [bucket]</code></td><td>从url拷贝文件到桶中</td></tr><tr><td><code>qs -qiniu -dl file [bucket]</code></td><td>从桶中下载文件</td></tr><tr><td><code>qs -qiniu -ls [bucket]</code></td><td>获取桶中的文件信息</td></tr></tbody></table></div><h5 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜ hexo $ qs -qiniu -ls</span><br><span class="line">Bucket url: http://***.bkt.clouddn.com/</span><br><span class="line">+----------------------------+------------+</span><br><span class="line">|            File            |    Size    |</span><br><span class="line">+----------------------------+------------+</span><br><span class="line">|     591918ca03491.jpg      | 522.393 KB |</span><br><span class="line">|     BaiduExporter.zip      |  64.810 KB |</span><br><span class="line">|         BitBar.zip         |   6.361 MB |</span><br><span class="line">|         cover.png          | 342.704 KB |</span><br><span class="line">|        ev-cover.png        | 483.959 KB |</span><br><span class="line">| google-access-helper-2.zip | 111.958 KB |</span><br><span class="line">|       weather.15m.py       |  13.386 KB |</span><br><span class="line">+----------------------------+------------+</span><br></pre></td></tr></table></figure><h4 id="Tencent-COS"><a href="#Tencent-COS" class="headerlink" title="Tencent COS"></a>Tencent COS</h4><div class="table-container"><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>qs -txcos -up file [bucket]</code></td><td>上传文件到桶/默认桶</td></tr><tr><td><code>qs -txcos -rm file [bucket]</code></td><td>删除桶中的文件</td></tr><tr><td><code>qs -txcos -dl file [bucket]</code></td><td>从桶中下载文件</td></tr><tr><td><code>qs -txcos -ls [bucket]</code></td><td>获取桶中的文件信息</td></tr></tbody></table></div><h5 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜ hexo $ qs -txcos -ls</span><br><span class="line">Bucket url: http://***.myqcloud.com/</span><br><span class="line">+----------------------------+------------+</span><br><span class="line">|            File            |    Size    |</span><br><span class="line">+----------------------------+------------+</span><br><span class="line">|           1.jpg            | 522.393 KB |</span><br><span class="line">|     BaiduExporter.zip      |  64.810 KB |</span><br><span class="line">|         BitBar.zip         |   6.361 MB |</span><br><span class="line">|        ev-cover.png        | 483.959 KB |</span><br><span class="line">|        gd-cover.png        | 342.704 KB |</span><br><span class="line">| google-access-helper-2.zip | 111.958 KB |</span><br><span class="line">|       weather.15m.py       |  13.386 KB |</span><br><span class="line">+----------------------------+------------+</span><br></pre></td></tr></table></figure><h4 id="ipinfo"><a href="#ipinfo" class="headerlink" title="ipinfo"></a>ipinfo</h4><ul><li>只提供一个函数:<code>QuickStart_Rhy.api.ipinfo(ip:str=None)</code>，它将返回一个包含ip信息的dict。</li></ul><h5 id="样例-3"><a href="#样例-3" class="headerlink" title="样例"></a>样例</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> QuickStart_Rhy.api <span class="keyword">import</span> ipinfo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ipinfo(<span class="string">'114.114.114.114'</span>)</span><br><span class="line">&#123;<span class="string">'ip'</span>: <span class="string">'114.114.114.114'</span>, <span class="string">'hostname'</span>: <span class="string">'public1.114dns.com'</span>, <span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'region'</span>: <span class="string">'Beijing'</span>, <span class="string">'country'</span>: <span class="string">'CN'</span>, <span class="string">'loc'</span>: <span class="string">'39.9075,116.3972'</span>, <span class="string">'org'</span>: <span class="string">'AS174 Cogent Communications'</span>, <span class="string">'timezone'</span>: <span class="string">'Asia/Shanghai'</span>, <span class="string">'country_name'</span>: <span class="string">'China'</span>, <span class="string">'latitude'</span>: <span class="string">'39.9075'</span>, <span class="string">'longitude'</span>: <span class="string">'116.3972'</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="Tencent-Translate"><a href="#Tencent-Translate" class="headerlink" title="Tencent Translate"></a>Tencent Translate</h4><ul><li>在经历了几种不稳定的翻译API后，我决定使用腾讯云机翻译作为qs的翻译引擎之一，所以如果你想使用翻译服务，你需要安装一些库，将你的账号信息设置在<code>~/.qsrc</code>。 </li></ul><h5 id="样例-4"><a href="#样例-4" class="headerlink" title="样例"></a>样例</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> qs -trans Looking <span class="keyword">in</span> indexes</span></span><br><span class="line">查找索引</span><br></pre></td></tr></table></figure><h4 id="netinfo"><a href="#netinfo" class="headerlink" title="netinfo"></a>netinfo</h4><p><img src="https://i.loli.net/2020/07/07/29F7iKpRnl3adJx.png" alt="demo"></p><ul><li>如图所示，您可以通过使用网址、ip地址或<code>me(关键字)</code>来获取ip信息!</li></ul><h4 id="upimg"><a href="#upimg" class="headerlink" title="upimg"></a>upimg</h4><p><img src="http://p6.qhimg.com/t01e0e9c1c36fa434ad.jpg" alt=""></p><ul><li><code>upimg</code>有与<code>smms</code>相同的功能，但<code>upimg</code>不需要API键。<br>它支持多平台上传你的图片，但我不保证它是安全的上传图片到任何平台。</li></ul><h2 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h2><p><strong>不满足于只在命令行上使用qs? qs现在提供了实用的工具来帮助您更快地开发Python应用程序! </strong></p><h3 id="ImageTools"><a href="#ImageTools" class="headerlink" title="ImageTools"></a>ImageTools</h3><ul><li><p>ColorTools.py: </p><ul><li><p><code>QuickStart_Rhy.ImageTools.ColorTools.get_color_from_str(str_color)</code>: get (R, G, B, A=255) from <code>str_color</code></p><p>样例:</p></li></ul></li></ul><div class="table-container"><table><thead><tr><th>call</th><th>return</th></tr></thead><tbody><tr><td><code>get_color_from_str(&#39;0,0,0,0&#39;)</code></td><td>(0, 0, 0, 0)</td></tr><tr><td><code>get_color_from_str(&#39;0,0,0&#39;)</code></td><td>(0, 0, 0, 255)</td></tr><tr><td><code>get_color_from_str(&#39;FFFFFF&#39;)</code></td><td>(255, 255, 255, 255)</td></tr></tbody></table></div><ul><li><p><code>QuickStart_Rhy.ImageTools.ColorTools.transport_back(src: str, to_color, from_color=(0, 0, 0, 0))</code>: 将图片 <code>Image.open(src)</code>中颜色 <code>from_color</code> 替换为 <code>to_color</code>。</p><p>样例:</p></li></ul><div class="table-container"><table><thead><tr><th>call</th><th>return</th></tr></thead><tbody><tr><td><code>transport_back(&#39;test.jpg&#39;, (0, 0, 0, 255))</code></td><td>Replace the transparent color with white</td></tr></tbody></table></div><h3 id="NetTools"><a href="#NetTools" class="headerlink" title="NetTools"></a>NetTools</h3><ul><li><p><code>QuickStart_Rhy.NetTools.check_one_page(url)</code>: 确定url是否可访问。</p></li><li><p><code>QuickStart_Rhy.NetTools.formatUrl(try_url)</code>: 尝试添加<a href="https://或http://以使`try_url`可以访问(不能保证返回值可以访问" target="_blank" rel="noopener">https://或http://以使`try_url`可以访问(不能保证返回值可以访问</a>)</p></li><li><p><code>QuickStart_Rhy.NetTools.get_ip()</code>: 获取局域网下当前机器的IP</p></li><li><p><code>QuickStart_Rhy.NetTools.size_format(sz, align=False)</code>: 格式化文件大小<code>1000000 -&gt;  1.000 MB</code>(如果不对齐，则为<code>1.000 MB</code>)</p></li><li><p><code>QuickStart_Rhy.NetTools.get_ip_info()</code>: 返回字典</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  'status': 'success', </span><br><span class="line">  'country': 'China', </span><br><span class="line">  'countryCode': 'CN', </span><br><span class="line">  'region': 'Province name abbreviations', </span><br><span class="line">  'regionName': 'Province name', </span><br><span class="line">  'city': 'City', </span><br><span class="line">  'zip': '', </span><br><span class="line">  'lat': latitude, </span><br><span class="line">  'lon': longitude, </span><br><span class="line">  'timezone': 'Asia/Shanghai', </span><br><span class="line">  'isp': 'Network operator', </span><br><span class="line">  'org': 'Network operator + location', </span><br><span class="line">  'as': 'AS4134 Chinanet', </span><br><span class="line">  'query': 'Your public IP'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>QuickStart_Rhy.NetTools.get_fileinfo(url)</code>: 返回可下载的链接, 文件名和头部信息.</p></li></ul><h3 id="ThreadTools"><a href="#ThreadTools" class="headerlink" title="ThreadTools"></a>ThreadTools</h3><ul><li><p><code>QuickStart_Rhy.ThreadTools.ThreadFunctionWrapper(threading.Thread)</code>: 打开一个新线程来运行函数。</p><ul><li><code>__init__(self, function, *args, **kwargs)</code> </li><li><code>run(self)</code>: 开始运行</li><li><code>get_res(self)</code>: 获取运行结果</li></ul></li><li><p><code>QuickStart_Rhy.ThreadTools.FileWriters</code>: 写文件线程池</p><ul><li><code>__init__(self, filename, workers, mode)</code>: 模式样例: <code>r+</code>, <code>w</code>, <code>rb+</code>, <code>wb</code></li><li><code>wait(self)</code>: 等待线程池所有线程工作完毕</li><li><code>new_job(self, content, index)</code>: 加入新的任务</li></ul><p><strong>文件必须已经创建并预先分配了足够的空间</strong></p></li></ul><h3 id="TuiTools"><a href="#TuiTools" class="headerlink" title="TuiTools"></a>TuiTools</h3><ul><li><code>QuickStart_Rhy.TuiTools.get_console_width()</code>: 顾名思义，获取控制台宽度</li><li><code>QuickStart_Rhy.TuiTools.Bar.RollBar</code>:支持在命令行上滚动条形图，您可以运行<code>qs -top</code>来查看效果。</li><li><code>QuickStart_Rhy.TuiTools.Line.Line</code>: 在命令行上支持折线图，您可以运行<code>qs -weather</code>来查看效果。</li></ul><h3 id="Wrappers"><a href="#Wrappers" class="headerlink" title="Wrappers"></a>Wrappers</h3><ul><li><p><code>QuickStart_Rhy.Wrapper.set_timeout(num)</code>: 函数包装器使函数在指定的时间<code>num</code>内结束。</p><ul><li>样例:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> QuickStart_Rhy.Wrapper <span class="keyword">import</span> set_timeout</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="meta">@set_timeout(2)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fuck</span><span class="params">(who)</span>:</span></span><br><span class="line">  time.sleep(<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'fuck &#123;&#125;'</span>.format(who)</span><br><span class="line"><span class="comment"># 返回 False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@set_timeout(2)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fuck</span><span class="params">(who)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'fuck &#123;&#125;'</span>.format(who)</span><br><span class="line"><span class="comment"># 返回 'fuck &#123;&#125;'.format(who)</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;
        
      
    
    </summary>
    
    
      <category term="文档" scheme="https://rhythmlian.cn/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="Python开源库文档" scheme="https://rhythmlian.cn/tags/Python%E5%BC%80%E6%BA%90%E5%BA%93%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>uTools旧版翻译插件安装</title>
    <link href="https://rhythmlian.cn/2020/07/25/Old-uTools-Translate/"/>
    <id>https://rhythmlian.cn/2020/07/25/Old-uTools-Translate/</id>
    <published>2020-07-25T06:02:16.000Z</published>
    <updated>2020-07-25T06:15:45.943Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>由于旧版的uTools翻译插件是通过非正当途径获取翻译API，目前已被官方下架。如果仍想使用旧版翻译插件，可以通过离线安装的方式。</p><h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p><img src="https://img.vim-cn.com/de/bd30857c033e943bf0ea43bcebdd4f2eea618b.png" alt=""></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>点击链接，下载插件：<a href="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/0004eb94f50e6c63095840eff2eeb0d9.asar" target="_blank" rel="noopener">0004eb94f50e6c63095840eff2eeb0d9.asar</a></li><li>关闭uTools（必须先关闭）</li><li>将<code>0004eb94f50e6c63095840eff2eeb0d9.asar</code>文件移动至你的uTools插件文件夹下<ol><li>Mac: <code>/Users/&lt;你的本机用户名&gt;/Library/Application Support/uTools/plugins</code></li><li>Windows: <code>C:\Users\&lt;你的本机用户名&gt;\AppData\Roaming\uTools\plugins</code></li><li>Linux需要自行寻找uTools插件文件夹位置</li></ol></li><li>打开uTools</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;
        
      
    
    </summary>
    
    
      <category term="攻略" scheme="https://rhythmlian.cn/categories/%E6%94%BB%E7%95%A5/"/>
    
    
      <category term="uTools" scheme="https://rhythmlian.cn/tags/uTools/"/>
    
  </entry>
  
  <entry>
    <title>Win10下Qt 5.14.2+VS2017环境配置与编译运行qwood</title>
    <link href="https://rhythmlian.cn/2020/07/06/QWoodRun/"/>
    <id>https://rhythmlian.cn/2020/07/06/QWoodRun/</id>
    <published>2020-07-05T18:40:19.000Z</published>
    <updated>2020-08-07T14:53:49.451Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="安装Visual-Studio-2017"><a href="#安装Visual-Studio-2017" class="headerlink" title="安装Visual Studio 2017"></a>安装Visual Studio 2017</h2><h3 id="下载并配置VS2017"><a href="#下载并配置VS2017" class="headerlink" title="下载并配置VS2017"></a>下载并配置VS2017</h3><ol><li>进入<a href="https://docs.microsoft.com/en-us/visualstudio/releasenotes/vs2017-relnotes" target="_blank" rel="noopener">Visual Studio官网</a>，点击蓝色按钮“Download Visual Studio 2017”，按照流程登录并下载即可。</li><li>打开已下载好的<code>Visual Studio Installer</code>程序，对<code>Visual Studio Community 2017</code>进行配置。</li><li>选择<code>工作负载</code>-&gt;<code>Windows(3)</code>-&gt;<code>使用C++的桌面开发</code>后，点击右下角确认即可。</li></ol><h3 id="安装Qt插件"><a href="#安装Qt插件" class="headerlink" title="安装Qt插件"></a>安装Qt插件</h3><ol><li><p>启动Visual Studio 2017后，看到如下界面：</p><p>  <img src="https://img-bed-rhythmlian.oss-cn-beijing.aliyuncs.com/QWoodReadMe/1.png" alt="1"></p></li><li><p>选择<code>工具</code>-&gt;<code>扩展和更新</code>-&gt;<code>联机</code>-&gt;<code>Visual Studio Marketplace</code>，并在右侧搜索处填入<code>Qt</code>:</p><p>  <img src="https://img-bed-rhythmlian.oss-cn-beijing.aliyuncs.com/QWoodReadMe/2.png" alt="2"></p><p>  安装即可，安装成功后，在VS2017窗口的菜单栏中会出现<code>Qt VS Tools</code>字段：</p><p>  <img src="https://img-bed-rhythmlian.oss-cn-beijing.aliyuncs.com/QWoodReadMe/3.png" alt="3"></p></li></ol><h2 id="安装Qt-5-14-2"><a href="#安装Qt-5-14-2" class="headerlink" title="安装Qt 5.14.2"></a>安装Qt 5.14.2</h2><h3 id="安装配置Qt-5-14-2环境"><a href="#安装配置Qt-5-14-2环境" class="headerlink" title="安装配置Qt 5.14.2环境"></a>安装配置Qt 5.14.2环境</h3><ol><li><p>进入<a href="http://download.qt.io/archive/qt/5.14/5.14.2/" target="_blank" rel="noopener">下载地址</a>，选择合适你系统版本的Qt安装包，在本文中我们选择<code>qt-opensource-windows-x86-5.14.2.exe</code>进行下载。</p><p>你可以直接点击下方链接下载：</p></li></ol><div class="table-container"><table><thead><tr><th>系统</th><th>链接</th></tr></thead><tbody><tr><td>Windows</td><td><a href="http://download.qt.io/archive/qt/5.14/5.14.2/qt-opensource-windows-x86-5.14.2.exe" target="_blank" rel="noopener">qt-opensource-windows-x86-5.14.2.exe</a></td></tr><tr><td>Mac OS X</td><td><a href="http://download.qt.io/archive/qt/5.14/5.14.2/qt-opensource-mac-x64-5.14.2.dmg" target="_blank" rel="noopener">qt-opensource-mac-x64-5.14.2.dmg</a></td></tr><tr><td>Linux</td><td><a href="http://download.qt.io/archive/qt/5.14/5.14.2/qt-opensource-linux-x64-5.14.2.run" target="_blank" rel="noopener">qt-opensource-linux-x64-5.14.2.run</a></td></tr></tbody></table></div><ol><li><p>下载成功后，运行刚刚下载好的<code>qt-opensource-windows-x86-5.14.2.exe</code>，需要注册Qt账户并通过邮箱确认。</p><p><img src="https://img-bed-rhythmlian.oss-cn-beijing.aliyuncs.com/QWoodReadMe/4.png" alt="4"></p><p>注册并成功登录后，一路下一步，直到<code>选择组件</code>部分。按如下配置选择：</p><p><img src="https://img-bed-rhythmlian.oss-cn-beijing.aliyuncs.com/QWoodReadMe/5.png" alt="5"></p><p>点击下一步，等待安装完毕后启动<code>Qt Creator</code>即安装完成。</p></li></ol><h3 id="配置Visual-Studio-2017中的Qt环境路径"><a href="#配置Visual-Studio-2017中的Qt环境路径" class="headerlink" title="配置Visual Studio 2017中的Qt环境路径"></a>配置Visual Studio 2017中的Qt环境路径</h3><ol><li><p>打开<code>Visual Studio 2017</code>，选择上方<code>Qt VS Tools</code>-&gt;<code>Qt Options</code>，点击右侧<code>add</code>-&gt;<code>...</code></p><p><img src="https://img-bed-rhythmlian.oss-cn-beijing.aliyuncs.com/QWoodReadMe/6.png" alt="6"></p></li><li><p>选择<code>MSVC 2017</code>的安装位置并确认：</p><p><img src="https://img-bed-rhythmlian.oss-cn-beijing.aliyuncs.com/QWoodReadMe/7.png" alt="7"></p></li></ol><h2 id="QWood项目编译与运行"><a href="#QWood项目编译与运行" class="headerlink" title="QWood项目编译与运行"></a>QWood项目编译与运行</h2><h3 id="获取QWood项目"><a href="#获取QWood项目" class="headerlink" title="获取QWood项目"></a>获取QWood项目</h3><ol><li><p>打开<code>cmd</code>，跳转到合适的位置并运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/thiagodnf/qwood.git</span><br></pre></td></tr></table></figure><p>（如果你的Windows没有git命令，建议百度<a href="https://www.baidu.com/s?ie=UTF-8&amp;wd=`Windows 10下安装git`" target="_blank" rel="noopener">Windows 10下安装git</a>）</p></li><li><p>运行完毕后，cmd当前目录下会生成一个<code>qwood</code>文件夹，进入后有如下目录结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">|-- Makefile</span><br><span class="line">|-- QWood.pro</span><br><span class="line">|-- QWood.pro.user</span><br><span class="line">|-- README.md</span><br><span class="line">|-- configdialog.cpp</span><br><span class="line">|-- configdialog.h</span><br><span class="line">|-- configdialogpageestruturas.cpp</span><br><span class="line">|-- configdialogpageestruturas.h</span><br><span class="line">|-- configdialogpageestruturas.ui</span><br><span class="line">|-- configdialogpages.cpp</span><br><span class="line">|-- configdialogpages.h</span><br><span class="line">|-- dist</span><br><span class="line">|   |-- Makefile</span><br><span class="line">|   &#96;-- QWood</span><br><span class="line">|-- entradas</span><br><span class="line">|   |-- cpp-home.txt</span><br><span class="line">|   |-- entrada2.txt</span><br><span class="line">|   |-- entrada3.txt</span><br><span class="line">|   |-- entrada_100.txt</span><br><span class="line">|   |-- entrada_100_inv.txt</span><br><span class="line">|   |-- entrada_livro.txt</span><br><span class="line">|   |-- main</span><br><span class="line">|   |-- main.cpp</span><br><span class="line">|   &#96;-- problema.txt</span><br><span class="line">|-- images</span><br><span class="line">|   |-- buscar.png</span><br><span class="line">|   |-- cascata.png</span><br><span class="line">|   |-- config.png</span><br><span class="line">|   |-- config_estruturas.png</span><br><span class="line">|   |-- delete.png</span><br><span class="line">|   |-- favicon.ico</span><br><span class="line">|   |-- favicon2.ico</span><br><span class="line">|   |-- fechar_tudo.png</span><br><span class="line">|   |-- inserir.png</span><br><span class="line">|   |-- lado_a_lado.png</span><br><span class="line">|   |-- limpar.png</span><br><span class="line">|   |-- logo.png</span><br><span class="line">|   |-- logo_qt.jpeg</span><br><span class="line">|   |-- logo_qt.png</span><br><span class="line">|   |-- logotipo_base.png</span><br><span class="line">|   |-- logotipo_base.xcf</span><br><span class="line">|   |-- logotipo_base1.png</span><br><span class="line">|   |-- logotipo_base2.png</span><br><span class="line">|   |-- sair.png</span><br><span class="line">|   |-- screenshot.png</span><br><span class="line">|   |-- update.png</span><br><span class="line">|   |-- zoomIn.png</span><br><span class="line">|   &#96;-- zoomOut.png</span><br><span class="line">|-- main.cpp</span><br><span class="line">|-- mainwindow.cpp</span><br><span class="line">|-- mainwindow.h</span><br><span class="line">|-- moc_configdialog.cpp</span><br><span class="line">|-- moc_configdialogpageestruturas.cpp</span><br><span class="line">|-- moc_mainwindow.cpp</span><br><span class="line">|-- moc_qbase.cpp</span><br><span class="line">|-- moc_qconfigdialogpagesestruturas.cpp</span><br><span class="line">|-- moc_qdialogabrir.cpp</span><br><span class="line">|-- moc_qdialogarvoreb.cpp</span><br><span class="line">|-- moc_qdialogarvorebplus.cpp</span><br><span class="line">|-- moc_qdialoghash.cpp</span><br><span class="line">|-- qavl.cpp</span><br><span class="line">|-- qavl.h</span><br><span class="line">|-- qb.cpp</span><br><span class="line">|-- qb.h</span><br><span class="line">|-- qbase.cpp</span><br><span class="line">|-- qbase.h</span><br><span class="line">|-- qbnodo.cpp</span><br><span class="line">|-- qbnodo.h</span><br><span class="line">|-- qbplus.cpp</span><br><span class="line">|-- qbplus.h</span><br><span class="line">|-- qbplusnodo.cpp</span><br><span class="line">|-- qbplusnodo.h</span><br><span class="line">|-- qbst.cpp</span><br><span class="line">|-- qbst.h</span><br><span class="line">|-- qbstnodo.cpp</span><br><span class="line">|-- qbstnodo.h</span><br><span class="line">|-- qdialogabrir.cpp</span><br><span class="line">|-- qdialogabrir.h</span><br><span class="line">|-- qdialogabrir.ui</span><br><span class="line">|-- qdialogarvoreb.cpp</span><br><span class="line">|-- qdialogarvoreb.h</span><br><span class="line">|-- qdialogarvoreb.ui</span><br><span class="line">|-- qdialogarvorebplus.cpp</span><br><span class="line">|-- qdialogarvorebplus.h</span><br><span class="line">|-- qdialogarvorebplus.ui</span><br><span class="line">|-- qdialoghash.cpp</span><br><span class="line">|-- qdialoghash.h</span><br><span class="line">|-- qdialoghash.ui</span><br><span class="line">|-- qopenhash.cpp</span><br><span class="line">|-- qopenhash.h</span><br><span class="line">|-- qopenhashnodo.cpp</span><br><span class="line">|-- qopenhashnodo.h</span><br><span class="line">|-- qopenhashtable.cpp</span><br><span class="line">|-- qopenhashtable.h</span><br><span class="line">|-- qrc_qwood.cpp</span><br><span class="line">|-- qsplay.cpp</span><br><span class="line">|-- qsplay.h</span><br><span class="line">|-- qtrie.cpp</span><br><span class="line">|-- qtrie.h</span><br><span class="line">|-- qtrienodo.cpp</span><br><span class="line">|-- qtrienodo.h</span><br><span class="line">|-- qwood.qrc</span><br><span class="line">|-- ui_configdialogpageestruturas.h</span><br><span class="line">|-- ui_qconfigdialogpagesestruturas.h</span><br><span class="line">|-- ui_qdialogabrir.h</span><br><span class="line">|-- ui_qdialogarvoreb.h</span><br><span class="line">|-- ui_qdialogarvorebplus.h</span><br><span class="line">|-- ui_qdialoghash.h</span><br><span class="line">|-- ui_qordemarvoreB.h</span><br><span class="line">&#96;-- uml</span><br><span class="line">    &#96;-- QWood.xmi</span><br><span class="line"></span><br><span class="line">4 directories, 107 files</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用Qt-Creator运行QWood"><a href="#使用Qt-Creator运行QWood" class="headerlink" title="使用Qt Creator运行QWood"></a>使用Qt Creator运行QWood</h3><ol><li><p>运行<code>Qt Creator</code>，点击左上角<code>文件</code>-&gt;<code>打开文件或项目</code>，选择<code>qwood/QWood.pro</code>文件</p><p><img src="https://img-bed-rhythmlian.oss-cn-beijing.aliyuncs.com/QWoodReadMe/8.png" alt="8"></p></li><li><p>配置项目</p><p><img src="https://img-bed-rhythmlian.oss-cn-beijing.aliyuncs.com/QWoodReadMe/9.png" alt="9"></p></li><li><p>编译与运行（右下角绿色三角）</p><p><img src="https://img-bed-rhythmlian.oss-cn-beijing.aliyuncs.com/QWoodReadMe/10.png" alt="10"></p><p>在编译与运行时可能遇到如下<strong><code>问题及解决办法</code></strong>：</p><ol><li><p>函数无返回值</p><p><strong>样例</strong></p><p><img src="https://img-bed-rhythmlian.oss-cn-beijing.aliyuncs.com/QWoodReadMe/11.png" alt="11"></p><p><strong>解决方法：</strong></p><p>&emsp;&emsp;双击红色报错部分，进入出错位置，并在如图中位置添加<code>return nullptr;</code></p><p><img src="https://img-bed-rhythmlian.oss-cn-beijing.aliyuncs.com/QWoodReadMe/12.png" alt="12"></p><p>  &emsp;&emsp;注意：Qt Creator下方所有红色报错部分的相关文件都要更改。</p></li><li><p>缺少<code>QIntValidator</code>类型</p><p>&emsp;&emsp;如果是<code>.cpp</code>文件出错，翻到代码顶部，若发现与cpp文件同名的<code>.h</code>文件，按住<code>Ctrl</code>并点击<code>.h</code>文件名即可跳转到相应的<code>.h</code>文件中，在<code>.h</code>文件头部添加：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtGui/QIntValidator&gt;</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果是<code>.h</code>文件出错，直接在头部添加上面的代码即可。</p></li></ol><p>成功运行：</p><p><img src="https://img-bed-rhythmlian.oss-cn-beijing.aliyuncs.com/QWoodReadMe/13.png" alt="12"></p></li></ol><h3 id="使用VS2017运行QWood"><a href="#使用VS2017运行QWood" class="headerlink" title="使用VS2017运行QWood"></a>使用VS2017运行QWood</h3><h3 id="打开QWood"><a href="#打开QWood" class="headerlink" title="打开QWood"></a>打开QWood</h3><ol><li><p>运行VS2017，点击上方<code>Qt VS Tools</code>-&gt;<code>Open Qt Project File (.pro) ...</code>，选择<code>qwood/QWood.pro</code>文件。</p><p><img src="https://img-bed-rhythmlian.oss-cn-beijing.aliyuncs.com/QWoodReadMe/14.png" alt="14"></p><p>将项目编译方式选为：<code>Release</code>+<code>x86</code>，右侧红框内为项目结构。</p></li><li><p>编译并运行</p><p><img src="https://img-bed-rhythmlian.oss-cn-beijing.aliyuncs.com/QWoodReadMe/13.png" alt="13"></p></li></ol><h2 id="简单使用QWood"><a href="#简单使用QWood" class="headerlink" title="简单使用QWood"></a>简单使用QWood</h2><ol><li><p>点击左上角<code>Arquivo</code>-&gt;<code>Novo</code>-&gt;<code>AVL</code></p></li><li><p>在左上角的输入框内输入如下数字，每个数字按一次<code>回车键</code>或点击输入框右侧<code>+ Inserir</code>按钮添加数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 3 5 7 9 2 4 6 8 10</span><br></pre></td></tr></table></figure></li><li><p>运行效果</p><p><img src="https://img-bed-rhythmlian.oss-cn-beijing.aliyuncs.com/QWoodReadMe/15.png" alt="15"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;
        
      
    
    </summary>
    
    
      <category term="攻略" scheme="https://rhythmlian.cn/categories/%E6%94%BB%E7%95%A5/"/>
    
    
      <category term="C++" scheme="https://rhythmlian.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>解决GitHub图片显示问题</title>
    <link href="https://rhythmlian.cn/2020/06/29/github-img-issue/"/>
    <id>https://rhythmlian.cn/2020/06/29/github-img-issue/</id>
    <published>2020-06-29T07:19:19.000Z</published>
    <updated>2020-06-29T07:36:16.572Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="打开电脑中的hosts文件"><a href="#打开电脑中的hosts文件" class="headerlink" title="打开电脑中的hosts文件"></a>打开电脑中的hosts文件</h2><div class="table-container"><table><thead><tr><th>系统</th><th>PATH</th></tr></thead><tbody><tr><td>Windows</td><td><code>C:\Windows\System32\drivers\etc\hosts</code></td></tr><tr><td>Mac</td><td><code>/etc/hosts</code></td></tr><tr><td>Linux</td><td><code>/etc/hosts</code></td></tr></tbody></table></div><h2 id="添加如下内容"><a href="#添加如下内容" class="headerlink" title="添加如下内容"></a>添加如下内容</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># GitHub Start </span><br><span class="line">140.82.113.3      github.com</span><br><span class="line">140.82.114.20     gist.github.com</span><br><span class="line"></span><br><span class="line">151.101.184.133    assets-cdn.github.com</span><br><span class="line">151.101.184.133    raw.githubusercontent.com</span><br><span class="line">151.101.184.133    gist.githubusercontent.com</span><br><span class="line">151.101.184.133    cloud.githubusercontent.com</span><br><span class="line">151.101.184.133    camo.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars0.githubusercontent.com</span><br><span class="line">199.232.68.133     avatars0.githubusercontent.com</span><br><span class="line">199.232.28.133     avatars1.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars1.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars2.githubusercontent.com</span><br><span class="line">199.232.28.133     avatars2.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars3.githubusercontent.com</span><br><span class="line">199.232.68.133     avatars3.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars4.githubusercontent.com</span><br><span class="line">199.232.68.133     avatars4.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars5.githubusercontent.com</span><br><span class="line">199.232.68.133     avatars5.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars6.githubusercontent.com</span><br><span class="line">199.232.68.133     avatars6.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars7.githubusercontent.com</span><br><span class="line">199.232.68.133     avatars7.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars8.githubusercontent.com</span><br><span class="line">199.232.68.133     avatars8.githubusercontent.com</span><br><span class="line"></span><br><span class="line"># GitHub End</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;
        
      
    
    </summary>
    
    
      <category term="攻略" scheme="https://rhythmlian.cn/categories/%E6%94%BB%E7%95%A5/"/>
    
    
      <category term="攻略" scheme="https://rhythmlian.cn/tags/%E6%94%BB%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>法语文化专题知识点</title>
    <link href="https://rhythmlian.cn/2020/06/10/french-points/"/>
    <id>https://rhythmlian.cn/2020/06/10/french-points/</id>
    <published>2020-06-10T08:41:03.000Z</published>
    <updated>2020-06-10T09:21:00.450Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><div class="table-container"><table><thead><tr><th>数字</th><th>法语</th><th>数字</th><th>法语</th><th>数字</th><th>法语</th></tr></thead><tbody><tr><td>0</td><td>zero</td><td>10</td><td>dix</td><td>20</td><td>vingt</td></tr><tr><td>1</td><td>un</td><td>11</td><td>onze</td><td>30</td><td>trente</td></tr><tr><td>2</td><td>deux</td><td>12</td><td>douze</td><td>40</td><td>quarante</td></tr><tr><td>3</td><td>trois</td><td>13</td><td>treize</td><td>50</td><td>cinquante</td></tr><tr><td>4</td><td>quatre</td><td>14</td><td>quatorze</td><td>60</td><td>soixante</td></tr><tr><td>5</td><td>cinq</td><td>15</td><td>quinze</td><td>21</td><td>vingt et un</td></tr><tr><td>6</td><td>six</td><td>16</td><td>seize</td><td>22</td><td>vingt-deux</td></tr><tr><td>7</td><td>sept</td><td>17</td><td>dix-sept</td><td>23</td><td>vingt-trois</td></tr><tr><td>8</td><td>huit</td><td>18</td><td>dix-huit</td><td>24</td><td>vingt-quatre</td></tr><tr><td>9</td><td>neuf</td><td>19</td><td>dix-neuf</td><td>25</td><td>vingt-cinq</td></tr></tbody></table></div><h2 id="第一周-法语、法国国家象征"><a href="#第一周-法语、法国国家象征" class="headerlink" title="第一周 法语、法国国家象征"></a>第一周 法语、法国国家象征</h2><h3 id="法语历史"><a href="#法语历史" class="headerlink" title="法语历史"></a>法语历史</h3><ul><li><p>为什么古代法国被人称之为高卢（la Gaule）呢？</p><ul><li>大约公元前8世纪左右，源于德国西南的凯尔特人经莱茵河进入法国，后又来到塞纳河与卢瓦尔河，于公元前5世纪抵达大西洋沿岸和法国南部，他们征服了西南部的伊比利亚人（les lberes）、中央高原的阿奎丹人（les Aqultains）和东南部的利古里亚人（les Ligures），并与他们杂居融合。古罗马人把凯尔特人称之为高卢人（les Gaulols），把高卢人居住的地方称之为高卢。古代的法国成为高卢，就由此而来。这些凯尔特人在公元前6世纪的时候，还创造了被后人称之为拉登文化（la Tene calture）的铁器时代。</li></ul></li><li><p>古法语来源于高卢语吗？…当然不是。</p><ul><li>法国人的祖先是高卢人，那么高卢语想当然地也就是法语的前身了？然而，由于古代克尔特和高卢人的的宗教守护者德落伊教祭司（lesdruides)拒绝书面传授他们的知识，高卢语资料匿乏，这门语言随之消失，如果想要了解这门语言的结构，可以借鉴今天依然使用的布列塔尼语。</li><li>其实，早在公元前700-500年克尔特人入侵高卢这块土地是，当地已有人居住。其他民族在这之前就长时间地生活在这里。如：利古里亚人（Les Ligures)(Ligurians),世居于阿尔卑斯山南蓬、亚平宁山北段西黄至地中海岸之间。Les lberes(伊比利亚人）,Les Aquitains(阿奎丹人）但这些民族的语言大概不属于印欧语系。</li></ul></li><li><p>古法语来源于拉丁语吗？—是的，但是哪种拉丁语（quel latin)?</p><ul><li>凯尔特人成了高卢人，其使用的语言被人称之为高卢语，是一种古老的语言。公元前58年，罗马元老院派造政治家和军事统帅恺撒（Julius Cesar)率军远征高户。恺撒在高卢征战近10年，“约100万人被杀，近100万人沦为奴隶。”从此，高卢纳入罗马的国家版图，沦为罗马的一个省，揭开了高卢历史新的一页——罗马时代。这是法国文化发展史上很重要的一个转折点。高户并入罗马帝国。征服者带来的是高度发展的希腊罗马文化，大批罗马士兵、移民、商人、教士来到高卢，同时把他们的语言——拉丁语也带到了高卢。高卢人虽然有自己的语言，社会也有一定的发展，但是当时的高户文化还是比较落后，高卢人还没有比较完善的语言文字。因此，被拉丁文化同化了。罗马帝国使用的是统一的语言——拉丁语（le latin)。</li><li>高卢地区使用的不是公元前1世纪那些先哲们如凯撒、西塞罗或维吉尔等使用的书面拉丁话或古典拉丁语（le latin dit classique),而是通俗拉丁语（le latin vulgaire),是老百姓日常生活中使用的语言。后来，随着罗马帝国的瓦解，通俗拉丁语（le latinvulgaire)或说大众拉丁语（le latin populaire),被当地的本土语言影响，朝着不同的方向发展，最后形成了罗曼语族（les langues romanes)的法语、意大利语、西班牙话、葡萄牙语和罗马尼亚语等话种。</li></ul></li><li><p>高卢语对法语的影响</p><ul><li>古法语的根当然是通俗拉丁语。但是，在其漫长的发展过程中，受到诸多语种的影响。</li><li>首先是高卢语。词汇肯定是有高卢语的特征的。我们在学习法语的时候，对于法国人的70以上的数字，实在是不敢恭维。像小孩子一样加乘都来。这点，我们要怪罪高卢人。因为，以20为倍数的计算方式，就是来自高卢语。</li><li>据专家考证，法语动词变位中，第一人称复数的词尾-ons也是来自高卢语。</li><li>拉丁语对法语的影响：原本，拉丁语是一种有词形屈折变化的语言(la langue flexionnelle),它靠词形的变化来表示词与词之间的关系。由于受到诸上各种语言的影响和自身的发展，古法语慢慢变成了分析性语言（lalangue analytique),主要借助冠词、介词等工具词（或虚词）来表示词与词之间的关系。句子顺序非常重要。</li><li>另外，拉丁语的名词、形容词和代词都有6个格（就是主格（lenominatif)、宾格（l’accusatif)、属格（le genitif)、呼格（levocatif)、与格（le datif)、夺格（l’ablatif))的变化，加上复数就是12种。现代法语只剩下主宾两格。</li></ul></li><li><p>日耳要入侵及对法语的影响：</p><ul><li>公元5世纪，西罗马帝国衰落，日耳要人人侵高卢，在人侵者法兰克人，哥特人和勃民第人中，法兰克人对法语的影响缓大。其实，在公元5世纪入侵之前，法兰克人已经出现在高户的土地上。他们早期在罗马军队中当胖佣兵<br>(mercenaire)。在公元2世纪时，当地土地所有者因为没有安全感纷纷离开，三世纪时，法兰克人大批涌入并授权占领荒芜的地区。到了四世纪，高卢罗马贵族退同乡下，日耳要人定层在此并耕种土地。法兰克人占领高卢并不单一是日耳曼士兵人侵的原因，也是由于一些日耳要人早已与当地高户罗马人进行日常接触，并长期定层于此的结果。</li></ul></li><li>法兰克人占领北方，从索姆河（la Somme)到卢瓦尔河（la Loire),除了布列塔尼地区的整个北方。<ul><li>哥特人占领南方，从卢瓦尔河laLoire)到迪朗斯河（la Durance),</li></ul></li><li><p>勃民第人被妈奴从莱尚河中游驱赶到萨瓦地区，随后他们向四面八方扩张，包括勃民第，弗朗什孔泰和罗纳阿尔卑斯地区。</p><ul><li><p>在语言上，这种不同民族分片占领使不同地区操不同的方言。（dialecte)</p><ul><li><p>—dialecte d’oll au nord du territoire(oil-oui) 北方使用奥依语</p></li><li><p>—dialecte d’oc au sud (oc-oui) 南方使用奥克语</p></li><li><p>—-dialecte francoprovencaux中间地带使用普罗旺斯法语，覆盖了罗纳河中游盆地，里易日内瓦和格勒诺布尔地区）</p></li></ul></li></ul></li><li>每一种方言都对法语的漫长的演变及形成中发挥了作用。<ul><li>LesFrancs法兰克人   LesBurgondes勃民第人   LesVandales汪达尔人<br>Les Wisigoths 西哥特人 Les Saxons 撒克避人</li><li>希腊语对古法语的影响也是非常大的。其实，古希腊文化高潮时期，古罗马帝国还未成气候。当时，由于希腊人只是在地中海沿岸地区同高卢人有接触。罗马帝国强盛之后并吞高卢之后，南部地区使用希腊语的情况就不复存在了。但是，原来拉丁语并没有冠词。这是效仿古希腊语的结果。</li></ul></li><li>法兰克语，也在古法语的形成当中起着一定的作用。由于法兰克人使用字母h,所以现在的法语单词中有h。还有那个w,也是法兰克语的杰作。</li></ul><h3 id="法国国家象征"><a href="#法国国家象征" class="headerlink" title="法国国家象征"></a>法国国家象征</h3><h4 id="国花"><a href="#国花" class="headerlink" title="国花"></a>国花</h4><p>法国人把驾尾作为国花，其意有三种说法：</p><ol><li>象征古代法国王室的权力。相传，在法兰克王国的第一任国王克洛维（481-511年）洗礼的时候，上帝赐给了他一件礼物一一莺尾花。此后法国人纪念自己的始祖，便把莺尾花作为标志。从公元12世纪起，法国的国徽上便出现了莺尾花的图案。</li><li>宗教上的象征。公元1376年，法国国王查理五世（1364-1380年）把原有国徽图案上的驾尾花改为三枚花瓣，代表着圣父、圣子、圣灵三位一体。</li><li>法国人民用莺尾花表示光明和自由，象征民族纯洁、庄严和光明磊落。</li></ol><h4 id="玛利亚娜"><a href="#玛利亚娜" class="headerlink" title="玛利亚娜"></a>玛利亚娜</h4><p>玛利亚娜是法国的绰号，也是法国的象征。在法语中，贵族阶层不喜欢玛利亚娜，因为她代表着人民。革命者选中玛利亚娜，因为玛利亚娜象征着祖国母亲，母亲的乳汁保护着共和国的孩子。</p><ul><li>Marianne并不是真实存在的人物，是想像中的形象，还有人认为她来源于古希腊神话，她通常是一位带着帽子——<code>弗里吉亚帽（bonnet phrygien）</code>——的女性，说到这里,我想先讲一下弗里吉亚帽的来历，以便我们更快地解开Marianne的身世之谜。</li><li>弗里吉亚帽源于一种叫做pilleus(拉丁语）的毡帽，这两种帽子在外形上很相像。罗马帝国时期，被主人释放的奴隶在获得自由后会带着这种帽子，他们的后代成为城邦居民后也会戴这种帽子，渐渐地，两种帽子混同了,成为了自由的标志物。</li><li>文艺复兴时期，艺术家与雕刻家就习惯用帽子传递崇尚自由的思想，通常在长枪的末端放一顶弗里吉亚帽，就像刺杀凯撒的刺客一样。</li><li>18世纪，美国独立战争时期的起义军用弗里吉亚帽坚定人民追求自由的信念。</li><li>在法国，弗里吉亚帽从1790年成为了自由与公民责任感的标志，也成为了法国大革命的标志。从法国大革命开始，带着弗里吉亚帽的Marianne逐渐成了法国大革命的标志。</li><li>比利时动画片蓝精灵</li><li>Marianne这个词本身由Marie和Anne缩合而成，18世纪法兰西王国很多女性天主教徒都叫做Marie或者Anne,历史上一些知名女性的名字都有这个特点, 例如路易十四的母亲Anne d’Autriche以及路易十六的王后Marie-Antoinette。</li><li>玛利亚娜（1536-1624)一位西班牙作家。</li></ul><p>十七世纪初，(拉伐雅克）弗朗索瓦·拉瓦亚克的天主教徒于1610年刺死了法王亨利四世。</p><p>十九世纪中叶，法国共和党人为纪念（拉伐雅克）拉瓦亚克，用“玛利亚娜”来为自己的秘密团体命名。此后  ,玛利亚娜便成为法国的代名词。</p><ul><li>法国大革命爆发以后，戴着弗里吉亚帽的Marianne所承载的自由涵义使她被写入了革命歌曲的歌词中，例如《Marianne的拯救》，它写于1792年10月，描绘了向新制度——共和制度转型的美好景象，当时正值法兰西第一共和国建立的第十二天。当时，法国南部的共和党人致力于将这个名字和他们的政治理想联系起来。具有象征意义的Marianne在共和国的拥护者和反对者之间迅速达成了共识，而后很快被法国人民所接受。Marianne最终成为了法兰西共和国以及共和国价值的标志——“自由、平等、博爱”，这六字口号是法兰西共和国的一项宪法原则，于1848年载入宪法文本。</li><li>关于Marianne,还有几个有意思的事情：<br>首先是美国的自由女像，有“自由照亮世界”的意思，其实它恰好是法国赠送给美国祝贺其置布独立100周年的礼物，法国雕塑家Frederic-AugusteBartholdi对自由女神像的灵感或多或少地受到了Marianne的影响，所以从外形上也和Marianne有相似的地方。</li><li>Marianne是法兰西共和国的自由女神，在欧洲的历史上，对于一种精神或者主张的宣传通常不是对人民直接的灌输，而是通过类似于Marianne这样的拟人手法，这是他们宣传政治理想或者凝聚社会力量的特殊方式。</li><li>对于普通的人群，则要借助艺术之手传授教义，这成为欧洲很有代表性的传统与特色。Marianne法兰西共和国“自由\平等\博爱”价值的肉身，是人民心中的精神领袖。</li></ul><h4 id="国旗"><a href="#国旗" class="headerlink" title="国旗"></a>国旗</h4><p>法国三色旗分别代表着自由、平等、博爱。如今，三色旗中间加上玛利亚娜的头像，便构成了法国最直观的识别国家公共职能的标记。从1999年起，只要是省、部级或使馆发出的带台头信件，小册子、表格、广告和信息载体，都必须具备此标记。图标右边上行写有一行小字：自由；平等；博爱。下行写有一排大写字：法兰西共和国。</p><h4 id="国歌"><a href="#国歌" class="headerlink" title="国歌"></a>国歌</h4><ul><li>《马赛曲》</li><li>原名莱茵军团战歌（Chant de guerre de l’Armeedu Rhin)</li><li>La Marseillaise</li><li><p>词曲作者：克洛德·约瑟夫·鲁日·德·李尔</p></li><li><p><a href="https://www.bilibili.com/video/av71080046/?redirectFrom=h5" target="_blank" rel="noopener">https://www.bilibili.com/video/av71080046/?redirectFrom=h5</a></p></li></ul><h2 id="第二周-法国地理、人口、资源"><a href="#第二周-法国地理、人口、资源" class="headerlink" title="第二周 法国地理、人口、资源"></a>第二周 法国地理、人口、资源</h2><h3 id="地理"><a href="#地理" class="headerlink" title="地理"></a>地理</h3><ul><li><p><strong>法国是六边形（L‘hexagone）国家</strong></p></li><li><p>欧洲的十字路口（Carrefour del’ Europe）</p></li><li><p>三面临海，三面邻国；西欧最大，欧洲第三</p></li><li><p>海岸线2700km，陆地边界线2800km，国土67万<script type="math/tex">km^2</script>，本土55万<script type="math/tex">km^2</script>，22个大区，96省。</p></li><li><p>芒什海峡 La Manche | 大西洋：Ocean Atlantique | 地中海：La Mer Mediternanee</p></li><li><p>法国邻国：比利时，卢森堡，德国，瑞士，意大利，摩纳哥，安道尔，西班牙</p><p><img src="https://i.loli.net/2020/06/10/EHCMNRAeT5cyJom.png" alt="image-20200609195612594" style="zoom:50%;" /></p></li><li><p>河流</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">河流</th><th style="text-align:center">长度（KM）</th></tr></thead><tbody><tr><td style="text-align:center">卢瓦尔河</td><td style="text-align:center">1010</td></tr><tr><td style="text-align:center">罗纳河</td><td style="text-align:center">812</td></tr><tr><td style="text-align:center">塞纳河</td><td style="text-align:center">776</td></tr><tr><td style="text-align:center">加龙河</td><td style="text-align:center">575</td></tr></tbody></table></div><ul><li>主要城市：巴黎、里尔、勒阿弗尔、斯特拉斯堡、奥尔良、里昂、格勒诺布尔、波尔多、南特、图卢兹、尼斯、马赛</li></ul><h3 id="人口：6620万（2014年）"><a href="#人口：6620万（2014年）" class="headerlink" title="人口：6620万（2014年）"></a>人口：6620万（2014年）</h3><ul><li>主要宗教：天主教（64%）；伊斯兰教（3%）；新教（3%）；犹太教（1%）；无宗教信仰（28%）；2009年《十字报》调查数据）</li><li>民族：法兰西人/阿尔萨斯人/布列塔尼人/科西嘉人/弗拉芒人/巴斯克人，后部分为<strong>多民族混合体</strong></li></ul><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><ul><li>森林面积约1556.5万公顷，覆盖率28.6%</li><li>可耕地面积4/5</li><li>农业产值占欧盟的27%(“欧洲的粮仓”）</li><li>物产丰富（20公里）</li><li>主要矿藏：铁矿，其次铝土矿和钾盐矿。煤炭储量几近枯竭，所有矿石依赖进口。</li><li>主要依靠能源：核能约78%电力靠核能供应。</li></ul><h2 id="第三周-法语与节日"><a href="#第三周-法语与节日" class="headerlink" title="第三周 法语与节日"></a>第三周 法语与节日</h2><h3 id="法语"><a href="#法语" class="headerlink" title="法语"></a>法语</h3><div class="table-container"><table><thead><tr><th style="text-align:center">Expressions utiles</th><th style="text-align:center">中文释义</th></tr></thead><tbody><tr><td style="text-align:center">Je m’appelle Isabella</td><td style="text-align:center">我的名字是Isabella</td></tr><tr><td style="text-align:center">Tu t’appelle<strong>s</strong> comment?</td><td style="text-align:center">你叫什么？</td></tr><tr><td style="text-align:center">Il/Elle s’appelle comment?</td><td style="text-align:center">他/她叫什么？</td></tr><tr><td style="text-align:center">Vous vows appelle comment?</td><td style="text-align:center">您叫什么？</td></tr><tr><td style="text-align:center">Mon nom est…</td><td style="text-align:center">我姓什么</td></tr><tr><td style="text-align:center">Mon prenom est..</td><td style="text-align:center">我名什么</td></tr><tr><td style="text-align:center">Je suis Isabelle/chinois(e)/etudiant(e)/a Beijing</td><td style="text-align:center">我是伊丽莎白/中国人/大学生/在北京</td></tr></tbody></table></div><ul><li><font color='red'>Nom, Nationalite, prefension, lieu</font></li><li>这是什么？这是一辆自行车。Qu’est - ce que c’est?C ‘est un vélo.</li><li>她是法国人吗？不，她是意大利人。Elle est française?Non, elle est italienne.</li><li>你的电话号码是多少？我的电话号码是01 23 45 33 16。Quel est votre numéro de téléphone?Mon numéro de téléphone est 01 23 45 33 16.</li><li>这是谁？这是朱莉（Julie), 弗朗索瓦（François）的妻子。Qui est - ce?Julie, la femme de François.</li></ul><h3 id="法国节日"><a href="#法国节日" class="headerlink" title="法国节日"></a>法国节日</h3><ul><li>11个法定假日，30天带薪假期，周六周日双休</li></ul><p><img src="https://i.loli.net/2020/06/10/EsemSyw48opIMnv.png" alt="image-20200312151559975"></p><p>1c 2a 3g 4f 5c 6b 7h 8e</p><h4 id="1-元旦-公历1月1日"><a href="#1-元旦-公历1月1日" class="headerlink" title="1.元旦(公历1月1日)"></a>1.元旦(公历1月1日)</h4><p>&emsp;&emsp;法国的元旦本来是每年4月1日，直到1564年，国王查理九世才把它改作1月1日。新年期间，亲朋会聚会，馈赠礼品或钱。有趣的是，法国人在新年到来之前，各家一定要把家中的余酒全部喝光，以致许多人喝得酩酊大醉。他们认为，新年时如果家中还有剩余的酒，新的一年定交厄运。</p><p>&emsp;&emsp;也有种说法是，在查理九世做出改动之前，法国的元旦日期并不固定，根据地区、时代的不同，新年的日期也不同。例如改动之前里昂地区的元旦，是从圣诞节开始的，还有些地方的元旦，在3月1日、3月25日或者复活节等等，相当混乱，这也是查理九世之所以要在1564年颁布敕令，统一全法国元旦日期的原因。</p><p>&emsp;&emsp;在1月1日一大早，法国的父母会给孩子发“压岁钱”，以表示对子女的关爱。另外，法国人对于元旦这一天的天气相当重视，因为他们把元旦这一天的天气看作是新一年的年景，所以元旦大清早上街看风向来占卜，也是不可缺少的一个传统。</p><p>&emsp;&emsp;如果这一天刮南风。预示新的一年风调雨顺，一切顺利；如果刮西风，则将有一个捕鱼和挤奶的丰收年；若是刮东风，这一年水果将高产；而如果刮北风，那么这一年就要歉收了。因此，元旦这一天的天气预报，是人们最为关心的。</p><p>&emsp;&emsp;如果说圣诞节是法国人与家人相聚的时候，那么到了元旦的夜晚，就是法国人跟朋友共度的时候了，友人们聚在一起，饮酒作乐，而因为法国民间有一种迷信说法：除夕时家中的酒瓶里如果还有剩余的酒，来年就要交厄运，因此，人们在这天晚上一定要将家中的酒喝得一滴不剩，所有的人都应该喝得酩酊大醉，这样新一年才会有新开始。</p><h4 id="2-主显节-公历1月6日"><a href="#2-主显节-公历1月6日" class="headerlink" title="2.主显节(公历1月6日)"></a>2.主显节(公历1月6日)</h4><p>&emsp;&emsp;主显节是在1月6日，意思是显示上帝的意图，让人间知道一个不寻常的孩子耶稣基督诞生了。主显节是基督教最古老的三个节日之一（其他两个是复活节和圣诞节），因此对美国和其他国家的基督徒来说，1月6日是一个重要的节日。因为主显节是在12月25日圣诞节后的第十二天，主显节又叫“第十二日节”。主显节也叫“小圣诞节”，因为它标志着圣诞节的结束。</p><p>&emsp;&emsp;传统上把东方三贤人到达耶稣出生地的时间作为主显节的标记。据圣经记载，当耶稣在伯力恒（中东以色列的一个城镇）降生时，上帝在东方的天空中放置了一颗特别明亮的星星。东方三贤人在巴勒斯坦东部很远的地方就看见了这颗星星。对于他们来说，它意味着一个婴儿的诞生，这个婴儿会成为犹太人之王。他们跟着这颗星不远万里来到耶路撒冷，告诉希律王他们想朝拜这个新生的婴儿。当他们离开耶路撒冷时，又一次看到这颗星星。他们高兴极了。星星在他们前面引路，最后在婴儿降生的地方停下。他们跟着这颗星星来到房前，走进房间，看到了基督和他的母亲。他们弯腰施躬向那孩子朝拜，并献上金子、乳香和没药作为礼物。</p><p>&emsp;&emsp;三贤人走后，上帝派来的天使告诉耶稣的父亲约瑟夫赶紧带耶稣和他的母亲逃到埃及，因为希律王想要搜寻那个孩子，然后把他杀掉。他们一家呆在埃及，直到希律王死后才回来。</p><p>&emsp;&emsp;对于三贤人是何时到达伯力恒的，基督徒有不同的说法。一些人认为是在耶稣降生的当晚到达的，有的认为是在12天之后。甚至有的认为，东方三贤人是在耶稣降生两年后才到达伯利恒的。</p><p>&emsp;&emsp;1月6日过主显节，并非因为众所周知这一天是东方三贤人到达耶稣降生地的确切日期，而是因为世上有学问的人和统治者了解了上帝让耶稣降生的意图。</p><h4 id="3-复活节-春分月圆之后的第一个星期天"><a href="#3-复活节-春分月圆之后的第一个星期天" class="headerlink" title="3.复活节(春分月圆之后的第一个星期天)"></a>3.复活节(春分月圆之后的第一个星期天)</h4><p>&emsp;&emsp;复活节是法国民间传统的宗教节日，在每年春分(三月二十日或二十一日)月圆之后的第一个星期日。届时，全国放假。复活节也称“主复活节”或“耶稣复活节瞻礼”，为纪念耶稣复活所设。</p><p>&emsp;&emsp;节日前夕，糖果商店的橱窗里摆满了各式用巧克力制作的糖蛋、糖鱼和系着丝带的五颜六色的彩钟，应有尽有。相传，在复活节前的圣日(即星期四至星期六)，所有教堂里的钟都将飞往罗马接受祝福。当它们返回时便把带回来的各种礼物撒向人间，孩子们吃的糖果便是由它们带回来的。节日里，人们以彩蛋作为礼物互相赠送，无论大人还是孩子都以能够得到一枚精美的彩蛋而感到幸运、欢喜。因为彩蛋不仅是耶稣复活的象征，也是“开化”、“诞生”、“春天”等众多美好事物的象征。在法国，彩蛋制作已成为一种艺术。人们有的是在真蛋壳上涂色作画，有的是在用金属、陶瓷、塑料、玻璃、木头等为原料的蛋坯上绘色饰彩、精雕细刻，甚至还要嵌金饰玉。在农村，复活节前神甫的侍童会挨家挨户地吟唱耶稣受难曲，募集鸡蛋，用以制作复活节彩蛋。</p><h4 id="4-耶稣升天节-复活节后四十天"><a href="#4-耶稣升天节-复活节后四十天" class="headerlink" title="4.耶稣升天节(复活节后四十天)"></a>4.耶稣升天节(复活节后四十天)</h4><p>&emsp;&emsp;耶稣升天节亦称“基督升天节”、“耶稣升天瞻礼”或“主升天节”，是基督教纪念耶稣“升天”的节日。据《新约圣经》载，耶稣于“复活”后第40日“升天”。后来教会规定复活节后第40日（5月1日和6月4日之间）为此节。</p><p>&emsp;&emsp;耶稣升天节传说起源于耶路撒冷教会，约4世纪时始举行。由于历法不同，在具体日期上，西部教会使用格列历后，节期与现在公历相同；东正教及其他东方教会仍沿用旧历，节期常迟于公历13、14天。</p><p>&emsp;&emsp;升天节永远定于复活节40天后的星期四，它可以被看作是对复活节所庆祝之事件的继续。这个节日是为了纪念基督——在复活并对于门徒有所嘱托之后——最终的升天。从神学上讲，升天意味着复活的基督对其门徒之显现期的结束。升天表明了“升高”之主题的重要性，耶稣被看作是已升高到上帝的右边。</p><p>&emsp;&emsp;耶稣升天被看作是耶稣基督救世工程的完成，古代基督教会在这天举行游行庆祝活动。游行起源于耶路撒冷，寓意着耶稣领导门徒出城到了橄榄山。中世纪的法国、德国，常以游行来进行纪念活动。</p><h4 id="5-圣灵降临节-五旬节-复活节后第50天"><a href="#5-圣灵降临节-五旬节-复活节后第50天" class="headerlink" title="5.圣灵降临节/五旬节(复活节后第50天)"></a>5.圣灵降临节/五旬节(复活节后第50天)</h4><p>&emsp;&emsp;五旬节，亦称圣灵降临节，被定于复活节后的第五十天，是教会用来庆祝圣灵被赐给使徒们，使得教会在早期迅速成长的一个节日。</p><p>&emsp;&emsp;圣灵降临节（英文名：Pentecost（weeks））。复活节后第五十天，耶稣升天后第十天的主日，使徒们正聚集于耶路撒冷，圣灵突然从天而降，落在各人身上。于是众使徒大得力量，同别人广传福音，那天，约有三千人信了耶稣。之后又有五千人信仰基督，每天人数加增。因此，圣灵降临节就是初期基督教会诞生之日，十分重要。使徒们以后遂勇赴各地宣扬耶稣救人福音，而教会最后遂得以扩展至全世界。根据第四世纪末，西班牙修道女以塞利亚所写的“朝圣记”，当时在耶路撒冷的教会已经庆祝圣灵降临节了（PilgrimageofEthria.pp.150）。圣灵降临节后的第一主日，叫做“三位一体日”（TrinitySunday），纪念耶稣在世一生事迹，圣灵降临，以及三位一体的真神。从三位一体主日开始，直至降临期这段时期，称为“三位一体期”（TrinitySeason），一共包括有二十几个主日，教会历中称为三位一体后第一主日、第二主日……。</p><p>&emsp;&emsp;据《新约圣经》载，耶稣“复活”后第40日“升天”，第50日差遣“圣灵”降临；门徒领受圣灵后开始传教。由于历法的不同，东正教和其他东方教会在具体日期上常比天主教、新教迟13、14天。</p><p>&emsp;&emsp;圣灵降临节的庆典中，天主教弥撒祭服为红色，依照教宗依诺森的解释，红色令人想起圣神降临时地充满神奇力量的火舌形象。</p><p>&emsp;&emsp;圣灵对于基督徒的思想和生活具有十分重要的意义，现代灵恩运动在世界各地教会中的兴起已经使得人们越来越意识到圣灵所具有的特别地位。五旬节也是基督教年历中十分重要的节日，在许多基督教传统中，它被看作是仅次于复活节的节日。五旬节在古英语作品中也被称为“Whitsun”（字面意思即“白色周日”），这是由于在这个节日，教职人员都身穿白色服装。</p><h4 id="6-五一国际劳动节-铃兰节-公历5月1日"><a href="#6-五一国际劳动节-铃兰节-公历5月1日" class="headerlink" title="6.五一国际劳动节/铃兰节(公历5月1日)"></a>6.五一国际劳动节/铃兰节(公历5月1日)</h4><p>&emsp;&emsp;五月一日，是法国的法定假日，也是国际劳动节，其实从法国的传统习俗来看，五月一日和铃兰花（lemuguet）联系一直很紧密，法国人也一直有互赠铃兰、互相祝愿一年幸福的传统。让我们一起来看看法国历史上和五月一日有关的动人故事和传说吧。</p><p>&emsp;&emsp;现代社会每年的五月一日，法国人有互赠铃兰、互相祝愿一年幸福的传统。获赠人通常将花挂在房间里保存全年，象征幸福永驻。这种有香味的小花，在法国的婚礼上通常也可以看到。送铃兰给新娘，祝福新人“幸福的到来”。在法国赠送铃兰花的传统最早其实可以追溯到16世纪的文艺复兴时期，当时法国的国王是查理九世，据说他在某年的五月一日收到了一束铃兰花，从此五月一日赠送铃兰便成为惯例和传统，这里我们暂且不用考证这种说法的真伪，但是可以确定的是，十五世纪的法国，五月一日已经是一个和爱情有关的节日，当时的王公贵族们会去森林里砍伐一些小树枝用来作为居家装饰的摆设，同时他们还会用树叶和花朵编织成戴在头上的花圈，自己佩戴并送给心爱的人。直到目前，这些几乎被遗忘的习俗仍然在法国的某些地区存在，比如很多地区还保留了五月树的节目，在法国东部，有时树代表尊重，从四月三十日夜间至五月一日之间，为了表达对当地政府官员的尊敬，人们会把树砍倒后送到他的家门口；有时树则象征爱情，五月一日的这一天，年轻男子会把一段树放在未出嫁的年轻女子的家门口，用以表达对她的爱慕之心。</p><p>&emsp;&emsp;铃兰花，因花季在五月，所以传统上一直被看作吉祥、幸福的象征，此外拉丁语中铃兰也有“回归幸福”的意思，在法国民间还有一种说法，如果谁找到了一束有13朵花骨朵的铃兰花，那此人将会受到命运的特别垂青，也就是好运连连、命运好。历史从古走到今天，在法国铃兰花一直和美好、美丽联系在一起，比如法国已故著名服装设计师克里斯汀．迪奥（ChristianDior）最喜欢的花就是铃兰花，而法国的很多香水都含有铃兰的味道。</p><h4 id="7-国庆日-公历7月14日"><a href="#7-国庆日-公历7月14日" class="headerlink" title="7.国庆日(公历7月14日)"></a>7.国庆日(公历7月14日)</h4><p>&emsp;&emsp;法国国庆日是每年的7月14日。以纪念在1789年7月14日，巴黎群众攻克了象征封建统治的巴士底狱，从而揭开法国大革命序幕。在法国，每年国庆节的阅兵式是庆典活动的重头戏。</p><p>&emsp;&emsp;1789年的这一天，巴黎人民攻占了象征封建统治的巴士底狱，推翻了君主政权。1880年，7月14日被正式确立为法国的国庆日，法国人每年都要隆重纪念这个象征自由和革命的日子。这一天的夜晚成为欢乐的海洋，法国的标志埃菲尔铁塔为火树银花所映衬。</p><p>&emsp;&emsp;人们通常认为，法国国庆日的正式确定是1789年，其实不然。虽然为纪念巴黎人民攻克巴士底狱这一光辉的日子，曾一度将1789年的7月14日作为国庆日。但1814年封建王朝复辟后，宣布7月14日为“国耻日”和“杀人犯的节日”。1870年，共和国恢复，1879年，共和党人成立了政府，议会由凡尔赛迁到了巴黎。翌年6月，法国议会正式通过法令，将1880年7月14日定为法国的国庆节。</p><h4 id="8-圣母升天节-公历8月15日-天主教-、8月27日-东正教"><a href="#8-圣母升天节-公历8月15日-天主教-、8月27日-东正教" class="headerlink" title="8.圣母升天节(公历8月15日(天主教)、8月27日(东正教))"></a>8.圣母升天节(公历8月15日(天主教)、8月27日(东正教))</h4><p>&emsp;&emsp;圣母升天节是天主教、东正教的宗教节日。又称圣母升天瞻礼、圣母安息节。在天主教、东正教的教义中，谓耶稣的母亲玛丽亚在结束在世的生命之后，灵体一齐被接进天堂。</p><p>&emsp;&emsp;天主教于公历8月15日举行，东正教于公历8月27日或28日举行。这是关于圣母玛利亚最古老、神圣的节日。圣母灵魂与肉身一同升天被教宗碧岳十二世声明为当信的教义，是天主启示的真理。此节日是圣母众多庆节中最大者。</p><p>&emsp;&emsp;圣母升天节纪念于每年的8月15日，在厄弗所大公会议基于肯定耶稣是真天主又是真人，宣认玛利亚为天主之母的信理。此后圣母敬礼便在各地蓬勃发展起来。至教宗本笃十四世，宣布玛利亚升天为可靠意见，1950年颁定：“童贞玛利亚灵魂肉身蒙召升到天国的荣耀”为信理。</p><p>&emsp;&emsp;罗马天主教、东正教及圣公会亦同时相信这条信条。在很多天主教传统的国家，圣母升天节是国家公共假日。这些国家包括比利时，喀麦隆，法国，意大利，波兰和西班牙等。</p><h4 id="9-诸圣瞻礼节-公历11月1日"><a href="#9-诸圣瞻礼节-公历11月1日" class="headerlink" title="9.诸圣瞻礼节(公历11月1日)"></a>9.诸圣瞻礼节(公历11月1日)</h4><p>&emsp;&emsp;诸圣瞻礼节，每年11月1日是“所有圣徒”的节日。这天并不像11月2日，是为纪念死者而设。然而，因为作为法定节假日，这天人们会携一束菊花，祭奠已故亲人。每年11月1日，天主教堂会纪念所有的圣徒，无论他们是否为人熟知。这是为了让人们知道，神圣不仅仅属于精英，每个人都能成为圣贤。从中世纪开始，人们就有每年纪念逝者的习俗。因此，在11月1日纪念完圣徒后，人们在第二天会为逝者祈祷。在天主教建筑中，这两个节日被不同的装饰颜色区分开。11月1日是白色，而11月2日是紫色。</p><h4 id="10-停战节-公历11月11日"><a href="#10-停战节-公历11月11日" class="headerlink" title="10.停战节(公历11月11日)"></a>10.停战节(公历11月11日)</h4><p>&emsp;&emsp;11月11日的停战节，本来是为纪念第一次世界大战停战的节日，后人在庆祝第一次世界大战胜利的同时，也深深地怀念在第二次世界大战中牺牲的烈士和死难的亲人。</p><p>&emsp;&emsp;依照惯例，这一天如同国庆节一样，由总统或总理亲自向军中有功官兵以及在两次世界大战中幸存的英雄们颁发奖章，以表彰他们的功勋。授勋仪式结束以后，还有一项固定的节日内容：由总统或总理设宴举行各种招待会。</p><p>&emsp;&emsp;停战节这天原来也属于全国性假日，吉斯卡尔·德斯坦任总统时决定取消这一假日，但有不少单位，尤其是大、中、小学校，至今仍坚持在这一天放假。</p><h4 id="11-圣诞节-公历12月25日"><a href="#11-圣诞节-公历12月25日" class="headerlink" title="11.圣诞节(公历12月25日)"></a>11.圣诞节(公历12月25日)</h4><p>&emsp;&emsp;圣诞节（Christmas）又称耶诞节，耶稣诞辰，译名为“基督弥撒”，西方传统节日，起源于基督教，在每年12月25日。弥撒是教会的一种礼拜仪式。圣诞节是一个宗教节，因为把它当作耶稣的诞辰来庆祝，故名“耶诞节”。</p><p>&emsp;&emsp;大部分的天主教教堂都会先在24日的平安夜，亦即12月25日凌晨举行子夜弥撒，而一些基督教会则会举行报佳音，然后在12月25日庆祝圣诞节；基督教的另一大分支——东正教的圣诞节庆则在每年的1月7日。</p><p>&emsp;&emsp;法国的一般成年人，在圣诞前夕差不多都要到教会参加子夜弥撒。在完毕后，家人同去最年老的已婚的哥哥或姊姊的家里，团聚吃饭。这个集会，讨论家中要事，但遇有家人不和睦的，在此后也前嫌冰释，大家要和好如初了，所以圣诞在法国是一个仁慈的日子。</p><h2 id="第四周：吃"><a href="#第四周：吃" class="headerlink" title="第四周：吃"></a>第四周：吃</h2><h2 id="第五周：法国教育"><a href="#第五周：法国教育" class="headerlink" title="第五周：法国教育"></a>第五周：法国教育</h2><h3 id="词汇"><a href="#词汇" class="headerlink" title="词汇"></a>词汇</h3><p>法语词汇：</p><ul><li>托儿所：creche(municipale/parentale)</li><li>幼儿园：ecole maternelle</li><li>小学：ecole primaire-ecolier,ere</li><li>中学：college-collegien,ne</li><li>高中：lycee-lyceen,ne</li><li>普通大学：Universite-etudiant,e</li><li>大大学/大学校：Grande ecole</li></ul><h3 id="教育（全免费）"><a href="#教育（全免费）" class="headerlink" title="教育（全免费）"></a>教育（全免费）</h3><ul><li>小学5年、中学4年</li><li>大大学、大学校：Grande ecole</li></ul><h3 id="托儿所"><a href="#托儿所" class="headerlink" title="托儿所"></a>托儿所</h3><ul><li>3个月大就可送。去托儿所托儿所由国家负责运营，收很少的钱帮忙照看双职工家庭的小孩。</li></ul><h3 id="学前教育"><a href="#学前教育" class="headerlink" title="学前教育"></a>学前教育</h3><p>——<strong>非义务，免费，就近原则</strong></p><ul><li>学前教育为非强制性的免费教育，根据家长的要求，2-6岁的儿童，都可送入家庭居住地附近的幼儿园或附设在小学的幼儿班。</li><li>法语称作：Ecole maternelle(母育学校）</li><li>在法国，超过99%的法国小孩上幼儿园。法国人的邻居，德国人就没那么好命了！</li><li>法国早在120年前即1889年就通过立法确定小学教师为国家公务员，其工资由国家财政负担。</li><li>在日本：日本的教师待遇在全国任何学校都是一样的。城市与农村，最南与最北都没有差别。而且所有的教师都是政府公务员待遇。中小学教师不评职称。一经当上教师，就是终身制。享受公务员待遇，而且是公务员身份。</li></ul><h3 id="小学"><a href="#小学" class="headerlink" title="小学"></a>小学</h3><div class="table-container"><table><thead><tr><th style="text-align:center">学年</th><th style="text-align:center">学期</th></tr></thead><tbody><tr><td style="text-align:center"><img src="https://i.loli.net/2020/06/10/iPYKvlSM1tb89xr.png" alt="image-20200609200631387"></td><td style="text-align:center"><img src="https://i.loli.net/2020/06/10/Y1gZ4saJGwBFAml.png" alt="image-20200609200655741"></td></tr></tbody></table></div><h3 id="初中（College）4年"><a href="#初中（College）4年" class="headerlink" title="初中（College）4年"></a>初中（College）4年</h3><p>—-学年10月中旬开始到第二年的7月中旬结序</p><ol><li>10月中旬-12月的圣诞节，放假两周</li><li>1月初到3月末，复活节放假两周</li><li>4月中旬到7月中旬</li><li>三个月悠长的暑假</li></ol><p>每个小学期结束，发成绩单，父母签字。每三个月一次家长会。7月，学年结束时，学校综合测评，确定升级或降级。</p><h4 id="初三选择"><a href="#初三选择" class="headerlink" title="初三选择"></a>初三选择</h4><div class="table-container"><table><thead><tr><th style="text-align:center">选择</th><th style="text-align:center">上班</th></tr></thead><tbody><tr><td style="text-align:center"><img src="https://i.loli.net/2020/06/10/1bLwMhN3TCixgDE.png" alt="image-20200609201049669"></td><td style="text-align:center">初中毕业的人在16岁前要学习1-2年的职业技能，颁发CAP或者是BEP文凭。<br /><img src="https://i.loli.net/2020/06/10/QG97ZYoNCzdPcRl.png" alt="image-20200609201137431"></td></tr><tr><td style="text-align:center">读高中</td><td style="text-align:center">毕业会考</td></tr><tr><td style="text-align:center"><img src="https://i.loli.net/2020/06/10/3mblCq91TAwWyLQ.png" style="zoom:50%;" /></td><td style="text-align:center"><img src="https://i.loli.net/2020/06/10/o3ngkisbQlu1jCR.png" alt=""></td></tr></tbody></table></div><ul><li><strong>BAC相关</strong>：法国统一中学毕业会考（BAC)制度，由拿破仑1808年立法确立。在法国，BAC成绩是申请大学的依据，算是法国版的“高考”。与其他国家不同，法国“高考”始终绕不开哲学这个科目；哲学也是法国高中第三年的必修科目。</li></ul><h3 id="高三必修课：哲学"><a href="#高三必修课：哲学" class="headerlink" title="高三必修课：哲学"></a>高三必修课：哲学</h3><h3 id="BAC改革新举措"><a href="#BAC改革新举措" class="headerlink" title="BAC改革新举措"></a>BAC改革新举措</h3><ul><li>法国教育部长布兰盖（Jean-Michel Blanquer)于2018年2月14日正式宣布未来高中毕业会考(baccalaureat)改革内容，将在2021年生效。会考总成绩将由四项笔试和一项口试（占60%)成绩及平时测验（占40%)成绩组成。此外，部长宣布还对高中科目和课时有重大改革：普通类高中生结束分科，改由选择专业课程代替。</li><li>目前高中毕业会考有十几项考试，从2021年开始只有四项笔试和一项大型口试（grand oral),占会考总成绩的60%。</li></ul><h3 id="高考时间"><a href="#高考时间" class="headerlink" title="高考时间"></a>高考时间</h3><div class="table-container"><table><thead><tr><th>时间</th><th>内容</th></tr></thead><tbody><tr><td>高二（premiere）期末</td><td>法语考试（笔试和口试）</td></tr><tr><td>高三（terminate）春假后</td><td>有两项考试，考试科目根据学生所选科目而定</td></tr><tr><td>高三毕业班的6月底</td><td>哲学考试，口试</td></tr></tbody></table></div><ul><li>口试也在高三毕业班的6月底进行，是针对一项从高二就开始进行的项目，涵盖一到两门所学科目口试由个人完成，时间是20分钟，其中有10分钟的项目介绍和10分钟的问答，由三位考官共同评分，评估学生对所学知识的分析能力。相关项目在高二时由小组团队完成，在毕业班时则由个人单独完成。</li><li>这项改革涉及普通类（general)和技术类(technologique)会考，包括70%的高中生。</li></ul><h3 id="普通类高中生结束分科以细分“专业”代替"><a href="#普通类高中生结束分科以细分“专业”代替" class="headerlink" title="普通类高中生结束分科以细分“专业”代替"></a>普通类高中生结束分科以细分“专业”代替</h3><ul><li>高中文（L)、商（ES)、理（S)的分科（系列）将不存在了。为了给学生“更多的选择机会”以及“避免过早分科”，2018新学年进入高一（seconde)的学生将不再选择分科，而是在高二选择专业学科。</li><li>高二所有普通类的学生都将学习法语、历史一地理、道德与公民教育、两种实用语言（LV1和LV2)、体育和一门名为“科学与数码人文科学”的新科目。</li><li>除了这些必修科目，每个学生还必须选择三门专业课程，共有11种可选课程，包括：艺术、生态学-农业-领土特征、历史-地理-地缘政治-政治学、人文-文学-哲学、外国语言和文学、数学、数码与计算机科学、生命学与地球科学、工程科学、经济与社会科学、物理-化学。</li></ul><h2 id="小王子音乐剧特点"><a href="#小王子音乐剧特点" class="headerlink" title="小王子音乐剧特点"></a>小王子音乐剧特点</h2><p><strong>内容提要</strong> 法国音乐舞台剧《小王子》改编自法国作家圣埃克苏佩里同名童话。贯穿于始终的诗意、忧伤和孤独让无数观众看后都烯嘘感动。《小王子》在凝练透彻的意象中洞察生命的本质，为人们提供了直面现实和反省自我精神世界的途径，同时揭示出人类生存困境的现代悲剧主题。</p><p>&emsp;&emsp;一个微小屏弱的童话形象小王子让人们永远记住了一个名字，至今，他的家乡法国里昂机场仍然以他的名字命名——他就是法国飞行员兼作家圣埃克苏佩里。自1943年《小王子》在纽约问世以来，达到五亿册的销量。它不但被誉为有史以来阅读率仅次于《圣经》的最佳书籍，而且还被翻译成102种文字。正因为原著如此受欢迎，西方各国改编的话剧、电影一直热演不衰其中法国版音乐剧《小王子》被公认为是最忠实于原著、制作最为精良和最成功的一个版本。2007年7月在上海东方艺术中心歌剧厅首次与中国观众见面就好评如潮。发人深省的童话故事加上优雅清新的法国音乐，美轮美免的舞台布景加上制作考究的演出服装，让所有观众沉醉于其中的同时也重新找回了心中那份遗失已久的纯真和美好。更为重要的是圣埃克苏佩里通过《小王子》透射出了20世纪人类生存错位和苍凉的现代主题。在他淡淡的忧伤和哀愁中，人们感受到了《小王子》意在传递给世人的一种精神道德力量。简单的故事情节却也包含了现代悲剧的基本特征。</p><h3 id="一、现代悲剧的审美价值"><a href="#一、现代悲剧的审美价值" class="headerlink" title="一、现代悲剧的审美价值"></a>一、现代悲剧的审美价值</h3><p>&emsp;&emsp;古希腊传统的悲剧主要是着力突出英雄人物形象；而现代悲剧则是更注重小人物的悲离合。剧本里不再有传统式的英雄人物，所有的人物都是最为司空见惯的平凡人，如那些渺小、软弱、可怜、想要挣脱命运咖锁，力图改变生存环境的在理想与现实中挫败的普通人。因此，他们的弱点是人类的共有弱点，而他们的悲剧就成为了整个人类的悲剧。现代悲剧的格调是深沉内在的。现代剧作家所着力挖掘的重心不再是现实的惨烈悲壮，而是通过它来警醒社会，力求从外在现象的描述开始，达到对社会内在本质的理解和把握。作为社会生活中悲剧现象的艺术反映，现代悲剧的基础是人与社会的异化与反异化之间的关系，这种关系的重心最终要落在社会人的身上，因而悲剧始终是人的悲剧而现代社会中人的危机和生存困境则是现代悲剧要处理的核心问题。<br>&emsp;&emsp;一直以来，审美就被理解为对美的事物的感受、感觉和体验，是一种感性地把握美的式。在马克思看来，艺术原本是人类掌握世界的一种方式，它不同于哲学、宗教、实践精神等其他的掌握方式。其特点就在于是以感性的、审美的方式把握对象世界，既能达到对对象世界的认知，同时也有利于保持人的审美情感体验，进而保持人们精神世界之感性的丰富性。那么，审美意义上的悲情应该是能让人“以悲为美”，从中获得审美愉快。这种悲情产生于人与一种无形的自然力量或自己认同的社会制度的矛盾冲突。悲剧之所以能够带来审美价值，是因为观众和读者自身的经历对审美程度起着非常重要的作用。生活中的悲剧是戏剧中悲剧的来源和基础，而戏剧悲剧则是生活悲剧在舞台上的再现。也许剧中人的生活经历就是我们自己的曾抑或是熟悉的身边人身边事。这样一来，在剧本和观众之间就会产生强烈的共鸣。但仅有共鸣是不够的，因为只有悲剧，没有崇高，就谈不上悲剧的审美价值。因此 悲剧欣赏心理效应总是具有两重性，它既有催人泪下的一面，又有促人奋进的一面，也就是亚里斯多德所说的，悲剧既能使人“引起怜悯和同情”，又能“使这种感情得到陶冶”。矛盾冲突的类型往往是人与人之间的外冲突和人与自身灵魂的内冲突的混合，而其中最能体现悲剧的价值同时也更能产生震撼人心的力量的往往是人自身的内在冲突。悲剧可以通过怜悯净化感情。这就是说，它使我们产生一种想象中的同情而忘掉单纯的个人打算。它超越在我们本身的利害之上，使我们对人性发生崇高的永恒的兴趣。它使我们看到伟大的、遥远的、可能的事物就像看到真实的、细小的、眼前的事物一样。它有如一面镜子给我们显示了人的生活、思想和行为，从而告诉我们在这个世上还有一些或有过一些别的人像我们自己一样。它揭开了人类心灵的内幕。它使我们对于切可以感染我们共同天性的东西不会无动于衷。正如刘再复所言：“心灵是文学的根低。伟大的文学仰仗着心灵的渗透力，把高洁的芬芳注入世界。”</p><h3 id="二、作者创作动因探析"><a href="#二、作者创作动因探析" class="headerlink" title="二、作者创作动因探析"></a>二、作者创作动因探析</h3><p>&emsp;&emsp;在法国文学史上，圣埃克苏佩里是一位殊的作家，他的人生与小王子一样，充满了传奇色彩。圣埃克苏佩里1900年6月29日出生于法国里昂的一个没落贵族家庭，圣埃克苏佩里家族在当地声名显赫，生活富有，拥有自己的城堡。他小时候深受家族影响，对人类美好理想的信仰极为忠诚。1921-1923年圣埃克苏佩里在法国空军服役，1927年春加入飞行员的行列，与著名飞行员梅尔莫兹、吉约梅、艾基安等人开辟了从法国南部的图卢兹到摩洛哥的卡萨布兰卡以及塞内加尔首府达喀尔的邮政航线。1939年德国法西斯入侵法国，他不顾自己曾多次负伤，毅然参加了抗德战争。1940年法国战败，他所在的部队损失惨重。他随后复员只身流亡美国。1943年，首版《小王子》在纽约出版之际，已经43岁的圣埃克苏佩里经强烈要求再次入伍，回到了法国在北非的抗战基地阿尔及尔。1944年7月31日上午，他出航执行官九次飞行任务，竟然神秘失踪，成为法国学史上的传奇。<br>&emsp;&emsp;在《小王子》中，圣埃克苏佩里将自己化身为孩童和形单影只的飞行员。事实上小王子与飞行员的对话正是圣埃克苏佩里的内心独白。飞行员就是现实世界中的圣埃克苏佩里，而小王子则是他向往回归童年的另一个自己。剧中导演也刻意让飞行员和小王子佩戴了同样一条橙色的围巾以示两人的同一性，而当小王子初次看到飞行员的飞机时也不禁感叹：“难道你也是从天上掉下来的吗？”小王子在地球上的孤单旅程其实正是圣埃克苏佩里在现实世界中的寂寞体验。六个星球上行事诡诵的人就是现实世界中的芸芸众生，他们善于伪装自己，他们喜欢带着符号般的假面具。而剧中的玫瑰则是圣埃克苏佩里妻子的象征，他当初就如小王子那样的爱上了玫瑰 移居美国后 与妻子发生了一场感情纠纷，虽然后来重归于好，但是这段纠纷在他的内心留下了不可磨灭的影响。他借小王子的口说出了内心的想法：“我那时什么也不懂！我应该根据她的行为，而不是根据她的话来判断她。她使我的生活芬芳多彩，我真不该离开她跑出来。我本应该猜出在她那令人爱怜的花招后面所隐藏的温情。花是多么自相矛盾！我当时太年轻，还不懂得爱她。”<br>&emsp;&emsp;《小王子》是圣埃克苏佩里心灵的自画像。他是一个有着成人的外壳但内心却拒绝长大的人。他感伤留恋美好童年的逝去，他厌倦成人世界的虚无盲目。成长对他而言是非常无可奈何的事。他在《小王子》中承认童年时代绝对真理观的崩溃造成了个人心理上的混乱与迷悯，而这正是进入成人世界所必须付出的代价。在成人世界中，“每件事的本身都是大谜团”。他很惊讶, 孩童时代无限的眼界已经变得狭溢。在成人眼光的局限下，他的游戏天堂早已荡然无存。更让人难受的是，他发现自己“永远找不回无限宽广的世界”。进入成人世界，代表着他被屏弃在了菩提树和冷杉木林立的美丽花园之外，从此无法尽情嬉游。他曾经在给母亲的信里说，“我不确定我童年以后是否真的活过。”[2]对圣埃克苏佩里来说，长大成人是无可救赎的原罪。他之所以选择童话体裁是因为童话世界里想像可以天马行空，这种特定模式不受时间限制，它可以说明现在、过去和未来，可谓“事近而喻远”。它是超现实的，但透过表象看本质，我们又会发现，在这些奇异的世界中又处处闪耀着现实社会的折光，渗透着现实生活的哲理和思想情感。圣埃克苏佩里的童话使我们轻易回到了最初的心灵轨道 获得了反思的角度。而他自己以回归童年之心看待曾经有过的烦恼，也获得了前所未有的平静和智慧。</p><h3 id="三、人类生存困境的悲剧主题"><a href="#三、人类生存困境的悲剧主题" class="headerlink" title="三、人类生存困境的悲剧主题"></a>三、人类生存困境的悲剧主题</h3><p>&emsp;&emsp;文学性就是诗性，那是人类原始生命的出发点，同时也是人类精神提升的制高点。法国音乐剧《小王子》没有火力四射的热舞，没有俏皮搞笑的台词，它展现在我们眼前的是一首诗一幅画一个哲理，需要我们静下心来，慢慢品读它会让那些带着“娱乐”心理前去欣赏的人大失所望；也会让那些善于思考和感悟的人们清然泪下。看似简单的言语中却充满了丰富的哲理，提醒盲目奔波的大人都曾经是孩子，虽然很多人早已经忘记，重拾那份渐行渐远的纯真美好<br>才能真正发现原来最珍贵的一直就在身边。<br>&emsp;&emsp;一名飞行员由于飞机故障，迫降到了撒哈拉大沙漠中碰巧遇到一名来自外星的小王子。通过与小王子共度8天的交流，飞行员了解到小王子所居住的星球的奇特情况以及他在太空中的奇遇：小王子分别拜访了权力幻想狂的国王、爱慕虚荣爱听谎言的人、深陷混渎迷惘中不能自拔的酒鬼、醉心于算计的商人、墨守成规的点灯人和自命不凡的教条地理学家。作者以来自异域的小王子为视角，放大了现实世界中可怜人的滑稽和荒唐。同时小王子对于怪人们的感受也渗透出圣埃克苏佩里对于成人世界洞察后的无奈与失望。来到地球后，无比寂寞的小王子想念他的玫瑰花 想念他的小星球。后来小王子又遇到了蛇、玫瑰花、狐狸、扳道工、商贩。由此他看透了人生的虚无和盲目，同时他也洞彻到了世界上最珍贵朴实的爱情和友情要用心去体会感受。《小王子》营造了诗画一般的意境，既针矿了时弊鞭达了世界上的丑恶现象，“又展示了一个延绵不断的经验流中的人生本质”，试图指出一条通向人类文明“理想境界”的道路。[3]成人世界通过小王子的视角被陌生化，作者以极其夸张的手法写出了成人们扭曲的生命形态。整部作品充满诗意与忧伤、孤独，以及在这种孤独中寻找某种人生经验的本质和意义，从而押击现实生活中的某种价值观 捍卫人类的精神家园。它的价值更多的是在浅显易懂的文字背后隐埋着对于人类生存体验和生存意义的深刻反思。<br>&emsp;&emsp;20世纪上半叶，西方文学的一个重要特征是反映人类生存的困境主题，是为陷入精神危机中的现代人类寻找出路。圣埃克苏佩里以自己的努力和亲身感受，回答了这一紧迫的时代课题。他向人的精神世界发问 揭示人的心灵在社会重压下的痛苦和扭曲，对人物心灵做了深层透视，以此去探索产生现代生活悲剧的内在根源。他用作品来体现现代人的困惑与迷茫，以及内心的痛苦。随着年龄的增长，束缚变的越来越多，在现代都市，在一个以效益为最高指标、竞争为基本手段、自利为追逐目的的环境中，人与人之间的联络似乎越来越容易，而心灵的沟通却越来越难；交往越来越频繁，但情义却越来越淡漠了。人人活在自己苦心经营的城堡里，人际的疏离、人心的冷漠却成了后现代肆意蔓延的流行趋势。后现代中人的生存和心灵空间受到消费主义的挤压，人们的思想越来越被商品的消费逻辑所操纵。人们贴近自然感悟自然的心灵也日渐枯竭。在“价值颠覆”和“价值崩溃”中人们拥有了实用主义、物质主义和急功近利的价值观。人们在渐渐屈从于金钱和权力的同时，内心最真诚的判断标准也随之迷封起来。富裕的物质生活不应该再是道德行为的切实保障，也不再是幸福欢悦的唯一来源。</p><h3 id="四、结语"><a href="#四、结语" class="headerlink" title="四、结语"></a>四、结语</h3><p>&emsp;&emsp;音乐剧《小王子》作为写给成年人看的童话，之所以能够感动无数人，是因为它唤起了人们对童年的美好回忆，以及对真、善、美的渴望，触动了心中最柔软最真实的角落。在剧尾小王子要离开地球时，戏剧冲突似乎达到了高潮，那种强大的震撼力让无数观众为之动容。霓虹灯的小王子画像打在舞台布景上，而后瞬间就消失了，留下飞行员孤零零地在沙漠上伤心感叹，“世间最美和最让人悲伤的景色，就是他消失的地方。倘若有天你来到这个沙漠，刚好在这颗星星下面，有个小孩向你走过来，如果他有金色的头发，你一定猜出他是谁，请好心肠的您不要让我如此悲伤，一定写信告诉我，他回来了……。”所有的孩子都会长大成人，所有的大人也都曾有过童年。人类一路跟随文明的进步至今，路边的风景丰富了我们的阅历却也有时让我们迷失。时光永远不会倒流，但永恒的纯真和美好却可以一直留存心间，激励我们前行。</p><h2 id="莫奈《日出·印象》"><a href="#莫奈《日出·印象》" class="headerlink" title="莫奈《日出·印象》"></a>莫奈《日出·印象》</h2><p>&emsp;&emsp;《日出·印象》，是法国印象派画家莫奈于1872年在勒阿弗尔港口画的一幅写生画。他在同一地点还画了一张《日落》， 在送往首届印象派画展时， 两幅画都没有标题。一名新闻记者讽刺莫奈的画是”对美与真实的否定， 只能给人一种印象”。莫奈于是就给这幅画起了个题目—《日出·印象》。它作为一幅海景写生画， 整个画面笼罩在稀薄的灰色调中， 笔触画得非常随意、零乱， 展示了一种雾气交融的景象。日出时， 海上雾气迷朦， 水中反射着天空和太阳的颜色.岸上景色隐隐约约， 模模糊糊看不清， 给人一种瞬间的感受。</p><h3 id="作品赏析"><a href="#作品赏析" class="headerlink" title="作品赏析"></a>作品赏析</h3><p>&emsp;&emsp;《日出·印象》[1] 描绘的是在晨雾笼罩中日出时港口景象。在由淡紫、微红、蓝灰和橙黄等色组成的色调中，一轮生机勃勃的红日拖着海水中一缕橙黄色的波光，冉冉升起。海水、天空、景物在轻松的笔调中，交错渗透，浑然一体。近海中的三只小船，在薄雾中渐渐变得模糊不清，远处的建筑、港口、吊车、船舶、桅杆等也都在晨曦中朦胧隐现。这一切，是画家从一个窗口看出去画成的。如此大胆地用”零乱”的笔触来展示雾气交融的景象。这对于一贯正统的沙龙学院派艺术家来说乃是艺术的叛逆。该画完全是一种瞬间的视觉感受和活泼生动的作画情绪使然，以往官方学院派艺术推崇的那种谨慎而明确的轮廓，呆板而僵化的色调荡然无存。这种具有叛逆性的绘画，引起了官方的反对。</p><p>&emsp;&emsp;这幅名画是莫奈于1872年在阿弗尔港口画的一幅写生画。他在同一地点还画了一张《日落》, 在送往首届印象派画展时, 两幅画都没有标题。一名新闻记者讽刺莫奈的画是”对美与真实的否定, 只能给人一种印象”。莫奈于是就给这幅画起了个题目—《日出·印象》。它作为一幅海景写生画, 整个画面笼罩在稀薄的灰色调中, 笔触画得非常随意、零乱, 展示了一种雾气交融的景象。日出时, 海上雾气迷朦, 水中反射着天空和太阳的颜色.岸上景色隐隐约约, 模模糊糊看不清, 给人一种瞬间的感受。</p><p>&emsp;&emsp;他对光色的专注远远超越物体本身的形象，使得物体在画布上的表现消失在光色之中。他让世人重新体悟到光与自然的结构。所以这一视野的嬗变，以往甚至难以想象，它所散发出的光线、色彩、运动和充沛的活力，取代了以往绘画中僵死的构图和不敢有丝毫创新的传统主义。</p><p>&emsp;&emsp;”如果你弄个《日出·印象》的黑白版本(如图)，会发现太阳基本消失了……没错，太阳本身没有光，只是凭色彩的映衬，才制造出这样的效果!”</p><p>&emsp;&emsp;当1874年莫奈和一群青年画家举办展览时，这幅《日出·印象》遭到了诽谤和奚落。有的评论家挖苦说:”毛坯的糊墙纸也比这海景完整!”更有人按这幅画的标题，讽喻以莫奈为首的青年艺术家们为”印象派”，于是”印象主义”也就成了这个画派的桂冠。</p><p>&emsp;&emsp;该画1985年被抢劫，据法国被盗艺术品侦缉处1990年12月6日，在科西嘉岛一座别墅中查获。</p><h2 id="马奈《吹笛少年》"><a href="#马奈《吹笛少年》" class="headerlink" title="马奈《吹笛少年》"></a>马奈《吹笛少年》</h2><p>&emsp;&emsp;画中描绘的是近卫军乐队里的一位少年吹笛手的肖像。画家在探索形与色的统一时，注意到人物个性特征的刻画。在色彩上追求一种稳定的、几乎没有变化的亮面，然后突然转入暗部，将人物置于浅灰色、近乎平涂的明亮背景中进行描绘，用比较概括的色块将形体显示出来。在这幅画中没有阴影，没有视平线，没有轮廓线，以最小限度的主体层次来作画，否定了三度空间的深远感。杜米埃说过马奈的画平得像扑克牌一样。</p><p>&emsp;&emsp;画中带有日本绘画风格的《吹笛少年》中，我们还可以看到委拉斯贵支以及戈雅不用任何背景和装饰的画风。画中的吹笛少年以右脚为重心站立，左腿向外伸展，上身自然向左倾斜，手指在乐器的孔洞上按压，悠扬的音符流泻而出，脸上神情专注，谨慎的演出。</p><p>&emsp;&emsp;运用三种基本色调—红色裤子、黑色上衣以及赭石色的背景。红色裤子两边的黑色边线，与黑色上衣连成一气，红、黑两色间的关系，被马奈以金黄色的衣扣和吹笛少年肩上的白色披带突显出来。赭石色的背景，是既无横面又无竖面的抽象背景，赭石色的底色，以人物为中心，渐次向外加深，使吹笛少年处于明亮的空间中。</p><h2 id="马奈《草地上的午餐》"><a href="#马奈《草地上的午餐》" class="headerlink" title="马奈《草地上的午餐》"></a>马奈《草地上的午餐》</h2><p>&emsp;&emsp;《草地上的午餐》(法文:Le déjeuner sur l’herbe)是法国写实派与印象派画家爱德华·马奈创作于1863年的一幅布面油画。原名为《浴》(法文:Le Bain)。现收藏于巴黎奥赛美术馆。</p><p>&emsp;&emsp;画上拉斐尔的女神和乔尔乔内的仙女成了女模特儿，其中一个裸体，另一个半穿着衣服。她们和两个衣冠楚楚但显然又”放荡不羁”的波希米亚艺术家在树林中消遣娱乐。此画把人物置于同一类树木茂盛的背景中，中心展开了一个有限的深度，中间不远地方的那个弯腰的女子，成为与前景中的三个人物组成的古典式三角形构图的顶点。</p><h3 id="画作内容"><a href="#画作内容" class="headerlink" title="画作内容"></a>画作内容</h3><p>&emsp;&emsp;《草地上的午餐》描绘的是一个愉快的午后，几个年轻人在草地共进午餐后的情景。画面的背景是茂密的树林，树木枝叶繁密茂盛。画面中间的绿草地上，一个赤裸的女人无拘无束地坐在草地上，手托着下巴，面对着画外，神情悠闲自在。与此形成鲜明对比的是她身边两个衣冠楚楚的绅士模样的人，他们两两相对，正半坐半卧地谈论着，一个还伸出手比划着什么。他们的前方堆满了女人的衣服、帽子等东西，一个盛放野营食物的篮子翻倒在地，面包、水果等食物散落了一地。他们后方是一条流向画面深处的小溪，一个衣衫单薄的女人正站在小溪里汲水准备沐浴，小溪的深处隐约可见停泊着一只小船。</p><h3 id="创作背景"><a href="#创作背景" class="headerlink" title="创作背景"></a>创作背景</h3><p>&emsp;&emsp;马奈出生在巴黎一个富有的法官家庭，16岁那年在父母的安排下，登上轮船当海员。大海变幻无常的各种景致，激发了他描绘自然美的激情。两年以后，马奈毅然进入学院派画家库图尔的画室学习。但是，不久之后，他便认为学院派的风格僵化、虚假，甚至发出”走进画室就如进入坟墓”的感叹。</p><p>&emsp;&emsp;离开画室后，马奈到各地美术馆临摹和研究前代大师们的作品，并在实际创作中，融入了很多自己独特的创新思想。经过不断的磨练，马奈终于在1863年创作出了《草地上的午餐》。</p><h3 id="艺术鉴赏"><a href="#艺术鉴赏" class="headerlink" title="艺术鉴赏"></a>艺术鉴赏</h3><h4 id="画面"><a href="#画面" class="headerlink" title="画面"></a>画面</h4><p>&emsp;&emsp;整个画面清新、淡雅，把一次草地午餐描绘得愉快、闲适、随意、自然。画面上蜿蜓曲折分成两个层次的流水，使画面有一种流动的感觉。画上色彩浓重，光线也很强烈，具有很强的色感和光感。</p><h4 id="画法"><a href="#画法" class="headerlink" title="画法"></a>画法</h4><p>&emsp;&emsp;这幅画的画法抛弃了人们所习惯的光滑用笔，而且不借助线条而是用色彩造型。并且作者运用了强烈的色彩和明快的平透色彩，从而彻底突破了传统的厚涂法，使画面变成了二度平面。</p><h4 id="构图"><a href="#构图" class="headerlink" title="构图"></a>构图</h4><p>&emsp;&emsp;在构图上，马奈采用了稳定的三角形，画面中间的三位人物与远处的女子及更远处的森林深处等，都可以构成纵深的三角形。</p><h4 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h4><p>&emsp;&emsp;技巧方面，古典主义绘画讲究透视、空间，观者在欣赏一幅古典绘画时，通常能感觉画面所营造出的景深感。而马奈则试图打破古典绘画这一传统，《草地上的午餐》的光源似乎来自画的正前方，不柔和的光线赋予了画面一种平面感，所需色彩均被平涂于画布之上，同时简化对象的明暗层次，省略中间色，加强光影间的对比。这样一来，画面的空间关系被削弱，平面感增强，进而一种有悖于传统绘画的新式绘画语言—平面性应运而生。</p><h2 id="雷诺阿《红磨坊的舞会》"><a href="#雷诺阿《红磨坊的舞会》" class="headerlink" title="雷诺阿《红磨坊的舞会》"></a>雷诺阿《红磨坊的舞会》</h2><p>&emsp;&emsp;《红磨坊的舞会》又名《煎饼磨坊的舞会》，是法国画家奥古斯特·雷诺阿1876年所创作的一幅油画。</p><p>&emsp;&emsp;这幅作品描绘出众多的人物，给人拥挤的感觉，人头攒动，色斑跳跃，热闹非凡，给人以愉快欢乐的强烈印象。</p><h3 id="创作背景-1"><a href="#创作背景-1" class="headerlink" title="创作背景"></a>创作背景</h3><p>&emsp;&emsp;1899年在法国蒙马特开业的”红磨坊”酒吧吸引了包括英国王太子在内的社会名流及众多年轻作家、艺术家。经历了100多年风雨沧桑的”红磨坊”，在历史的境迁中，丝毫没有褪色，反而越来越受到全世界人们的关注。屋顶上旋转的大红风车已经成为巴黎蒙马特的标志，更令全世界慕名而来的游客们向往。</p><p>&emsp;&emsp;”红磨坊”长盛不衰的原因还有两个:首先，令众多贪杯者流连忘返的”红磨坊”啤酒，一直严格地遵守并保留了传统的啤酒酿造工艺，独特的口味令无数人开怀畅饮，夜夜不归。另外， “红磨坊”酒吧与法国后印象派绘画大师雷诺阿的创作结下了不解之缘。雷诺阿是”红磨坊”的常客，他创作了《红磨坊的舞会》。其后，他受酒吧老板之邀为其创作宣传海报，当那些大胆革新及充满艺术品位的海报贴满大街小巷时，无数人涌向红磨坊酒吧。</p><p>&emsp;&emsp;法国红磨坊有着悠久的历史，自1899年开业至今，五代经营者将红磨坊发展成为国际化的知名品牌，其传统的酿酒工艺深受世界各国消费者的喜爱。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;
        
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://rhythmlian.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://rhythmlian.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>C++面试知识点（GitHub镜像）</title>
    <link href="https://rhythmlian.cn/2020/06/09/cpp-interview/"/>
    <id>https://rhythmlian.cn/2020/06/09/cpp-interview/</id>
    <published>2020-06-09T08:20:58.000Z</published>
    <updated>2020-06-09T08:27:21.145Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="➕-C-C"><a href="#➕-C-C" class="headerlink" title="➕ C/C++"></a>➕ C/C++</h2><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol><li>修饰变量，说明该变量不可以被改变；</li><li>修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；</li><li>修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li><li>修饰成员函数，说明该成员函数内不能修改成员变量。</li></ol><h4 id="const-的指针与引用"><a href="#const-的指针与引用" class="headerlink" title="const 的指针与引用"></a>const 的指针与引用</h4><ul><li>指针<ul><li>指向常量的指针（pointer to const）</li><li>自身是常量的指针（常量指针，const pointer）</li></ul></li><li>引用<ul><li>指向常量的引用（reference to const）</li><li>没有 const reference，因为引用本身就是 const pointer</li></ul></li></ul><blockquote><p>（为了方便记忆可以想成）被 const 修饰（在 const 后面）的值不可改变，如下文使用例子中的 <code>p2</code>、<code>p3</code></p></blockquote><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>const 使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a;                <span class="comment">// 常对象成员，只能在初始化列表赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    A() : a(<span class="number">0</span>) &#123; &#125;;</span><br><span class="line">    A(<span class="keyword">int</span> x) : a(x) &#123; &#125;;        <span class="comment">// 初始化列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const可用于对重载函数的区分</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>;             <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span>;       <span class="comment">// 常成员函数，不得修改类中的任何数据成员的值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对象</span></span><br><span class="line">    A b;                        <span class="comment">// 普通对象，可以调用全部成员函数、更新常成员变量</span></span><br><span class="line">    <span class="keyword">const</span> A a;                  <span class="comment">// 常对象，只能调用常成员函数</span></span><br><span class="line">    <span class="keyword">const</span> A *p = &amp;a;            <span class="comment">// 指针变量，指向常对象</span></span><br><span class="line">    <span class="keyword">const</span> A &amp;q = a;             <span class="comment">// 指向常对象的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针</span></span><br><span class="line">    <span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="keyword">char</span>* p1 = greeting;                <span class="comment">// 指针变量，指向字符数组变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* p2 = greeting;          <span class="comment">// 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）</span></span><br><span class="line">    <span class="keyword">char</span>* <span class="keyword">const</span> p3 = greeting;          <span class="comment">// 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p4 = greeting;    <span class="comment">// 自身是常量的指针，指向字符数组常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> Var)</span></span>;           <span class="comment">// 传递过来的参数在函数内不可变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* Var)</span></span>;         <span class="comment">// 参数指针所指内容为常量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function3</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">const</span> Var)</span></span>;         <span class="comment">// 参数指针为常量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function4</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Var)</span></span>;          <span class="comment">// 引用参数在函数内为常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回值</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">function5</span><span class="params">()</span></span>;      <span class="comment">// 返回一个常数</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="title">function6</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向常量的指针变量，使用：const int *p = function6();</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="keyword">const</span> <span class="title">function7</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向变量的常指针，使用：int* const p = function7();</span></span><br></pre></td></tr></table></figure><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ol><li>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</li><li>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。</li><li>修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。</li><li>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。</li></ol><h3 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h3><ol><li><code>this</code> 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。</li><li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给 <code>this</code> 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 <code>this</code> 指针。</li><li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li><li><code>this</code> 指针被隐含地声明为: <code>ClassName *const this</code>，这意味着不能给 <code>this</code> 指针赋值；在 <code>ClassName</code> 类的 <code>const</code> 成员函数中，<code>this</code> 指针的类型为：<code>const ClassName* const</code>，这说明不能对 <code>this</code> 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</li><li><code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址（不能 <code>&amp;this</code>）。</li><li>在以下场景中，经常需要显式引用 <code>this</code> 指针：<ol><li>为实现对象的链式引用；</li><li>为避免对同一对象进行赋值操作；</li><li>在实现一些数据结构时，如 <code>list</code>。</li></ol></li></ol><h3 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title="inline 内联函数"></a>inline 内联函数</h3><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li>相当于把内联函数里面的内容写在调用内联函数处；</li><li>相当于不用执行进入函数的步骤，直接执行函数体；</li><li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li><li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li><li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</li></ul><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>inline 使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明1（加 inline，建议使用）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明2（不加 inline）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span> </span>&#123;<span class="comment">/****/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类内定义，隐式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;         <span class="comment">// 隐式内联</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义，需要显式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">A::doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;   <span class="comment">// 需要显式内联</span></span><br></pre></td></tr></table></figure><h4 id="编译器对-inline-函数的处理步骤"><a href="#编译器对-inline-函数的处理步骤" class="headerlink" title="编译器对 inline 函数的处理步骤"></a>编译器对 inline 函数的处理步骤</h4><ol><li>将 inline 函数体复制到 inline 函数调用点处； </li><li>为所用 inline 函数中的局部变量分配内存空间； </li><li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； </li><li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li></ol><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点</p><ol><li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li><li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 </li><li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li><li>内联函数在运行时可调试，而宏定义不可以。</li></ol><p>缺点</p><ol><li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li><li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li><li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li></ol><h4 id="虚函数（virtual）可以是内联函数（inline）吗？"><a href="#虚函数（virtual）可以是内联函数（inline）吗？" class="headerlink" title="虚函数（virtual）可以是内联函数（inline）吗？"></a>虚函数（virtual）可以是内联函数（inline）吗？</h4><blockquote><p><a href="http://www.cs.technion.ac.il/users/yechiel/c++-faq/inline-virtuals.html" target="_blank" rel="noopener">Are “inline virtual” member functions ever actually “inlined”?</a></p></blockquote><ul><li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li><li>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li><li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li></ul><p>虚函数内联使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">who</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"I am Base\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~Base() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">who</span><span class="params">()</span>  <span class="comment">// 不写inline时隐式内联</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"I am Derived\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 </span></span><br><span class="line">Base b;</span><br><span class="line">b.who();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  </span></span><br><span class="line">Base *ptr = <span class="keyword">new</span> Derived();</span><br><span class="line">ptr-&gt;who();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。</span></span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line">ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><ul><li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</li><li>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li><li>const 可以是 volatile （如只读的状态寄存器）</li><li>指针可以是 volatile</li></ul><h3 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h3><p>断言，是宏，而非函数。assert 宏的原型定义在 <code>&lt;assert.h&gt;</code>（C）、<code>&lt;cassert&gt;</code>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 <code>NDEBUG</code> 来关闭 assert，但是需要在源代码的开头，<code>include &lt;assert.h&gt;</code> 之前。</p><p>assert() 使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDEBUG          <span class="comment">// 加上这行，则 assert 不可用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">assert( p != <span class="literal">NULL</span> );    <span class="comment">// assert 不可用</span></span><br></pre></td></tr></table></figure><h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof()"></a>sizeof()</h3><ul><li>sizeof 对数组，得到整个数组所占空间大小。</li><li>sizeof 对指针，得到指针本身所占空间大小。</li></ul><h3 id="pragma-pack-n"><a href="#pragma-pack-n" class="headerlink" title="#pragma pack(n)"></a>#pragma pack(n)</h3><p>设定结构体、联合以及类成员变量以 n 字节方式对齐</p><h1 id="pragma-pack-n-使用"><a href="#pragma-pack-n-使用" class="headerlink" title="pragma pack(n) 使用"></a>pragma pack(n) 使用</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push)  <span class="comment">// 保存对齐状态</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)     <span class="comment">// 设定为 4 字节对齐</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> m1;</span><br><span class="line">    <span class="keyword">double</span> m4;</span><br><span class="line">    <span class="keyword">int</span> m3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)   <span class="comment">// 恢复对齐状态</span></span></span><br></pre></td></tr></table></figure><h3 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bit mode: <span class="number">2</span>;    <span class="comment">// mode 占 2 位</span></span><br></pre></td></tr></table></figure><p>类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。</p><ul><li>位域在内存中的布局是与机器有关的</li><li>位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定</li><li>取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域</li></ul><h3 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h3><ul><li>被 extern 限定的函数或变量是 extern 类型的</li><li>被 <code>extern &quot;C&quot;</code> 修饰的变量和函数是按照 C 语言方式编译和链接的</li></ul><p><code>extern &quot;C&quot;</code> 的作用是让 C++ 编译器将 <code>extern &quot;C&quot;</code> 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。</p><p>extern “C” 使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">int</span>, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="struct-和-typedef-struct"><a href="#struct-和-typedef-struct" class="headerlink" title="struct 和 typedef struct"></a>struct 和 typedef struct</h3><h4 id="C-中"><a href="#C-中" class="headerlink" title="C 中"></a>C 中</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">&#125; S;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">S</span>;</span></span><br></pre></td></tr></table></figure><p>此时 <code>S</code> 等价于 <code>struct Student</code>，但两个标识符名称空间不相同。</p><p>另外还可以定义与 <code>struct Student</code> 不冲突的 <code>void Student() {}</code>。</p><h4 id="C-中-1"><a href="#C-中-1" class="headerlink" title="C++ 中"></a>C++ 中</h4><p>由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。</p><p>一、如果在类标识符空间定义了 <code>struct Student {...};</code>，使用 <code>Student me;</code> 时，编译器将搜索全局标识符表，<code>Student</code> 未找到，则在类标识符内搜索。</p><p>即表现为可以使用 <code>Student</code> 也可以使用 <code>struct Student</code>，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( Student me )</span></span>;       <span class="comment">// 正确，"struct" 关键字可省略</span></span><br></pre></td></tr></table></figure><p>二、若定义了与 <code>Student</code> 同名函数之后，则 <code>Student</code> 只代表函数，不代表结构体，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">&#125; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;&#125;           <span class="comment">// 正确，定义后 "Student" 只代表此函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void S() &#123;&#125;               // 错误，符号 "S" 已经被定义为一个 "struct Student" 的别名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student(); </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">me</span>;</span>      <span class="comment">// 或者 "S me";</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-中-struct-和-class"><a href="#C-中-struct-和-class" class="headerlink" title="C++ 中 struct 和 class"></a>C++ 中 struct 和 class</h3><p>总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>最本质的一个区别就是默认的访问控制<ol><li>默认的继承访问权限。struct 是 public 的，class 是 private 的。  </li><li>struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。</li></ol></li></ul><h3 id="union-联合"><a href="#union-联合" class="headerlink" title="union 联合"></a>union 联合</h3><p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p><ul><li>默认访问控制符为 public</li><li>可以含有构造函数、析构函数</li><li>不能含有引用类型的成员</li><li>不能继承自其他类，不能作为基类</li><li>不能含有虚函数</li><li>匿名 union 在定义所在作用域可直接访问 union 成员</li><li>匿名 union 不能包含 protected 成员或 private 成员</li><li>全局匿名联合必须是静态（static）的</li></ul><p>union 使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> UnionTest &#123;</span><br><span class="line">    UnionTest() : i(<span class="number">10</span>) &#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UnionTest u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; u.i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出 UnionTest 联合的 10</span></span><br><span class="line"></span><br><span class="line">    ::i = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ::i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出全局静态匿名联合的 20</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">// 输出局部匿名联合的 30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-实现-C-类"><a href="#C-实现-C-类" class="headerlink" title="C 实现 C++ 类"></a>C 实现 C++ 类</h3><p>C 实现 C++ 的面向对象特性（封装、继承、多态）</p><ul><li>封装：使用函数指针把属性与方法封装到结构体中</li><li>继承：结构体嵌套</li><li>多态：父类与子类方法的函数指针不同</li></ul><blockquote><p><a href="https://stackoverflow.com/a/351745" target="_blank" rel="noopener">Can you write object-oriented code in C? [closed]</a></p></blockquote><h3 id="explicit（显式）关键字"><a href="#explicit（显式）关键字" class="headerlink" title="explicit（显式）关键字"></a>explicit（显式）关键字</h3><ul><li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li><li>explicit 修饰转换函数时，可以防止隐式转换，但 <a href="https://zh.cppreference.com/w/cpp/language/implicit_conversion" target="_blank" rel="noopener">按语境转换</a> 除外</li></ul><p>explicit 使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">A(<span class="keyword">int</span>) &#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doA</span><span class="params">(A a)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doB</span><span class="params">(B b)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">A <span class="title">a1</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">// OK：直接初始化</span></span><br><span class="line">A a2 = <span class="number">1</span>;<span class="comment">// OK：复制初始化</span></span><br><span class="line">A a3&#123; <span class="number">1</span> &#125;;<span class="comment">// OK：直接列表初始化</span></span><br><span class="line">A a4 = &#123; <span class="number">1</span> &#125;;<span class="comment">// OK：复制列表初始化</span></span><br><span class="line">A a5 = (A)<span class="number">1</span>;<span class="comment">// OK：允许 static_cast 的显式转换 </span></span><br><span class="line">doA(<span class="number">1</span>);<span class="comment">// OK：允许从 int 到 A 的隐式转换</span></span><br><span class="line"><span class="keyword">if</span> (a1);<span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line"><span class="keyword">bool</span> a6（a1）;<span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line"><span class="keyword">bool</span> a7 = a1;<span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line"><span class="keyword">bool</span> a8 = <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(a1);  <span class="comment">// OK ：static_cast 进行直接初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function">B <span class="title">b1</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">// OK：直接初始化</span></span><br><span class="line">B b2 = <span class="number">1</span>;<span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以复制初始化</span></span><br><span class="line">B b3&#123; <span class="number">1</span> &#125;;<span class="comment">// OK：直接列表初始化</span></span><br><span class="line">B b4 = &#123; <span class="number">1</span> &#125;;<span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化</span></span><br><span class="line">B b5 = (B)<span class="number">1</span>;<span class="comment">// OK：允许 static_cast 的显式转换</span></span><br><span class="line">doB(<span class="number">1</span>);<span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换</span></span><br><span class="line"><span class="keyword">if</span> (b1);<span class="comment">// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">b6</span><span class="params">(b1)</span></span>;<span class="comment">// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换</span></span><br><span class="line"><span class="keyword">bool</span> b7 = b1;<span class="comment">// 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换</span></span><br><span class="line"><span class="keyword">bool</span> b8 = <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(b1);  <span class="comment">// OK：static_cast 进行直接初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="friend-友元类和友元函数"><a href="#friend-友元类和友元函数" class="headerlink" title="friend 友元类和友元函数"></a>friend 友元类和友元函数</h3><ul><li>能访问私有成员  </li><li>破坏封装性</li><li>友元关系不可传递</li><li>友元关系的单向性</li><li>友元声明的形式及数量不受限制</li></ul><h3 id="using"><a href="#using" class="headerlink" title="using"></a>using</h3><h4 id="using-声明"><a href="#using-声明" class="headerlink" title="using 声明"></a>using 声明</h4><p>一条 <code>using 声明</code> 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> namespace_name::name;</span><br></pre></td></tr></table></figure><h4 id="构造函数的-using-声明"><a href="#构造函数的-using-声明" class="headerlink" title="构造函数的 using 声明"></a>构造函数的 using 声明</h4><p>在 C++11 中，派生类能够重用其直接基类定义的构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Derived(parms) : Base(args) &#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="using-指示"><a href="#using-指示" class="headerlink" title="using 指示"></a>using 指示</h4><p><code>using 指示</code> 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> namespace_name name;</span><br></pre></td></tr></table></figure><h4 id="尽量少使用-using-指示-污染命名空间"><a href="#尽量少使用-using-指示-污染命名空间" class="headerlink" title="尽量少使用 using 指示 污染命名空间"></a>尽量少使用 <code>using 指示</code> 污染命名空间</h4><blockquote><p>一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它<strong>只导入了指定的名称</strong>。如果该名称与局部名称发生冲突，编译器将<strong>发出指示</strong>。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则<strong>局部名称将覆盖名称空间版本</strong>，而编译器<strong>并不会发出警告</strong>。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。</p></blockquote><p>using 使用</p><p>尽量少使用 <code>using 指示</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><p>应该多使用 <code>using 声明</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x ;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h3 id="范围解析运算符"><a href="#范围解析运算符" class="headerlink" title=":: 范围解析运算符"></a>:: 范围解析运算符</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ol><li>全局作用域符（<code>::name</code>）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</li><li>类作用域符（<code>class::name</code>）：用于表示指定类型的作用域范围是具体某个类的</li><li>命名空间作用域符（<code>namespace::name</code>）:用于表示指定类型的作用域范围是具体某个命名空间的</li></ol><p>:: 使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">11</span>;         <span class="comment">// 全局（::）的 count</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count;   <span class="comment">// 类 A 的 count（A::count）</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> A::count = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">31</span>;     <span class="comment">// 初始化局部的 count 为 31</span></span><br><span class="line">count = <span class="number">32</span>;         <span class="comment">// 设置局部的 count 的值为 32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">::count = <span class="number">12</span>;       <span class="comment">// 测试 1：设置全局的 count 的值为 12</span></span><br><span class="line"></span><br><span class="line">A::count = <span class="number">22</span>;      <span class="comment">// 测试 2：设置类 A 的 count 为 22</span></span><br><span class="line"></span><br><span class="line">fun();        <span class="comment">// 测试 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="enum-枚举类型"><a href="#enum-枚举类型" class="headerlink" title="enum 枚举类型"></a>enum 枚举类型</h3><h4 id="限定作用域的枚举类型"><a href="#限定作用域的枚举类型" class="headerlink" title="限定作用域的枚举类型"></a>限定作用域的枚举类型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">open_modes</span> &#123;</span> input, output, append &#125;;</span><br></pre></td></tr></table></figure><h4 id="不限定作用域的枚举类型"><a href="#不限定作用域的枚举类型" class="headerlink" title="不限定作用域的枚举类型"></a>不限定作用域的枚举类型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> color &#123; red, yellow, green &#125;;</span><br><span class="line"><span class="keyword">enum</span> &#123; floatPrec = <span class="number">6</span>, doublePrec = <span class="number">10</span> &#125;;</span><br></pre></td></tr></table></figure><h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p>decltype 关键字用于检查实体的声明类型或表达式的类型及值分类。语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span> ( expression )</span><br></pre></td></tr></table></figure><p>decltype 使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尾置返回允许我们在参数列表之后声明返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn(It beg, It end) -&gt; decltype(*beg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg;    <span class="comment">// 返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为了使用模板参数成员，必须用 typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn2(It beg, It end) -&gt; typename remove_reference&lt;decltype(*beg)&gt;::type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg;    <span class="comment">// 返回序列中一个元素的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h4><p>常规引用，一般表示对象的身份。</p><h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><p>右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。</p><p>右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：</p><ul><li>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</li><li>能够更简洁明确地定义泛型函数。</li></ul><h4 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h4><ul><li><code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>、<code>X&amp;&amp; &amp;</code> 可折叠成 <code>X&amp;</code></li><li><code>X&amp;&amp; &amp;&amp;</code> 可折叠成 <code>X&amp;&amp;</code></li></ul><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><ul><li>宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。</li></ul><h3 id="成员初始化列表"><a href="#成员初始化列表" class="headerlink" title="成员初始化列表"></a>成员初始化列表</h3><p>好处</p><ul><li>更高效：少了一次调用默认构造函数的过程。</li><li>有些场合必须要用初始化列表：<ol><li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li><li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li><li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化</li></ol></li></ul><h3 id="initializer-list-列表初始化"><a href="#initializer-list-列表初始化" class="headerlink" title="initializer_list 列表初始化"></a>initializer_list 列表初始化</h3><p>用花括号初始化器列表初始化一个对象，其中对应构造函数接受一个 <code>std::initializer_list</code> 参数.</p><p>initializer_list 使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; v;</span><br><span class="line">    S(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; l) : v(l) &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"constructed with a "</span> &lt;&lt; l.size() &lt;&lt; <span class="string">"-element list\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; l)</span> </span>&#123;</span><br><span class="line">        v.insert(v.end(), l.begin(), l.end());</span><br><span class="line">    &#125;</span><br><span class="line">    std::pair&lt;const T*, std::size_t&gt; c_arr() const &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&amp;v[<span class="number">0</span>], v.size()&#125;;  <span class="comment">// 在 return 语句中复制列表初始化</span></span><br><span class="line">                                   <span class="comment">// 这不使用 std::initializer_list</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">templated_fn</span><span class="params">(T)</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S&lt;<span class="keyword">int</span>&gt; s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 复制初始化</span></span><br><span class="line">    s.append(&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;);      <span class="comment">// 函数调用中的列表初始化</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The vector size is now "</span> &lt;&lt; s.c_arr().second &lt;&lt; <span class="string">" ints:\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : s.v)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Range-for over brace-init-list: \n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>&#125;) <span class="comment">// auto 的规则令此带范围 for 工作</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> al = &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;   <span class="comment">// auto 的特殊规则</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The list bound to auto has size() = "</span> &lt;&lt; al.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//    templated_fn(&#123;1, 2, 3&#125;); // 编译错误！“ &#123;1, 2, 3&#125; ”不是表达式，</span></span><br><span class="line">                             <span class="comment">// 它无类型，故 T 无法推导</span></span><br><span class="line">    templated_fn&lt;<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;&gt;(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;); <span class="comment">// OK</span></span><br><span class="line">    templated_fn&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);           <span class="comment">// 也 OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。</p><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/面向对象基本特征.png" alt="面向对象特征"></p><p>面向对象三大特征 —— 封装、继承、多态</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。</p><ul><li><code>public</code> 成员：可以被任意实体访问</li><li><code>protected</code> 成员：只允许被子类及本类的成员函数访问</li><li><code>private</code> 成员：只允许被本类的成员函数、友元类或友元函数访问</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>基类（父类）——&gt; 派生类（子类）</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul><li>多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。</li><li>多态是以封装和继承为基础的。</li><li>C++ 多态分类及实现：<ol><li>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载</li><li>子类型多态（Subtype Polymorphism，运行期）：虚函数</li><li>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板</li><li>强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换</li></ol></li></ul><blockquote><p><a href="https://catonmat.net/cpp-polymorphism" target="_blank" rel="noopener">The Four Polymorphisms in C++</a></p></blockquote><h4 id="静态多态（编译期-早绑定）"><a href="#静态多态（编译期-早绑定）" class="headerlink" title="静态多态（编译期/早绑定）"></a>静态多态（编译期/早绑定）</h4><p>函数重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="动态多态（运行期期-晚绑定）"><a href="#动态多态（运行期期-晚绑定）" class="headerlink" title="动态多态（运行期期/晚绑定）"></a>动态多态（运行期期/晚绑定）</h4><ul><li>虚函数：用 virtual 修饰成员函数，使其成为虚函数</li></ul><p><strong>注意：</strong></p><ul><li>普通函数（非类成员函数）不能是虚函数</li><li>静态函数（static）不能是虚函数</li><li>构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）</li><li>内联函数不能是表现多态性时的虚函数，解释见：<a href="https://github.com/huihut/interview#%E8%99%9A%E5%87%BD%E6%95%B0virtual%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0inline%E5%90%97" target="_blank" rel="noopener">虚函数（virtual）可以是内联函数（inline）吗？</a></li></ul><p>动态多态使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>                     // 形状类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Shape();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape     <span class="comment">// 圆形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> :</span> <span class="keyword">public</span> Shape       <span class="comment">// 矩形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape * shape1 = <span class="keyword">new</span> Circle(<span class="number">4.0</span>);</span><br><span class="line">    Shape * shape2 = <span class="keyword">new</span> Rect(<span class="number">5.0</span>, <span class="number">6.0</span>);</span><br><span class="line">    shape1-&gt;calcArea();         <span class="comment">// 调用圆形类里面的方法</span></span><br><span class="line">    shape2-&gt;calcArea();         <span class="comment">// 调用矩形类里面的方法</span></span><br><span class="line">    <span class="keyword">delete</span> shape1;</span><br><span class="line">    shape1 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> shape2;</span><br><span class="line">    shape2 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。</p><p>虚析构函数使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Shape();                    <span class="comment">// 构造函数不能是虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Shape();           <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape     <span class="comment">// 圆形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape * shape1 = <span class="keyword">new</span> Circle(<span class="number">4.0</span>);</span><br><span class="line">    shape1-&gt;calcArea();    </span><br><span class="line">    <span class="keyword">delete</span> shape1;  <span class="comment">// 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。</span></span><br><span class="line">    shape1 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">A</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="虚函数、纯虚函数"><a href="#虚函数、纯虚函数" class="headerlink" title="虚函数、纯虚函数"></a>虚函数、纯虚函数</h3><ul><li>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。 </li><li>虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。</li><li>虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。 </li><li>带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。</li><li>虚基类是虚继承中的基类，具体见下文虚继承。</li></ul><blockquote><p><a href="https://blog.csdn.net/u012260238/article/details/53610462" target="_blank" rel="noopener">CSDN . C++ 中的虚函数、纯虚函数区别和联系</a></p></blockquote><h3 id="虚函数指针、虚函数表"><a href="#虚函数指针、虚函数表" class="headerlink" title="虚函数指针、虚函数表"></a>虚函数指针、虚函数表</h3><ul><li>虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。</li><li>虚函数表：在程序只读数据段（<code>.rodata section</code>，见：<a href="#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">目标文件存储结构</a>），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。</li></ul><blockquote><p><a href="https://blog.twofei.com/496/" target="_blank" rel="noopener">C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现</a></p></blockquote><h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。</p><p>底层实现原理与编译器相关，一般通过<strong>虚基类指针</strong>和<strong>虚基类表</strong>实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p><p>实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p><h3 id="虚继承、虚函数"><a href="#虚继承、虚函数" class="headerlink" title="虚继承、虚函数"></a>虚继承、虚函数</h3><ul><li>相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）</li><li>不同之处：<ul><li>虚继承<ul><li>虚基类依旧存在继承类中，只占用存储空间</li><li>虚基类表存储的是虚基类相对直接继承类的偏移</li></ul></li><li>虚函数<ul><li>虚函数不占用存储空间</li><li>虚函数表存储的是虚函数地址</li></ul></li></ul></li></ul><h3 id="模板类、成员模板、虚函数"><a href="#模板类、成员模板、虚函数" class="headerlink" title="模板类、成员模板、虚函数"></a>模板类、成员模板、虚函数</h3><ul><li>模板类中可以使用虚函数</li><li>一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数</li></ul><h3 id="抽象类、接口类、聚合类"><a href="#抽象类、接口类、聚合类" class="headerlink" title="抽象类、接口类、聚合类"></a>抽象类、接口类、聚合类</h3><ul><li>抽象类：含有纯虚函数的类</li><li>接口类：仅含有纯虚函数的抽象类</li><li>聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：<ul><li>所有成员都是 public</li><li>没有定义任何构造函数</li><li>没有类内初始化</li><li>没有基类，也没有 virtual 函数</li></ul></li></ul><h3 id="内存分配和管理"><a href="#内存分配和管理" class="headerlink" title="内存分配和管理"></a>内存分配和管理</h3><h4 id="malloc、calloc、realloc、alloca"><a href="#malloc、calloc、realloc、alloca" class="headerlink" title="malloc、calloc、realloc、alloca"></a>malloc、calloc、realloc、alloca</h4><ol><li>malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。</li><li>calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。</li><li>realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。</li><li>alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。</li></ol><h4 id="malloc、free"><a href="#malloc、free" class="headerlink" title="malloc、free"></a>malloc、free</h4><p>用于分配、释放内存</p><p>malloc、free 使用</p><p>申请内存，确认是否申请成功</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">assert(str != <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p>释放内存后指针置空</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(p); </span><br><span class="line">p = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><h4 id="new、delete"><a href="#new、delete" class="headerlink" title="new、delete"></a>new、delete</h4><ol><li>new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。</li><li>delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</li><li>new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。</li></ol><p>new、delete 使用</p><p>申请内存，确认是否申请成功</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T* t = <span class="keyword">new</span> T();     <span class="comment">// 先内存分配 ，再构造函数</span></span><br><span class="line">    <span class="keyword">delete</span> t;           <span class="comment">// 先析构函数，再内存释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定位-new"><a href="#定位-new" class="headerlink" title="定位 new"></a>定位 new</h4><p>定位 new（placement new）允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> (place_address) type</span><br><span class="line"><span class="keyword">new</span> (place_address) type (initializers)</span><br><span class="line"><span class="keyword">new</span> (place_address) type [size]</span><br><span class="line"><span class="keyword">new</span> (place_address) type [size] &#123; braced initializer <span class="built_in">list</span> &#125;</span><br></pre></td></tr></table></figure><ul><li><code>place_address</code> 是个指针</li><li><code>initializers</code> 提供一个（可能为空的）以逗号分隔的初始值列表</li></ul><h3 id="delete-this-合法吗？"><a href="#delete-this-合法吗？" class="headerlink" title="delete this 合法吗？"></a>delete this 合法吗？</h3><blockquote><p><a href="https://isocpp.org/wiki/faq/freestore-mgmt#delete-this" target="_blank" rel="noopener">Is it legal (and moral) for a member function to say delete this?</a></p></blockquote><p>合法，但：</p><ol><li>必须保证 this 对象是通过 <code>new</code>（不是 <code>new[]</code>、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li><li>必须保证调用 <code>delete this</code> 的成员函数是最后一个调用 this 的成员函数</li><li>必须保证成员函数的 <code>delete this</code> 后面没有调用 this 了</li><li>必须保证 <code>delete this</code> 后没有人使用了</li></ol><h3 id="如何定义一个只能在堆上（栈上）生成对象的类？"><a href="#如何定义一个只能在堆上（栈上）生成对象的类？" class="headerlink" title="如何定义一个只能在堆上（栈上）生成对象的类？"></a>如何定义一个只能在堆上（栈上）生成对象的类？</h3><blockquote><p><a href="https://www.nowcoder.com/questionTerminal/0a584aa13f804f3ea72b442a065a7618" target="_blank" rel="noopener">如何定义一个只能在堆上（栈上）生成对象的类?</a></p></blockquote><h4 id="只能在堆上"><a href="#只能在堆上" class="headerlink" title="只能在堆上"></a>只能在堆上</h4><p>方法：将析构函数设置为私有</p><p>原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</p><h4 id="只能在栈上"><a href="#只能在栈上" class="headerlink" title="只能在栈上"></a>只能在栈上</h4><p>方法：将 new 和 delete 重载为私有</p><p>原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</p><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><h4 id="C-标准库（STL）中"><a href="#C-标准库（STL）中" class="headerlink" title="C++ 标准库（STL）中"></a>C++ 标准库（STL）中</h4><p>头文件：<code>#include &lt;memory&gt;</code></p><h4 id="C-98"><a href="#C-98" class="headerlink" title="C++ 98"></a>C++ 98</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::auto_ptr&lt;std::string&gt; ps (new std::string(str))；</span><br></pre></td></tr></table></figure><h4 id="C-11"><a href="#C-11" class="headerlink" title="C++ 11"></a>C++ 11</h4><ol><li>shared_ptr</li><li>unique_ptr</li><li>weak_ptr</li><li>auto_ptr（被 C++11 弃用）</li></ol><ul><li>Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。</li><li>Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。</li></ul><h5 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h5><p>多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。</p><ul><li>支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁</li></ul><h5 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h5><p>weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。</p><ul><li>可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题</li></ul><h5 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h5><p>unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。</p><ul><li>unique_ptr 用于取代 auto_ptr</li></ul><h5 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h5><p>被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 <code>std::move</code> 语义，以及其他瑕疵。</p><h5 id="auto-ptr-与-unique-ptr-比较"><a href="#auto-ptr-与-unique-ptr-比较" class="headerlink" title="auto_ptr 与 unique_ptr 比较"></a>auto_ptr 与 unique_ptr 比较</h5><ul><li>auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了<code>move</code> 语义；</li><li>auto_ptr 对象不能管理数组（析构调用 <code>delete</code>），unique_ptr 可以管理数组（析构调用 <code>delete[]</code> ）；</li></ul><h3 id="强制类型转换运算符"><a href="#强制类型转换运算符" class="headerlink" title="强制类型转换运算符"></a>强制类型转换运算符</h3><blockquote><p><a href="https://msdn.microsoft.com/zh-CN/library/5f6c9f8h.aspx" target="_blank" rel="noopener">MSDN . 强制转换运算符</a></p></blockquote><h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h4><ul><li>用于非多态类型的转换</li><li>不执行运行时类型检查（转换安全性不如 dynamic_cast）</li><li>通常用于转换数值数据类型（如 float -&gt; int）</li><li>可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）</li></ul><blockquote><p>向上转换是一种隐式转换。</p></blockquote><h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><ul><li>用于多态类型的转换</li><li>执行行运行时类型检查</li><li>只适用于指针或引用</li><li>对不明确的指针的转换将失败（返回 nullptr），但不引发异常</li><li>可以在整个类层次结构中移动指针，包括向上转换、向下转换</li></ul><h4 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h4><ul><li>用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）</li></ul><h4 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h4><ul><li>用于位的简单重新解释</li><li>滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。</li><li>允许将任何指针转换为任何其他指针类型（如 <code>char*</code> 到 <code>int*</code> 或 <code>One_class*</code> 到 <code>Unrelated_class*</code> 之类的转换，但其本身并不安全）</li><li>也允许将任何整数类型转换为任何指针类型以及反向转换。</li><li>reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。 </li><li>reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。</li></ul><h4 id="bad-cast"><a href="#bad-cast" class="headerlink" title="bad_cast"></a>bad_cast</h4><ul><li>由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。</li></ul><p>bad_cast 使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    Circle&amp; ref_circle = <span class="keyword">dynamic_cast</span>&lt;Circle&amp;&gt;(ref_shape);   </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">catch</span> (bad_cast b) &#123;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Caught: "</span> &lt;&lt; b.what();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行时类型信息-RTTI"><a href="#运行时类型信息-RTTI" class="headerlink" title="运行时类型信息 (RTTI)"></a>运行时类型信息 (RTTI)</h3><h4 id="dynamic-cast-1"><a href="#dynamic-cast-1" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><ul><li>用于多态类型的转换</li></ul><h4 id="typeid"><a href="#typeid" class="headerlink" title="typeid"></a>typeid</h4><ul><li>typeid 运算符允许在运行时确定对象的类型</li><li>type_id 返回一个 type_info 对象的引用</li><li>如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数</li><li>只能获取对象的实际类型</li></ul><h4 id="type-info"><a href="#type-info" class="headerlink" title="type_info"></a>type_info</h4><ul><li>type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。</li><li>头文件：<code>typeinfo</code></li></ul><p>typeid、type_info 使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flyable</span>                       // 能飞的</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">takeoff</span><span class="params">()</span> </span>= <span class="number">0</span>;     <span class="comment">// 起飞</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">land</span><span class="params">()</span> </span>= <span class="number">0</span>;        <span class="comment">// 降落</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> :</span> <span class="keyword">public</span> Flyable         <span class="comment">// 鸟</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foraging</span><span class="params">()</span> </span>&#123;...&#125;           <span class="comment">// 觅食</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">takeoff</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">land</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Bird()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plane</span> :</span> <span class="keyword">public</span> Flyable        <span class="comment">// 飞机</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">carry</span><span class="params">()</span> </span>&#123;...&#125;              <span class="comment">// 运输</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">takeoff</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">land</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">type_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> type_info &amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> type_info &amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">before</span><span class="params">(<span class="keyword">const</span> type_info &amp; rhs)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~type_info();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Flyable *obj)</span>                 <span class="comment">// 做些事情</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj-&gt;takeoff();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(*obj).name() &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 输出传入对象类型（"class Bird" or "class Plane"）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeid</span>(*obj) == <span class="keyword">typeid</span>(Bird))            <span class="comment">// 判断对象类型</span></span><br><span class="line">    &#123;</span><br><span class="line">        Bird *bird = <span class="keyword">dynamic_cast</span>&lt;Bird *&gt;(obj); <span class="comment">// 对象转化</span></span><br><span class="line">        bird-&gt;foraging();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    obj-&gt;land();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Bird *b = <span class="keyword">new</span> Bird();</span><br><span class="line">doSomething(b);</span><br><span class="line"><span class="keyword">delete</span> b;</span><br><span class="line">b = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⭐️-Effective"><a href="#⭐️-Effective" class="headerlink" title="⭐️ Effective"></a>⭐️ Effective</h2><h3 id="Effective-C"><a href="#Effective-C" class="headerlink" title="Effective C++"></a>Effective C++</h3><ol><li>视 C++ 为一个语言联邦（C、Object-Oriented C++、Template C++、STL）</li><li>宁可以编译器替换预处理器（尽量以 <code>const</code>、<code>enum</code>、<code>inline</code> 替换 <code>#define</code>）</li><li>尽可能使用 const</li><li>确定对象被使用前已先被初始化（构造时赋值（copy 构造函数）比 default 构造后赋值（copy assignment）效率高）</li><li>了解 C++ 默默编写并调用哪些函数（编译器暗自为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符、析构函数）</li><li>若不想使用编译器自动生成的函数，就应该明确拒绝（将不想使用的成员函数声明为 private，并且不予实现）</li><li>为多态基类声明 virtual 析构函数（如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数）</li><li>别让异常逃离析构函数（析构函数应该吞下不传播异常，或者结束程序，而不是吐出异常；如果要处理异常应该在非析构的普通函数处理）</li><li>绝不在构造和析构过程中调用 virtual 函数（因为这类调用从不下降至 derived class）</li><li>令 <code>operator=</code> 返回一个 <code>reference to *this</code> （用于连锁赋值）</li><li>在 <code>operator=</code> 中处理 “自我赋值”</li><li>赋值对象时应确保复制 “对象内的所有成员变量” 及 “所有 base class 成分”（调用基类复制构造函数）</li><li>以对象管理资源（资源在构造函数获得，在析构函数释放，建议使用智能指针，资源取得时机便是初始化时机（Resource Acquisition Is Initialization，RAII））</li><li>在资源管理类中小心 copying 行为（普遍的 RAII class copying 行为是：抑制 copying、引用计数、深度拷贝、转移底部资源拥有权（类似 auto_ptr））</li><li>在资源管理类中提供对原始资源（raw resources）的访问（对原始资源的访问可能经过显式转换或隐式转换，一般而言显示转换比较安全，隐式转换对客户比较方便）</li><li>成对使用 new 和 delete 时要采取相同形式（<code>new</code> 中使用 <code>[]</code> 则 <code>delete []</code>，<code>new</code> 中不使用 <code>[]</code> 则 <code>delete</code>）</li><li>以独立语句将 newed 对象存储于（置入）智能指针（如果不这样做，可能会因为编译器优化，导致难以察觉的资源泄漏）</li><li>让接口容易被正确使用，不易被误用（促进正常使用的办法：接口的一致性、内置类型的行为兼容；阻止误用的办法：建立新类型，限制类型上的操作，约束对象值、消除客户的资源管理责任）</li><li>设计 class 犹如设计 type，需要考虑对象创建、销毁、初始化、赋值、值传递、合法值、继承关系、转换、一般化等等。</li><li>宁以 pass-by-reference-to-const 替换 pass-by-value （前者通常更高效、避免切割问题（slicing problem），但不适用于内置类型、STL迭代器、函数对象）</li><li>必须返回对象时，别妄想返回其 reference（绝不返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。）</li><li>将成员变量声明为 private（为了封装、一致性、对其读写精确控制等）</li><li>宁以 non-member、non-friend 替换 member 函数（可增加封装性、包裹弹性（packaging flexibility）、机能扩充性）</li><li>若所有参数（包括被this指针所指的那个隐喻参数）皆须要类型转换，请为此采用 non-member 函数</li><li>考虑写一个不抛异常的 swap 函数</li><li>尽可能延后变量定义式的出现时间（可增加程序清晰度并改善程序效率）</li><li>尽量少做转型动作（旧式：<code>(T)expression</code>、<code>T(expression)</code>；新式：<code>const_cast&lt;T&gt;(expression)</code>、<code>dynamic_cast&lt;T&gt;(expression)</code>、<code>reinterpret_cast&lt;T&gt;(expression)</code>、<code>static_cast&lt;T&gt;(expression)</code>、；尽量避免转型、注重效率避免 dynamic_casts、尽量设计成无需转型、可把转型封装成函数、宁可用新式转型）</li><li>避免使用 handles（包括 引用、指针、迭代器）指向对象内部（以增加封装性、使 const 成员函数的行为更像 const、降低 “虚吊号码牌”（dangling handles，如悬空指针等）的可能性）</li><li>为 “异常安全” 而努力是值得的（异常安全函数（Exception-safe functions）即使发生异常也不会泄露资源或允许任何数据结构败坏，分为三种可能的保证：基本型、强列型、不抛异常型）</li><li>透彻了解 inlining 的里里外外（inlining 在大多数 C++ 程序中是编译期的行为；inline 函数是否真正 inline，取决于编译器；大部分编译器拒绝太过复杂（如带有循环或递归）的函数 inlining，而所有对 virtual 函数的调用（除非是最平淡无奇的）也都会使 inlining 落空；inline 造成的代码膨胀可能带来效率损失；inline 函数无法随着程序库的升级而升级）</li><li>将文件间的编译依存关系降至最低（如果使用 object references 或 object pointers 可以完成任务，就不要使用 objects；如果能够，尽量以 class 声明式替换 class 定义式；为声明式和定义式提供不同的头文件）</li><li>确定你的 public 继承塑模出 is-a（是一种）关系（适用于 base classes 身上的每一件事情一定适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象）</li><li>避免遮掩继承而来的名字（可使用 using 声明式或转交函数（forwarding functions）来让被遮掩的名字再见天日）</li><li>区分接口继承和实现继承（在 public 继承之下，derived classes 总是继承 base class 的接口；pure virtual 函数只具体指定接口继承；非纯 impure virtual 函数具体指定接口继承及缺省实现继承；non-virtual 函数具体指定接口继承以及强制性实现继承）</li><li>考虑 virtual 函数以外的其他选择（如 Template Method 设计模式的 non-virtual interface（NVI）手法，将 virtual 函数替换为 “函数指针成员变量”，以 <code>tr1::function</code> 成员变量替换 virtual 函数，将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数）</li><li>绝不重新定义继承而来的 non-virtual 函数</li><li>绝不重新定义继承而来的缺省参数值，因为缺省参数值是静态绑定（statically bound），而 virtual 函数却是动态绑定（dynamically bound）</li><li>通过复合塑模 has-a（有一个）或 “根据某物实现出”（在应用域（application domain），复合意味 has-a（有一个）；在实现域（implementation domain），复合意味着 is-implemented-in-terms-of（根据某物实现出））</li><li>明智而审慎地使用 private 继承（private 继承意味着 is-implemented-in-terms-of（根据某物实现出），尽可能使用复合，当 derived class 需要访问 protected base class 的成员，或需要重新定义继承而来的时候 virtual 函数，或需要 empty base 最优化时，才使用 private 继承）</li><li>明智而审慎地使用多重继承（多继承比单一继承复杂，可能导致新的歧义性，以及对 virtual 继承的需要，但确有正当用途，如 “public 继承某个 interface class” 和 “private 继承某个协助实现的 class”；virtual 继承可解决多继承下菱形继承的二义性问题，但会增加大小、速度、初始化及赋值的复杂度等等成本）</li><li>了解隐式接口和编译期多态（class 和 templates 都支持接口（interfaces）和多态（polymorphism）；class 的接口是以签名为中心的显式的（explicit），多态则是通过 virtual 函数发生于运行期；template 的接口是奠基于有效表达式的隐式的（implicit），多态则是通过 template 具现化和函数重载解析（function overloading resolution）发生于编译期）</li><li>了解 typename 的双重意义（声明 template 类型参数是，前缀关键字 class 和 typename 的意义完全相同；请使用关键字 typename 标识嵌套从属类型名称，但不得在基类列（base class lists）或成员初值列（member initialization list）内以它作为 base class 修饰符）</li><li>学习处理模板化基类内的名称（可在 derived class templates 内通过 <code>this-&gt;</code> 指涉 base class templates 内的成员名称，或藉由一个明白写出的 “base class 资格修饰符” 完成）</li><li>将与参数无关的代码抽离 templates（因类型模板参数（non-type template parameters）而造成代码膨胀往往可以通过函数参数或 class 成员变量替换 template 参数来消除；因类型参数（type parameters）而造成的代码膨胀往往可以通过让带有完全相同二进制表述（binary representations）的实现类型（instantiation types）共享实现码）</li><li>运用成员函数模板接受所有兼容类型（请使用成员函数模板（member function templates）生成 “可接受所有兼容类型” 的函数；声明 member templates 用于 “泛化 copy 构造” 或 “泛化 assignment 操作” 时还需要声明正常的 copy 构造函数和 copy assignment 操作符）</li><li>需要类型转换时请为模板定义非成员函数（当我们编写一个 class template，而它所提供之 “与此 template 相关的” 函数支持 “所有参数之隐式类型转换” 时，请将那些函数定义为 “class template 内部的 friend 函数”）</li><li>请使用 traits classes 表现类型信息（traits classes 通过 templates 和 “templates 特化” 使得 “类型相关信息” 在编译期可用，通过重载技术（overloading）实现在编译期对类型执行 if…else 测试）</li><li>认识 template 元编程（模板元编程（TMP，template metaprogramming）可将工作由运行期移往编译期，因此得以实现早期错误侦测和更高的执行效率；TMP 可被用来生成 “给予政策选择组合”（based on combinations of policy choices）的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码）</li><li>了解 new-handler 的行为（set_new_handler 允许客户指定一个在内存分配无法获得满足时被调用的函数；nothrow new 是一个颇具局限的工具，因为它只适用于内存分配（operator new），后继的构造函数调用还是可能抛出异常）</li><li>了解 new 和 delete 的合理替换时机（为了检测运用错误、收集动态分配内存之使用统计信息、增加分配和归还速度、降低缺省内存管理器带来的空间额外开销、弥补缺省分配器中的非最佳齐位、将相关对象成簇集中、获得非传统的行为）</li><li>编写 new 和 delete 时需固守常规（operator new 应该内涵一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就应该调用 new-handler，它也应该有能力处理 0 bytes 申请，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”；operator delete 应该在收到 null 指针时不做任何事，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”）</li><li>写了 placement new 也要写 placement delete（当你写一个 placement operator new，请确定也写出了对应的 placement operator delete，否则可能会发生隐微而时断时续的内存泄漏；当你声明 placement new 和 placement delete，请确定不要无意识（非故意）地遮掩了它们地正常版本）</li><li>不要轻忽编译器的警告</li><li>让自己熟悉包括 TR1 在内的标准程序库（TR1，C++ Technical Report 1，C++11 标准的草稿文件）</li><li>让自己熟悉 Boost（准标准库）</li></ol><h3 id="More-Effective-c"><a href="#More-Effective-c" class="headerlink" title="More Effective c++"></a>More Effective c++</h3><ol><li>仔细区别 pointers 和 references（当你知道你需要指向某个东西，而且绝不会改变指向其他东西，或是当你实现一个操作符而其语法需求无法由 pointers 达成，你就应该选择 references；任何其他时候，请采用 pointers）</li><li>最好使用 C++ 转型操作符（<code>static_cast</code>、<code>const_cast</code>、<code>dynamic_cast</code>、<code>reinterpret_cast</code>）</li><li>绝不要以多态（polymorphically）方式处理数组（多态（polymorphism）和指针算术不能混用；数组对象几乎总是会涉及指针的算术运算，所以数组和多态不要混用）</li><li>非必要不提供 default constructor（避免对象中的字段被无意义地初始化）</li><li>对定制的 “类型转换函数” 保持警觉（单自变量 constructors 可通过简易法（explicit 关键字）或代理类（proxy classes）来避免编译器误用；隐式类型转换操作符可改为显式的 member function 来避免非预期行为）</li><li>区别 increment/decrement 操作符的前置（prefix）和后置（postfix）形式（前置式累加后取出，返回一个 reference；后置式取出后累加，返回一个 const 对象；处理用户定制类型时，应该尽可能使用前置式 increment；后置式的实现应以其前置式兄弟为基础）</li><li>千万不要重载 <code>&amp;&amp;</code>，<code>||</code> 和 <code>,</code> 操作符（<code>&amp;&amp;</code> 与 <code>||</code> 的重载会用 “函数调用语义” 取代 “骤死式语义”；<code>,</code> 的重载导致不能保证左侧表达式一定比右侧表达式更早被评估）</li><li>了解各种不同意义的 new 和 delete（<code>new operator</code>、<code>operator new</code>、<code>placement new</code>、<code>operator new[]</code>；<code>delete operator</code>、<code>operator delete</code>、<code>destructor</code>、<code>operator delete[]</code>）</li><li>利用 destructors 避免泄漏资源（在 destructors 释放资源可以避免异常时的资源泄漏）</li><li>在 constructors 内阻止资源泄漏（由于 C++ 只会析构已构造完成的对象，因此在构造函数可以使用 try…catch 或者 auto_ptr（以及与之相似的 classes） 处理异常时资源泄露问题）</li><li>禁止异常流出 destructors 之外（原因：一、避免 terminate 函数在 exception 传播过程的栈展开（stack-unwinding）机制种被调用；二、协助确保 destructors 完成其应该完成的所有事情）</li><li>了解 “抛出一个 exception” 与 “传递一个参数” 或 “调用一个虚函数” 之间的差异（第一，exception objects 总是会被复制（by pointer 除外），如果以 by value 方式捕捉甚至被复制两次，而传递给函数参数的对象则不一定得复制；第二，“被抛出成为 exceptions” 的对象，其被允许的类型转换动作比 “被传递到函数去” 的对象少；第三，catch 子句以其 “出现于源代码的顺序” 被编译器检验对比，其中第一个匹配成功者便执行，而调用一个虚函数，被选中执行的是那个 “与对象类型最佳吻合” 的函数）</li><li>以 by reference 方式捕获 exceptions（可避免对象删除问题、exception objects 的切割问题，可保留捕捉标准 exceptions 的能力，可约束 exception object 需要复制的次数）</li><li>明智运用 exception specifications（exception specifications 对 “函数希望抛出什么样的 exceptions” 提供了卓越的说明；也有一些缺点，包括编译器只对它们做局部性检验而很容易不经意地违反，与可能会妨碍更上层的 exception 处理函数处理未预期的 exceptions）</li><li>了解异常处理的成本（粗略估计，如果使用 try 语句块，代码大约整体膨胀 5%-10%，执行速度亦大约下降这个数；因此请将你对 try 语句块和 exception specifications 的使用限制于非用不可的地点，并且在真正异常的情况下才抛出 exceptions）</li><li>谨记 80-20 法则（软件的整体性能几乎总是由其构成要素（代码）的一小部分决定的，可使用程序分析器（program profiler）识别出消耗资源的代码）</li><li>考虑使用 lazy evaluation（缓式评估）（可应用于：Reference Counting（引用计数）来避免非必要的对象复制、区分 operator[] 的读和写动作来做不同的事情、Lazy Fetching（缓式取出）来避免非必要的数据库读取动作、Lazy Expression Evaluation（表达式缓评估）来避免非必要的数值计算动作）</li><li>分期摊还预期的计算成本（当你必须支持某些运算而其结构几乎总是被需要，或其结果常常被多次需要的时候，over-eager evaluation（超急评估）可以改善程序效率）</li></ol><h3 id="Google-C-Style-Guide"><a href="#Google-C-Style-Guide" class="headerlink" title="Google C++ Style Guide"></a>Google C++ Style Guide</h3><ul><li>英文：<a href="https://google.github.io/styleguide/cppguide.html" target="_blank" rel="noopener">Google C++ Style Guide</a></li><li>中文：<a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/" target="_blank" rel="noopener">C++ 风格指南</a></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><a href="http://www.stroustrup.com/bs_faq.html" target="_blank" rel="noopener">Bjarne Stroustrup 的常见问题</a></li><li><a href="http://www.stroustrup.com/bs_faq2.html" target="_blank" rel="noopener">Bjarne Stroustrup 的 C++ 风格和技巧常见问题</a></li></ul><h2 id="📦-STL"><a href="#📦-STL" class="headerlink" title="📦 STL"></a>📦 STL</h2><h3 id="STL-索引"><a href="#STL-索引" class="headerlink" title="STL 索引"></a>STL 索引</h3><p><a href="https://github.com/huihut/interview/tree/master/STL" target="_blank" rel="noopener">STL 方法含义索引</a></p><h3 id="STL-容器"><a href="#STL-容器" class="headerlink" title="STL 容器"></a>STL 容器</h3><div class="table-container"><table><thead><tr><th>容器</th><th>底层数据结构</th><th>时间复杂度</th><th>有无序</th><th>可不可重复</th><th>其他</th></tr></thead><tbody><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#array" target="_blank" rel="noopener">array</a></td><td>数组</td><td>随机读改 O(1)</td><td>无序</td><td>可重复</td><td>支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#vector" target="_blank" rel="noopener">vector</a></td><td>数组</td><td>随机读改、尾部插入、尾部删除 O(1)<br/>头部插入、头部删除 O(n)</td><td>无序</td><td>可重复</td><td>支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#deque" target="_blank" rel="noopener">deque</a></td><td>双端队列</td><td>头尾插入、头尾删除 O(1)</td><td>无序</td><td>可重复</td><td>一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#forward_list" target="_blank" rel="noopener">forward_list</a></td><td>单向链表</td><td>插入、删除 O(1)</td><td>无序</td><td>可重复</td><td>不支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#list" target="_blank" rel="noopener">list</a></td><td>双向链表</td><td>插入、删除 O(1)</td><td>无序</td><td>可重复</td><td>不支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#stack" target="_blank" rel="noopener">stack</a></td><td>deque / list</td><td>顶部插入、顶部删除 O(1)</td><td>无序</td><td>可重复</td><td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#queue" target="_blank" rel="noopener">queue</a></td><td>deque / list</td><td>尾部插入、头部删除 O(1)</td><td>无序</td><td>可重复</td><td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#priority_queue" target="_blank" rel="noopener">priority_queue</a></td><td>vector + max-heap</td><td>插入、删除 O(log<sub>2</sub>n)</td><td>有序</td><td>可重复</td><td>vector容器+heap处理规则</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#set" target="_blank" rel="noopener">set</a></td><td>红黑树</td><td>插入、删除、查找 O(log<sub>2</sub>n)</td><td>有序</td><td>不可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#multiset" target="_blank" rel="noopener">multiset</a></td><td>红黑树</td><td>插入、删除、查找 O(log<sub>2</sub>n)</td><td>有序</td><td>可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#map" target="_blank" rel="noopener">map</a></td><td>红黑树</td><td>插入、删除、查找 O(log<sub>2</sub>n)</td><td>有序</td><td>不可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#multimap" target="_blank" rel="noopener">multimap</a></td><td>红黑树</td><td>插入、删除、查找 O(log<sub>2</sub>n)</td><td>有序</td><td>可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_set" target="_blank" rel="noopener">unordered_set</a></td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>不可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_multiset" target="_blank" rel="noopener">unordered_multiset</a></td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_map" target="_blank" rel="noopener">unordered_map</a></td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>不可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_multimap" target="_blank" rel="noopener">unordered_multimap</a></td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>可重复</td><td></td></tr></tbody></table></div><h3 id="STL-算法"><a href="#STL-算法" class="headerlink" title="STL 算法"></a>STL 算法</h3><div class="table-container"><table><thead><tr><th>算法</th><th>底层算法</th><th>时间复杂度</th><th>可不可重复</th></tr></thead><tbody><tr><td><a href="http://www.cplusplus.com/reference/algorithm/find/" target="_blank" rel="noopener">find</a></td><td>顺序查找</td><td>O(n)</td><td>可重复</td></tr><tr><td><a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc++-v3/include/bits/stl_algo.h#L4808" target="_blank" rel="noopener">sort</a></td><td><a href="https://en.wikipedia.org/wiki/Introsort" target="_blank" rel="noopener">内省排序</a></td><td>O(n*log<sub>2</sub>n)</td><td>可重复</td></tr></tbody></table></div><h2 id="〽️-数据结构"><a href="#〽️-数据结构" class="headerlink" title="〽️ 数据结构"></a>〽️ 数据结构</h2><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><h4 id="顺序栈（Sequence-Stack）"><a href="#顺序栈（Sequence-Stack）" class="headerlink" title="顺序栈（Sequence Stack）"></a>顺序栈（Sequence Stack）</h4><p><a href="DataStructure/SqStack.cpp">SqStack.cpp</a></p><p>顺序栈数据结构和图片</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ElemType *elem;</span><br><span class="line"><span class="keyword">int</span> top;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">int</span> increment;</span><br><span class="line">&#125; SqStack;</span><br></pre></td></tr></table></figure><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/SqStack.png" alt=""></p><h4 id="队列（Sequence-Queue）"><a href="#队列（Sequence-Queue）" class="headerlink" title="队列（Sequence Queue）"></a>队列（Sequence Queue）</h4><p>队列数据结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ElemType * elem;</span><br><span class="line"><span class="keyword">int</span> front;</span><br><span class="line"><span class="keyword">int</span> rear;</span><br><span class="line"><span class="keyword">int</span> maxSize;</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><h5 id="非循环队列"><a href="#非循环队列" class="headerlink" title="非循环队列"></a>非循环队列</h5><p>非循环队列图片</p><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/SqQueue.png" alt=""></p><p><code>SqQueue.rear++</code></p><h5 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h5><p>循环队列图片</p><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/SqLoopStack.png" alt=""></p><p><code>SqQueue.rear = (SqQueue.rear + 1) % SqQueue.maxSize</code></p><h4 id="顺序表（Sequence-List）"><a href="#顺序表（Sequence-List）" class="headerlink" title="顺序表（Sequence List）"></a>顺序表（Sequence List）</h4><p><a href="DataStructure/SqList.cpp">SqList.cpp</a></p><p>顺序表数据结构和图片</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ElemType *elem;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">int</span> increment;</span><br><span class="line">&#125; SqList;</span><br></pre></td></tr></table></figure><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/SqList.png" alt=""></p><h3 id="链式结构"><a href="#链式结构" class="headerlink" title="链式结构"></a>链式结构</h3><p><a href="DataStructure/LinkList.cpp">LinkList.cpp</a></p><p><a href="DataStructure/LinkList_with_head.cpp">LinkList_with_head.cpp</a></p><p>链式数据结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br></pre></td></tr></table></figure><h4 id="链队列（Link-Queue）"><a href="#链队列（Link-Queue）" class="headerlink" title="链队列（Link Queue）"></a>链队列（Link Queue）</h4><p>链队列图片</p><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/LinkQueue.png" alt=""></p><h4 id="线性表的链式表示"><a href="#线性表的链式表示" class="headerlink" title="线性表的链式表示"></a>线性表的链式表示</h4><h5 id="单链表（Link-List）"><a href="#单链表（Link-List）" class="headerlink" title="单链表（Link List）"></a>单链表（Link List）</h5><p>单链表图片</p><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/LinkList.png" alt=""></p><h5 id="双向链表（Du-Link-List）"><a href="#双向链表（Du-Link-List）" class="headerlink" title="双向链表（Du-Link-List）"></a>双向链表（Du-Link-List）</h5><p>双向链表图片</p><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/DuLinkList.png" alt=""></p><h5 id="循环链表（Cir-Link-List）"><a href="#循环链表（Cir-Link-List）" class="headerlink" title="循环链表（Cir-Link-List）"></a>循环链表（Cir-Link-List）</h5><p>循环链表图片</p><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/CirLinkList.png" alt=""></p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p><a href="DataStructure/HashTable.cpp">HashTable.cpp</a></p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>哈希函数：<code>H(key): K -&gt; D , key ∈ K</code></p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li>直接定址法</li><li>除留余数法</li><li>数字分析法</li><li>折叠法</li><li>平方取中法</li></ul><h4 id="冲突处理方法"><a href="#冲突处理方法" class="headerlink" title="冲突处理方法"></a>冲突处理方法</h4><ul><li>链地址法：key 相同的用单链表链接</li><li>开放定址法<ul><li>线性探测法：key 相同 -&gt; 放到 key 的下一个位置，<code>Hi = (H(key) + i) % m</code></li><li>二次探测法：key 相同 -&gt; 放到 <code>Di = 1^2, -1^2, ..., ±（k)^2,(k&lt;=m/2）</code></li><li>随机探测法：<code>H = (H(key) + 伪随机数) % m</code></li></ul></li></ul><h4 id="线性探测的哈希表数据结构"><a href="#线性探测的哈希表数据结构" class="headerlink" title="线性探测的哈希表数据结构"></a>线性探测的哈希表数据结构</h4><p>线性探测的哈希表数据结构和图片</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> KeyType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">KeyType key;</span><br><span class="line">&#125;RcdType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">RcdType *rcd;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">bool</span> *tag;</span><br><span class="line">&#125;HashTable;</span><br></pre></td></tr></table></figure><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/HashTable.png" alt=""></p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>函数直接或间接地调用自身</p><h4 id="递归与分治"><a href="#递归与分治" class="headerlink" title="递归与分治"></a>递归与分治</h4><ul><li>分治法<ul><li>问题的分解</li><li>问题规模的分解</li></ul></li><li>折半查找（递归）</li><li>归并排序（递归）</li><li>快速排序（递归）</li></ul><h4 id="递归与迭代"><a href="#递归与迭代" class="headerlink" title="递归与迭代"></a>递归与迭代</h4><ul><li>迭代：反复利用变量旧值推出新值</li><li>折半查找（迭代）</li><li>归并排序（迭代）</li></ul><h4 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h4><h5 id="头尾链表存储表示"><a href="#头尾链表存储表示" class="headerlink" title="头尾链表存储表示"></a>头尾链表存储表示</h5><p>广义表的头尾链表存储表示和图片</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 广义表的头尾链表存储表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;ATOM, LIST&#125; ElemTag;</span><br><span class="line"><span class="comment">// ATOM==0：原子，LIST==1：子表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> &#123;</span></span><br><span class="line">    ElemTag tag;</span><br><span class="line">    <span class="comment">// 公共部分，用于区分原子结点和表结点</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="comment">// 原子结点和表结点的联合部分</span></span><br><span class="line">        AtomType atom;</span><br><span class="line">        <span class="comment">// atom 是原子结点的值域，AtomType 由用户定义</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> *<span class="title">hp</span>, *<span class="title">tp</span>;</span></span><br><span class="line">        &#125; ptr;</span><br><span class="line">        <span class="comment">// ptr 是表结点的指针域，prt.hp 和 ptr.tp 分别指向表头和表尾</span></span><br><span class="line">    &#125; a;</span><br><span class="line">&#125; *GList, GLNode;</span><br></pre></td></tr></table></figure><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/GeneralizedList1.png" alt=""></p><h5 id="扩展线性链表存储表示"><a href="#扩展线性链表存储表示" class="headerlink" title="扩展线性链表存储表示"></a>扩展线性链表存储表示</h5><p>扩展线性链表存储表示和图片</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 广义表的扩展线性链表存储表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;ATOM, LIST&#125; ElemTag;</span><br><span class="line"><span class="comment">// ATOM==0：原子，LIST==1：子表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GLNode1</span> &#123;</span></span><br><span class="line">    ElemTag tag;</span><br><span class="line">    <span class="comment">// 公共部分，用于区分原子结点和表结点</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="comment">// 原子结点和表结点的联合部分</span></span><br><span class="line">        AtomType atom; <span class="comment">// 原子结点的值域</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">GLNode1</span> *<span class="title">hp</span>;</span> <span class="comment">// 表结点的表头指针</span></span><br><span class="line">    &#125; a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">GLNode1</span> *<span class="title">tp</span>;</span></span><br><span class="line">    <span class="comment">// 相当于线性链表的 next，指向下一个元素结点</span></span><br><span class="line">&#125; *GList1, GLNode1;</span><br></pre></td></tr></table></figure><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/GeneralizedList2.png" alt=""></p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p><a href="DataStructure/BinaryTree.cpp">BinaryTree.cpp</a></p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol><li>非空二叉树第 i 层最多 2<sup>(i-1)</sup> 个结点 （i &gt;= 1）</li><li>深度为 k 的二叉树最多 2<sup>k</sup> - 1 个结点 （k &gt;= 1）</li><li>度为 0 的结点数为 n<sub>0</sub>，度为 2 的结点数为 n<sub>2</sub>，则 n<sub>0</sub> = n<sub>2</sub> + 1</li><li>有 n 个结点的完全二叉树深度 k = ⌊ log<sub>2</sub>(n) ⌋ + 1 </li><li>对于含 n 个结点的完全二叉树中编号为 i （1 &lt;= i &lt;= n） 的结点<ol><li>若 i = 1，为根，否则双亲为 ⌊ i / 2 ⌋</li><li>若 2i &gt; n，则 i 结点没有左孩子，否则孩子编号为 2i</li><li>若 2i + 1 &gt; n，则 i 结点没有右孩子，否则孩子编号为 2i + 1</li></ol></li></ol><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>二叉树数据结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure><h5 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h5><p>二叉树顺序存储图片</p><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/SqBinaryTree.png" alt=""></p><h5 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h5><p>二叉树链式存储图片</p><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/LinkBinaryTree.png" alt=""></p><h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4><ul><li>先序遍历</li><li>中序遍历</li><li>后续遍历</li><li>层次遍历</li></ul><h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><ul><li>满二叉树</li><li>完全二叉树（堆）<ul><li>大顶堆：根 &gt;= 左 &amp;&amp; 根 &gt;= 右</li><li>小顶堆：根 &lt;= 左 &amp;&amp; 根 &lt;= 右</li></ul></li><li>二叉查找树（二叉排序树）：左 &lt; 根 &lt; 右</li><li>平衡二叉树（AVL树）：| 左子树树高 - 右子树树高 | &lt;= 1</li><li>最小失衡树：平衡二叉树插入新结点导致失衡的子树：调整：<ul><li>LL型：根的左孩子右旋</li><li>RR型：根的右孩子左旋</li><li>LR型：根的左孩子左旋，再右旋</li><li>RL型：右孩子的左子树，先右旋，再左旋</li></ul></li></ul><h3 id="其他树及森林"><a href="#其他树及森林" class="headerlink" title="其他树及森林"></a>其他树及森林</h3><h4 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h4><ul><li>双亲表示法</li><li>双亲孩子表示法</li><li>孩子兄弟表示法</li></ul><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><p>一种不相交的子集所构成的集合 S = {S1, S2, …, Sn}</p><h4 id="平衡二叉树（AVL树）"><a href="#平衡二叉树（AVL树）" class="headerlink" title="平衡二叉树（AVL树）"></a>平衡二叉树（AVL树）</h4><h5 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h5><ul><li>| 左子树树高 - 右子树树高 | &lt;= 1</li><li>平衡二叉树必定是二叉搜索树，反之则不一定</li><li>最小二叉平衡树的节点的公式：<code>F(n)=F(n-1)+F(n-2)+1</code> （1 是根节点，F(n-1) 是左子树的节点数量，F(n-2) 是右子树的节点数量）</li></ul><p>平衡二叉树图片</p><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/Self-balancingBinarySearchTree.png" alt=""></p><h5 id="最小失衡树"><a href="#最小失衡树" class="headerlink" title="最小失衡树"></a>最小失衡树</h5><p>平衡二叉树插入新结点导致失衡的子树</p><p>调整：</p><ul><li>LL 型：根的左孩子右旋</li><li>RR 型：根的右孩子左旋</li><li>LR 型：根的左孩子左旋，再右旋</li><li>RL 型：右孩子的左子树，先右旋，再左旋</li></ul><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p><a href="DataStructure/RedBlackTree.cpp">RedBlackTree.cpp</a></p><h5 id="红黑树的特征是什么？"><a href="#红黑树的特征是什么？" class="headerlink" title="红黑树的特征是什么？"></a>红黑树的特征是什么？</h5><ol><li>节点是红色或黑色。</li><li>根是黑色。</li><li>所有叶子都是黑色（叶子是 NIL 节点）。</li><li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）（新增节点的父节点必须相同）</li><li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。（新增节点必须为红）</li></ol><h5 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h5><ol><li>变色</li><li>左旋</li><li>右旋</li></ol><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><ul><li>关联数组：如 STL 中的 map、set</li></ul><h5 id="红黑树、B-树、B-树的区别？"><a href="#红黑树、B-树、B-树的区别？" class="headerlink" title="红黑树、B 树、B+ 树的区别？"></a>红黑树、B 树、B+ 树的区别？</h5><ul><li>红黑树的深度比较大，而 B 树和 B+ 树的深度则相对要小一些</li><li>B+ 树则将数据都保存在叶子节点，同时通过链表的形式将他们连接在一起。</li></ul><h4 id="B-树（B-tree）、B-树（B-tree）"><a href="#B-树（B-tree）、B-树（B-tree）" class="headerlink" title="B 树（B-tree）、B+ 树（B+-tree）"></a>B 树（B-tree）、B+ 树（B+-tree）</h4><p>B 树、B+ 树图片</p><p><img src="https://i.stack.imgur.com/l6UyF.png" alt="B 树（B-tree）、B+ 树（B+-tree）"></p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>一般化的二叉查找树（binary search tree）</li><li>“矮胖”，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好）</li></ul><h5 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h5><ul><li>大部分文件系统、数据库系统都采用B树、B+树作为索引结构</li></ul><h5 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h5><ul><li>B+树中只有叶子节点会带有指向记录的指针（ROWID），而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。</li><li>B+树中所有叶子节点都是通过指针连接在一起，而B树不会。</li></ul><h5 id="B树的优点"><a href="#B树的优点" class="headerlink" title="B树的优点"></a>B树的优点</h5><p>对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。</p><h5 id="B-树的优点"><a href="#B-树的优点" class="headerlink" title="B+树的优点"></a>B+树的优点</h5><ul><li>非叶子节点不会带上 ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。</li><li>叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。</li></ul><blockquote><p>B 树、B+ 树区别来自：<a href="https://stackoverflow.com/questions/870218/differences-between-b-trees-and-b-trees" target="_blank" rel="noopener">differences-between-b-trees-and-b-trees</a>、<a href="https://www.cnblogs.com/ivictor/p/5849061.html" target="_blank" rel="noopener">B树和B+树的区别</a></p></blockquote><h4 id="八叉树"><a href="#八叉树" class="headerlink" title="八叉树"></a>八叉树</h4><p>八叉树图片</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/Octree2.png/400px-Octree2.png" alt=""></p><p>八叉树（octree），或称八元树，是一种用于描述三维空间（划分空间）的树状数据结构。八叉树的每个节点表示一个正方体的体积元素，每个节点有八个子节点，这八个子节点所表示的体积元素加在一起就等于父节点的体积。一般中心点作为节点的分叉中心。</p><h5 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h5><ul><li>三维计算机图形</li><li>最邻近搜索</li></ul><h2 id="⚡️-算法"><a href="#⚡️-算法" class="headerlink" title="⚡️ 算法"></a>⚡️ 算法</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><div class="table-container"><table><thead><tr><th>排序算法</th><th>平均时间复杂度</th><th>最差时间复杂度</th><th>空间复杂度</th><th>数据对象稳定性</th></tr></thead><tbody><tr><td><a href="Algorithm/BubbleSort.h">冒泡排序</a></td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>O(1)</td><td>稳定</td></tr><tr><td><a href="Algorithm/SelectionSort.h">选择排序</a></td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>O(1)</td><td>数组不稳定、链表稳定</td></tr><tr><td><a href="Algorithm/InsertSort.h">插入排序</a></td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>O(1)</td><td>稳定</td></tr><tr><td><a href="Algorithm/QuickSort.h">快速排序</a></td><td>O(n*log<sub>2</sub>n)</td><td>O(n<sup>2</sup>)</td><td>O(log<sub>2</sub>n)</td><td>不稳定</td></tr><tr><td><a href="Algorithm/HeapSort.cpp">堆排序</a></td><td>O(n*log<sub>2</sub>n)</td><td>O(n*log<sub>2</sub>n)</td><td>O(1)</td><td>不稳定</td></tr><tr><td><a href="Algorithm/MergeSort.h">归并排序</a></td><td>O(n*log<sub>2</sub>n)</td><td>O(n*log<sub>2</sub>n)</td><td>O(n)</td><td>稳定</td></tr><tr><td><a href="Algorithm/ShellSort.h">希尔排序</a></td><td>O(n*log<sup>2</sup>n)</td><td>O(n<sup>2</sup>)</td><td>O(1)</td><td>不稳定</td></tr><tr><td><a href="Algorithm/CountSort.cpp">计数排序</a></td><td>O(n+m)</td><td>O(n+m)</td><td>O(n+m)</td><td>稳定</td></tr><tr><td><a href="Algorithm/BucketSort.cpp">桶排序</a></td><td>O(n)</td><td>O(n)</td><td>O(m)</td><td>稳定</td></tr><tr><td><a href="Algorithm/RadixSort.h">基数排序</a></td><td>O(k*n)</td><td>O(n<sup>2</sup>)</td><td></td><td>稳定</td></tr></tbody></table></div><blockquote><ul><li>均按从小到大排列</li><li>k：代表数值中的 “数位” 个数</li><li>n：代表数据规模</li><li>m：代表数据的最大值减最小值</li><li>来自：<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">wikipedia . 排序算法</a></li></ul></blockquote><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><div class="table-container"><table><thead><tr><th>查找算法</th><th>平均时间复杂度</th><th>空间复杂度</th><th>查找条件</th></tr></thead><tbody><tr><td><a href="Algorithm/SequentialSearch.h">顺序查找</a></td><td>O(n)</td><td>O(1)</td><td>无序或有序</td></tr><tr><td><a href="Algorithm/BinarySearch.h">二分查找（折半查找）</a></td><td>O(log<sub>2</sub>n)</td><td>O(1)</td><td>有序</td></tr><tr><td><a href="Algorithm/InsertionSearch.h">插值查找</a></td><td>O(log<sub>2</sub>(log<sub>2</sub>n))</td><td>O(1)</td><td>有序</td></tr><tr><td><a href="Algorithm/FibonacciSearch.cpp">斐波那契查找</a></td><td>O(log<sub>2</sub>n)</td><td>O(1)</td><td>有序</td></tr><tr><td><a href="DataStructure/HashTable.cpp">哈希查找</a></td><td>O(1)</td><td>O(n)</td><td>无序或有序</td></tr><tr><td><a href="Algorithm/BSTSearch.h">二叉查找树（二叉搜索树查找）</a></td><td>O(log<sub>2</sub>n)</td><td></td><td></td></tr><tr><td><a href="DataStructure/RedBlackTree.cpp">红黑树</a></td><td>O(log<sub>2</sub>n)</td><td></td><td></td></tr><tr><td>2-3树</td><td>O(log<sub>2</sub>n - log<sub>3</sub>n)</td><td></td><td></td></tr><tr><td>B树/B+树</td><td>O(log<sub>2</sub>n)</td><td></td><td></td></tr></tbody></table></div><h3 id="图搜索算法"><a href="#图搜索算法" class="headerlink" title="图搜索算法"></a>图搜索算法</h3><div class="table-container"><table><thead><tr><th>图搜索算法</th><th>数据结构</th><th>遍历时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td><a href="https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2" target="_blank" rel="noopener">BFS广度优先搜索</a></td><td>邻接矩阵<br/>邻接链表</td><td>O(\</td><td>v\</td><td><sup>2</sup>)<br/>O(\</td><td>v\</td><td>+\</td><td>E\</td><td>)</td><td>O(\</td><td>v\</td><td><sup>2</sup>)<br/>O(\</td><td>v\</td><td>+\</td><td>E\</td><td>)</td></tr><tr><td><a href="https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2" target="_blank" rel="noopener">DFS深度优先搜索</a></td><td>邻接矩阵<br/>邻接链表</td><td>O(\</td><td>v\</td><td><sup>2</sup>)<br/>O(\</td><td>v\</td><td>+\</td><td>E\</td><td>)</td><td>O(\</td><td>v\</td><td><sup>2</sup>)<br/>O(\</td><td>v\</td><td>+\</td><td>E\</td><td>)</td></tr></tbody></table></div><h3 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h3><div class="table-container"><table><thead><tr><th>算法</th><th>思想</th><th>应用</th></tr></thead><tbody><tr><td><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95" target="_blank" rel="noopener">分治法</a></td><td>把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并</td><td><a href="https://github.com/huihut/interview/tree/master/Problems/RoundRobinProblem" target="_blank" rel="noopener">循环赛日程安排问题</a>、排序算法（快速排序、归并排序）</td></tr><tr><td><a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" target="_blank" rel="noopener">动态规划</a></td><td>通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，适用于有重叠子问题和最优子结构性质的问题</td><td><a href="https://github.com/huihut/interview/tree/master/Problems/KnapsackProblem" target="_blank" rel="noopener">背包问题</a>、斐波那契数列</td></tr><tr><td><a href="https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E6%B3%95" target="_blank" rel="noopener">贪心法</a></td><td>一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法</td><td>旅行推销员问题（最短路径问题）、最小生成树、哈夫曼编码</td></tr></tbody></table></div><h2 id="❓-Problems"><a href="#❓-Problems" class="headerlink" title="❓ Problems"></a>❓ Problems</h2><h3 id="Single-Problem"><a href="#Single-Problem" class="headerlink" title="Single Problem"></a>Single Problem</h3><ul><li><a href="Problems/ChessboardCoverageProblem">Chessboard Coverage Problem（棋盘覆盖问题）</a></li><li><a href="Problems/KnapsackProblem">Knapsack Problem（背包问题）</a></li><li><a href="Problems/NeumannNeighborProblem">Neumann Neighbor Problem（冯诺依曼邻居问题）</a></li><li><a href="Problems/RoundRobinProblem">Round Robin Problem（循环赛日程安排问题）</a></li><li><a href="Problems/TubingProblem">Tubing Problem（输油管道问题）</a></li></ul><h3 id="Leetcode-Problems"><a href="#Leetcode-Problems" class="headerlink" title="Leetcode Problems"></a>Leetcode Problems</h3><ul><li><a href="https://github.com/haoel/leetcode" target="_blank" rel="noopener">Github . haoel/leetcode</a></li><li><a href="https://github.com/pezy/LeetCode" target="_blank" rel="noopener">Github . pezy/LeetCode</a></li></ul><h3 id="剑指-Offer"><a href="#剑指-Offer" class="headerlink" title="剑指 Offer"></a>剑指 Offer</h3><ul><li><a href="https://github.com/zhedahht/CodingInterviewChinese2" target="_blank" rel="noopener">Github . zhedahht/CodingInterviewChinese2</a></li><li><a href="https://github.com/gatieme/CodingInterviews" target="_blank" rel="noopener">Github . gatieme/CodingInterviews</a></li></ul><h3 id="Cracking-the-Coding-Interview-程序员面试金典"><a href="#Cracking-the-Coding-Interview-程序员面试金典" class="headerlink" title="Cracking the Coding Interview 程序员面试金典"></a>Cracking the Coding Interview 程序员面试金典</h3><ul><li><a href="https://github.com/careercup/ctci" target="_blank" rel="noopener">Github . careercup/ctci</a></li><li><a href="https://www.nowcoder.com/ta/cracking-the-coding-interview" target="_blank" rel="noopener">牛客网 . 程序员面试金典</a></li></ul><h3 id="牛客网"><a href="#牛客网" class="headerlink" title="牛客网"></a>牛客网</h3><ul><li><a href="https://www.nowcoder.com/activity/oj" target="_blank" rel="noopener">牛客网 . 在线编程专题</a></li></ul><p><a id="os"></a></p><h2 id="💻-操作系统"><a href="#💻-操作系统" class="headerlink" title="💻 操作系统"></a>💻 操作系统</h2><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>对于有线程系统：</p><ul><li>进程是资源分配的独立单位</li><li>线程是资源调度的独立单位</li></ul><p>对于无线程系统：</p><ul><li>进程是资源调度、分配的独立单位</li></ul><h4 id="进程之间的通信方式以及优缺点"><a href="#进程之间的通信方式以及优缺点" class="headerlink" title="进程之间的通信方式以及优缺点"></a>进程之间的通信方式以及优缺点</h4><ul><li>管道（PIPE）<ul><li>有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信<ul><li>优点：可以实现任意关系的进程间的通信</li><li>缺点：<ol><li>长期存于系统中，使用不当容易出错</li><li>缓冲区有限</li></ol></li></ul></li><li>无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）<ul><li>优点：简单方便</li><li>缺点：<ol><li>局限于单向通信 </li><li>只能创建在它的进程以及其有亲缘关系的进程之间</li><li>缓冲区有限</li></ol></li></ul></li></ul></li><li>信号量（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问<ul><li>优点：可以同步进程</li><li>缺点：信号量有限</li></ul></li><li>信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</li><li>消息队列（Message Queue）：是消息的链表，存放在内核中并由消息队列标识符标识<ul><li>优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便</li><li>缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合</li></ul></li><li>共享内存（Shared Memory）：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问<ul><li>优点：无须复制，快捷，信息量大</li><li>缺点：<ol><li>通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题</li><li>利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信</li></ol></li></ul></li><li>套接字（Socket）：可用于不同计算机间的进程通信<ul><li>优点：<ol><li>传输数据为字节级，传输数据可自定义，数据量小效率高</li><li>传输数据时间短，性能高</li><li>适合于客户端和服务器端之间信息实时交互</li><li>可以加密,数据安全性强</li></ol></li><li>缺点：需对传输的数据进行解析，转化成应用级的数据。</li></ul></li></ul><h4 id="线程之间的通信方式"><a href="#线程之间的通信方式" class="headerlink" title="线程之间的通信方式"></a>线程之间的通信方式</h4><ul><li>锁机制：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）<ul><li>互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。</li><li>读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。</li><li>自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。</li><li>条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li></ul></li><li>信号量机制(Semaphore)<ul><li>无名线程信号量</li><li>命名线程信号量</li></ul></li><li>信号机制(Signal)：类似进程间的信号处理</li><li>屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。</li></ul><p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制  </p><blockquote><p>进程之间的通信方式以及优缺点来源于：<a href="http://blog.csdn.net/wujiafei_njgcxy/article/details/77098977" target="_blank" rel="noopener">进程线程面试题总结</a></p></blockquote><h4 id="进程之间私有和共享的资源"><a href="#进程之间私有和共享的资源" class="headerlink" title="进程之间私有和共享的资源"></a>进程之间私有和共享的资源</h4><ul><li>私有：地址空间、堆、全局变量、栈、寄存器</li><li>共享：代码段，公共数据，进程目录，进程 ID</li></ul><h4 id="线程之间私有和共享的资源"><a href="#线程之间私有和共享的资源" class="headerlink" title="线程之间私有和共享的资源"></a>线程之间私有和共享的资源</h4><ul><li>私有：线程栈，寄存器，程序计数器</li><li>共享：堆，地址空间，全局变量，静态变量</li></ul><h4 id="多进程与多线程间的对比、优劣与选择"><a href="#多进程与多线程间的对比、优劣与选择" class="headerlink" title="多进程与多线程间的对比、优劣与选择"></a>多进程与多线程间的对比、优劣与选择</h4><h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><div class="table-container"><table><thead><tr><th>对比维度</th><th>多进程</th><th>多线程</th><th>总结</th></tr></thead><tbody><tr><td>数据共享、同步</td><td>数据共享复杂，需要用 IPC；数据是分开的，同步简单</td><td>因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂</td><td>各有优势</td></tr><tr><td>内存、CPU</td><td>占用内存多，切换复杂，CPU 利用率低</td><td>占用内存少，切换简单，CPU 利用率高</td><td>线程占优</td></tr><tr><td>创建销毁、切换</td><td>创建销毁、切换复杂，速度慢</td><td>创建销毁、切换简单，速度很快</td><td>线程占优</td></tr><tr><td>编程、调试</td><td>编程简单，调试简单</td><td>编程复杂，调试复杂</td><td>进程占优</td></tr><tr><td>可靠性</td><td>进程间不会互相影响</td><td>一个线程挂掉将导致整个进程挂掉</td><td>进程占优</td></tr><tr><td>分布式</td><td>适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单</td><td>适应于多核分布式</td><td>进程占优</td></tr></tbody></table></div><h5 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h5><div class="table-container"><table><thead><tr><th>优劣</th><th>多进程</th><th>多线程</th></tr></thead><tbody><tr><td>优点</td><td>编程、调试简单，可靠性较高</td><td>创建、销毁、切换速度快，内存、资源占用小</td></tr><tr><td>缺点</td><td>创建、销毁、切换速度慢，内存、资源占用大</td><td>编程、调试复杂，可靠性较差</td></tr></tbody></table></div><h5 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h5><ul><li>需要频繁创建销毁的优先用线程</li><li>需要进行大量计算的优先使用线程</li><li>强相关的处理用线程，弱相关的处理用进程</li><li>可能要扩展到多机分布的用进程，多核分布的用线程</li><li>都满足需求的情况下，用你最熟悉、最拿手的方式</li></ul><blockquote><p>多进程与多线程间的对比、优劣与选择来自：<a href="https://blog.csdn.net/lishenglong666/article/details/8557215" target="_blank" rel="noopener">多线程还是多进程的选择及区别</a></p></blockquote><h3 id="Linux-内核的同步方式"><a href="#Linux-内核的同步方式" class="headerlink" title="Linux 内核的同步方式"></a>Linux 内核的同步方式</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>在现代操作系统里，同一时间可能有多个内核执行流在执行，因此内核其实像多进程多线程编程一样也需要一些同步机制来同步各执行单元对共享数据的访问。尤其是在多处理器系统上，更需要一些同步机制来同步不同处理器上的执行单元对共享的数据的访问。</p><h4 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h4><ul><li>原子操作</li><li>信号量（semaphore）</li><li>读写信号量（rw_semaphore）</li><li>自旋锁（spinlock）</li><li>大内核锁（BKL，Big Kernel Lock）</li><li>读写锁（rwlock）</li><li>大读者锁（brlock-Big Reader Lock）</li><li>读-拷贝修改(RCU，Read-Copy Update)</li><li>顺序锁（seqlock）</li></ul><blockquote><p>来自：<a href="https://www.ibm.com/developerworks/cn/linux/l-synch/part1/" target="_blank" rel="noopener">Linux 内核的同步机制，第 1 部分</a>、<a href="https://www.ibm.com/developerworks/cn/linux/l-synch/part2/" target="_blank" rel="noopener">Linux 内核的同步机制，第 2 部分</a></p></blockquote><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h4><ul><li>系统资源不足</li><li>资源分配不当</li><li>进程运行推进顺序不合适</li></ul><h4 id="产生条件"><a href="#产生条件" class="headerlink" title="产生条件"></a>产生条件</h4><ul><li>互斥</li><li>请求和保持</li><li>不剥夺</li><li>环路</li></ul><h4 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h4><ul><li>打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。</li><li>打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。</li><li>打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。</li><li>打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。</li><li>有序资源分配法</li><li>银行家算法</li></ul><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><ul><li>Windows：FCB 表 + FAT + 位图</li><li>Unix：inode + 混合索引 + 成组链接</li></ul><h3 id="主机字节序与网络字节序"><a href="#主机字节序与网络字节序" class="headerlink" title="主机字节序与网络字节序"></a>主机字节序与网络字节序</h3><h4 id="主机字节序（CPU-字节序）"><a href="#主机字节序（CPU-字节序）" class="headerlink" title="主机字节序（CPU 字节序）"></a>主机字节序（CPU 字节序）</h4><h5 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h5><p>主机字节序又叫 CPU 字节序，其不是由操作系统决定的，而是由 CPU 指令集架构决定的。主机字节序分为两种：</p><ul><li>大端字节序（Big Endian）：高序字节存储在低位地址，低序字节存储在高位地址</li><li>小端字节序（Little Endian）：高序字节存储在高位地址，低序字节存储在低位地址</li></ul><h5 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h5><p>32 位整数 <code>0x12345678</code> 是从起始位置为 <code>0x00</code> 的地址开始存放，则：</p><div class="table-container"><table><thead><tr><th>内存地址</th><th>0x00</th><th>0x01</th><th>0x02</th><th>0x03</th></tr></thead><tbody><tr><td>大端</td><td>12</td><td>34</td><td>56</td><td>78</td></tr><tr><td>小端</td><td>78</td><td>56</td><td>34</td><td>12</td></tr></tbody></table></div><p>大端小端图片</p><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/CPU-Big-Endian.svg.png" alt="大端序"><br><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/CPU-Little-Endian.svg.png" alt="小端序"></p><h5 id="判断大端小端"><a href="#判断大端小端" class="headerlink" title="判断大端小端"></a>判断大端小端</h5><p>判断大端小端</p><p>可以这样判断自己 CPU 字节序是大端还是小端：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0x12345678</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*((<span class="keyword">char</span>*)&amp;i) == <span class="number">0x12</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"大端"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"小端"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="各架构处理器的字节序"><a href="#各架构处理器的字节序" class="headerlink" title="各架构处理器的字节序"></a>各架构处理器的字节序</h5><ul><li>x86（Intel、AMD）、MOS Technology 6502、Z80、VAX、PDP-11 等处理器为小端序；</li><li>Motorola 6800、Motorola 68000、PowerPC 970、System/370、SPARC（除 V9 外）等处理器为大端序；</li><li>ARM（默认小端序）、PowerPC（除 PowerPC 970 外）、DEC Alpha、SPARC V9、MIPS、PA-RISC 及 IA64 的字节序是可配置的。</li></ul><h4 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h4><p>网络字节顺序是 TCP/IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。</p><p>网络字节顺序采用：大端（Big Endian）排列方式。</p><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。</p><h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><ul><li>全局置换：在整个内存空间置换</li><li>局部置换：在本进程中进行置换</li></ul><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>全局：</p><ul><li>工作集算法</li><li>缺页率置换算法</li></ul><p>局部：</p><ul><li>最佳置换算法（OPT）</li><li>先进先出置换算法（FIFO）</li><li>最近最久未使用（LRU）算法</li><li>时钟（Clock）置换算法</li></ul><h2 id="☁️-计算机网络"><a href="#☁️-计算机网络" class="headerlink" title="☁️ 计算机网络"></a>☁️ 计算机网络</h2><blockquote><p>本节部分知识点来自《计算机网络（第 7 版）》</p></blockquote><p>计算机网络体系结构：</p><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/计算机网络体系结构.png" alt="计算机网络体系结构"></p><h3 id="各层作用及协议"><a href="#各层作用及协议" class="headerlink" title="各层作用及协议"></a>各层作用及协议</h3><div class="table-container"><table><thead><tr><th>分层</th><th>作用</th><th>协议</th></tr></thead><tbody><tr><td>物理层</td><td>通过媒介传输比特，确定机械及电气规范（比特 Bit）</td><td>RJ45、CLOCK、IEEE802.3（中继器，集线器）</td></tr><tr><td>数据链路层</td><td>将比特组装成帧和点到点的传递（帧 Frame）</td><td>PPP、FR、HDLC、VLAN、MAC（网桥，交换机）</td></tr><tr><td>网络层</td><td>负责数据包从源到宿的传递和网际互连（包 Packet）</td><td>IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器）</td></tr><tr><td>运输层</td><td>提供端到端的可靠报文传递和错误恢复（ 段Segment）</td><td>TCP、UDP、SPX</td></tr><tr><td>会话层</td><td>建立、管理和终止会话（会话协议数据单元 SPDU）</td><td>NFS、SQL、NETBIOS、RPC</td></tr><tr><td>表示层</td><td>对数据进行翻译、加密和压缩（表示协议数据单元 PPDU）</td><td>JPEG、MPEG、ASII</td></tr><tr><td>应用层</td><td>允许访问OSI环境的手段（应用协议数据单元 APDU）</td><td>FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</td></tr></tbody></table></div><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><ul><li>传输数据的单位：比特</li><li>数据传输系统：源系统（源点、发送器） —&gt; 传输系统 —&gt; 目的系统（接收器、终点）</li></ul><p>通道：</p><ul><li>单向通道（单工通道）：只有一个方向通信，没有反方向交互，如广播</li><li>双向交替通信（半双工通信）：通信双方都可发消息，但不能同时发送或接收</li><li>双向同时通信（全双工通信）：通信双方可以同时发送和接收信息</li></ul><p>通道复用技术：</p><ul><li>频分复用（FDM，Frequency Division Multiplexing）：不同用户在不同频带，所用用户在同样时间占用不同带宽资源</li><li>时分复用（TDM，Time Division Multiplexing）：不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度</li><li>波分复用（WDM，Wavelength Division Multiplexing）：光的频分复用</li><li>码分复用（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带通信</li></ul><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>主要信道：</p><ul><li>点对点信道</li><li>广播信道</li></ul><h4 id="点对点信道"><a href="#点对点信道" class="headerlink" title="点对点信道"></a>点对点信道</h4><ul><li>数据单元：帧</li></ul><p>三个基本问题：</p><ul><li>封装成帧：把网络层的 IP 数据报封装成帧，<code>SOH - 数据部分 - EOT</code></li><li>透明传输：不管数据部分什么字符，都能传输出去；可以通过字节填充方法解决（冲突字符前加转义字符）</li><li>差错检测：降低误码率（BER，Bit Error Rate），广泛使用循环冗余检测（CRC，Cyclic Redundancy Check）</li></ul><p>点对点协议（Point-to-Point Protocol）：</p><ul><li>点对点协议（Point-to-Point Protocol）：用户计算机和 ISP 通信时所使用的协议</li></ul><h4 id="广播信道"><a href="#广播信道" class="headerlink" title="广播信道"></a>广播信道</h4><p>广播通信：</p><ul><li>硬件地址（物理地址、MAC 地址）</li><li>单播（unicast）帧（一对一）：收到的帧的 MAC 地址与本站的硬件地址相同</li><li>广播（broadcast）帧（一对全体）：发送给本局域网上所有站点的帧</li><li>多播（multicast）帧（一对多）：发送给本局域网上一部分站点的帧</li></ul><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><ul><li>IP（Internet Protocol，网际协议）是为计算机网络相互连接进行通信而设计的协议。</li><li>ARP（Address Resolution Protocol，地址解析协议）</li><li>ICMP（Internet Control Message Protocol，网际控制报文协议）</li><li>IGMP（Internet Group Management Protocol，网际组管理协议）</li></ul><h4 id="IP-网际协议"><a href="#IP-网际协议" class="headerlink" title="IP 网际协议"></a>IP 网际协议</h4><p>IP 地址分类：</p><ul><li><code>IP 地址 ::= {&lt;网络号&gt;,&lt;主机号&gt;}</code></li></ul><div class="table-container"><table><thead><tr><th>IP 地址类别</th><th>网络号</th><th>网络范围</th><th>主机号</th><th>IP 地址范围</th></tr></thead><tbody><tr><td>A 类</td><td>8bit，第一位固定为 0</td><td>0 —— 127</td><td>24bit</td><td>1.0.0.0 —— 127.255.255.255</td></tr><tr><td>B 类</td><td>16bit，前两位固定为  10</td><td>128.0 —— 191.255</td><td>16bit</td><td>128.0.0.0 —— 191.255.255.255</td></tr><tr><td>C  类</td><td>24bit，前三位固定为  110</td><td>192.0.0 —— 223.255.255</td><td>8bit</td><td>192.0.0.0 —— 223.255.255.255</td></tr><tr><td>D  类</td><td>前四位固定为 1110，后面为多播地址</td></tr><tr><td>E  类</td><td>前五位固定为 11110，后面保留为今后所用</td></tr></tbody></table></div><p>IP 数据报格式：</p><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/IP数据报格式.png" alt="IP 数据报格式"></p><h4 id="ICMP-网际控制报文协议"><a href="#ICMP-网际控制报文协议" class="headerlink" title="ICMP 网际控制报文协议"></a>ICMP 网际控制报文协议</h4><p>ICMP 报文格式：</p><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/ICMP报文格式.png" alt="ICMP 报文格式"></p><p>应用：</p><ul><li>PING（Packet InterNet Groper，分组网间探测）测试两个主机之间的连通性</li><li>TTL（Time To Live，生存时间）该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量</li></ul><h4 id="内部网关协议"><a href="#内部网关协议" class="headerlink" title="内部网关协议"></a>内部网关协议</h4><ul><li>RIP（Routing Information Protocol，路由信息协议）</li><li>OSPF（Open Sortest Path First，开放最短路径优先）</li></ul><h4 id="外部网关协议"><a href="#外部网关协议" class="headerlink" title="外部网关协议"></a>外部网关协议</h4><ul><li>BGP（Border Gateway Protocol，边界网关协议）</li></ul><h4 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h4><ul><li>IGMP（Internet Group Management Protocol，网际组管理协议）</li><li>多播路由选择协议</li></ul><h4 id="VPN-和-NAT"><a href="#VPN-和-NAT" class="headerlink" title="VPN 和 NAT"></a>VPN 和 NAT</h4><ul><li>VPN（Virtual Private Network，虚拟专用网）</li><li>NAT（Network Address Translation，网络地址转换）</li></ul><h4 id="路由表包含什么？"><a href="#路由表包含什么？" class="headerlink" title="路由表包含什么？"></a>路由表包含什么？</h4><ol><li>网络 ID（Network ID, Network number）：就是目标地址的网络 ID。</li><li>子网掩码（subnet mask）：用来判断 IP 所属网络</li><li>下一跳地址/接口（Next hop / interface）：就是数据在发送到目标地址的旅途中下一站的地址。其中 interface 指向 next hop（即为下一个 route）。一个自治系统（AS, Autonomous system）中的 route 应该包含区域内所有的子网络，而默认网关（Network id: <code>0.0.0.0</code>, Netmask: <code>0.0.0.0</code>）指向自治系统的出口。</li></ol><p>根据应用和执行的不同，路由表可能含有如下附加信息：</p><ol><li>花费（Cost）：就是数据发送过程中通过路径所需要的花费。</li><li>路由的服务质量</li><li>路由中需要过滤的出/入连接列表</li></ol><h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><p>协议：</p><ul><li>TCP（Transmission Control Protocol，传输控制协议）</li><li>UDP（User Datagram Protocol，用户数据报协议）</li></ul><p>端口：</p><div class="table-container"><table><thead><tr><th>应用程序</th><th>FTP</th><th>TELNET</th><th>SMTP</th><th>DNS</th><th>TFTP</th><th>HTTP</th><th>HTTPS</th><th>SNMP  </th></tr></thead><tbody><tr><td>端口号</td><td>21</td><td>23</td><td>25</td><td>53</td><td>69</td><td>80</td><td>443</td><td>161  </td></tr></tbody></table></div><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><ul><li>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，其传输的单位是报文段。</li></ul><p>特征：</p><ul><li>面向连接</li><li>只能点对点（一对一）通信</li><li>可靠交互</li><li>全双工通信</li><li>面向字节流</li></ul><p>TCP 如何保证可靠传输：</p><ul><li>确认和超时重传</li><li>数据合理分片和排序</li><li>流量控制</li><li>拥塞控制</li><li>数据校验</li></ul><p>TCP 报文结构</p><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/TCP报文.png" alt="TCP 报文"></p><p>TCP 首部</p><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/TCP首部.png" alt="TCP 首部"></p><p>TCP：状态控制码（Code，Control Flag），占 6 比特，含义如下：</p><ul><li>URG：紧急比特（urgent），当 <code>URG＝1</code> 时，表明紧急指针字段有效，代表该封包为紧急封包。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)， 且上图中的 Urgent Pointer 字段也会被启用。</li><li>ACK：确认比特（Acknowledge）。只有当 <code>ACK＝1</code> 时确认号字段才有效，代表这个封包为确认封包。当 <code>ACK＝0</code> 时，确认号无效。</li><li>PSH：（Push function）若为 1 时，代表要求对方立即传送缓冲区内的其他对应封包，而无需等缓冲满了才送。</li><li>RST：复位比特(Reset)，当 <code>RST＝1</code> 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。</li><li>SYN：同步比特(Synchronous)，SYN 置为 1，就表示这是一个连接请求或连接接受报文，通常带有 SYN 标志的封包表示『主动』要连接到对方的意思。</li><li>FIN：终止比特(Final)，用来释放一个连接。当 <code>FIN＝1</code> 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。</li></ul><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><ul><li>UDP（User Datagram Protocol，用户数据报协议）是 OSI（Open System Interconnection 开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户数据报。</li></ul><p>特征：</p><ul><li>无连接</li><li>尽最大努力交付</li><li>面向报文</li><li>没有拥塞控制</li><li>支持一对一、一对多、多对一、多对多的交互通信</li><li>首部开销小</li></ul><p>UDP 报文结构</p><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/UDP报文.png" alt="UDP 报文"></p><p>UDP 首部</p><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/UDP首部.png" alt="UDP 首部"></p><blockquote><p>TCP/UDP 图片来源于：<a href="https://github.com/JerryC8080/understand-tcp-udp" target="_blank" rel="noopener">https://github.com/JerryC8080/understand-tcp-udp</a></p></blockquote><h4 id="TCP-与-UDP-的区别"><a href="#TCP-与-UDP-的区别" class="headerlink" title="TCP 与 UDP 的区别"></a>TCP 与 UDP 的区别</h4><ol><li>TCP 面向连接，UDP 是无连接的；</li><li>TCP 提供可靠的服务，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付</li><li>TCP 的逻辑通信信道是全双工的可靠信道；UDP 则是不可靠信道</li><li>每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信</li><li>TCP 面向字节流（可能出现黏包问题），实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的（不会出现黏包问题）</li><li>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）</li><li>TCP 首部开销20字节；UDP 的首部开销小，只有 8 个字节</li></ol><h4 id="TCP-黏包问题"><a href="#TCP-黏包问题" class="headerlink" title="TCP 黏包问题"></a>TCP 黏包问题</h4><h5 id="原因-2"><a href="#原因-2" class="headerlink" title="原因"></a>原因</h5><p>TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的。所以可能会出现两个数据包黏在一起的情况。</p><h5 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h5><ul><li>发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。</li><li>包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。</li><li>在数据包之间设置边界，如添加特殊符号 <code>\r\n</code> 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 <code>\r\n</code>，则会误判为消息的边界。</li><li>使用更加复杂的应用层协议。</li></ul><h4 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h4><h5 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h5><p>流量控制（flow control）就是让发送方的发送速率不要太快，要让接收方来得及接收。</p><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>利用可变窗口进行流量控制</p><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/利用可变窗口进行流量控制举例.png" alt=""></p><h4 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h4><h5 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h5><p>拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</p><h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><ul><li>慢开始( slow-start )</li><li>拥塞避免( congestion avoidance )</li><li>快重传( fast retransmit )</li><li>快恢复( fast recovery )</li></ul><p>TCP的拥塞控制图</p><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/TCP拥塞窗口cwnd在拥塞控制时的变化情况.png" alt=""><br><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/快重传示意图.png" alt=""><br><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/TCP的拥塞控制流程图.png" alt=""></p><h4 id="TCP-传输连接管理"><a href="#TCP-传输连接管理" class="headerlink" title="TCP 传输连接管理"></a>TCP 传输连接管理</h4><blockquote><p>因为 TCP 三次握手建立连接、四次挥手释放连接很重要，所以附上《计算机网络（第 7 版）-谢希仁》书中对此章的详细描述：<a href="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/TCP-transport-connection-management.png" target="_blank" rel="noopener">https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/TCP-transport-connection-management.png</a></p></blockquote><h5 id="TCP-三次握手建立连接"><a href="#TCP-三次握手建立连接" class="headerlink" title="TCP 三次握手建立连接"></a>TCP 三次握手建立连接</h5><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/TCP三次握手建立连接.png" alt="UDP 报文"></p><p>【TCP 建立连接全过程解释】</p><ol><li>客户端发送 SYN 给服务器，说明客户端请求建立连接；</li><li>服务端收到客户端发的 SYN，并回复 SYN+ACK 给客户端（同意建立连接）；</li><li>客户端收到服务端的 SYN+ACK 后，回复 ACK 给服务端（表示客户端收到了服务端发的同意报文）；</li><li>服务端收到客户端的 ACK，连接已建立，可以数据传输。</li></ol><h5 id="TCP-为什么要进行三次握手？"><a href="#TCP-为什么要进行三次握手？" class="headerlink" title="TCP 为什么要进行三次握手？"></a>TCP 为什么要进行三次握手？</h5><p>【答案一】因为信道不可靠，而 TCP 想在不可靠信道上建立可靠地传输，那么三次通信是理论上的最小值。（而 UDP 则不需建立可靠传输，因此 UDP 不需要三次握手。）</p><blockquote><p><a href="https://groups.google.com/forum/#!msg/pongba/kF6O7-MFxM0/5S7zIJ4yqKUJ" target="_blank" rel="noopener">Google Groups . TCP 建立连接为什么是三次握手？{技术}{网络通信}</a></p></blockquote><p>【答案二】因为双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信。</p><blockquote><p><a href="https://www.zhihu.com/question/24853633/answer/115173386" target="_blank" rel="noopener">知乎 . TCP 为什么是三次握手，而不是两次或四次？</a></p></blockquote><p>【答案三】为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p><blockquote><p><a href="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/TCP-transport-connection-management.png" target="_blank" rel="noopener">《计算机网络（第 7 版）-谢希仁》</a></p></blockquote><h5 id="TCP-四次挥手释放连接"><a href="#TCP-四次挥手释放连接" class="headerlink" title="TCP 四次挥手释放连接"></a>TCP 四次挥手释放连接</h5><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/TCP四次挥手释放连接.png" alt="UDP 报文"></p><p>【TCP 释放连接全过程解释】</p><ol><li>客户端发送 FIN 给服务器，说明客户端不必发送数据给服务器了（请求释放从客户端到服务器的连接）；</li><li>服务器接收到客户端发的 FIN，并回复 ACK 给客户端（同意释放从客户端到服务器的连接）；</li><li>客户端收到服务端回复的 ACK，此时从客户端到服务器的连接已释放（但服务端到客户端的连接还未释放，并且客户端还可以接收数据）；</li><li>服务端继续发送之前没发完的数据给客户端；</li><li>服务端发送 FIN+ACK 给客户端，说明服务端发送完了数据（请求释放从服务端到客户端的连接，就算没收到客户端的回复，过段时间也会自动释放）；</li><li>客户端收到服务端的 FIN+ACK，并回复 ACK 给客户端（同意释放从服务端到客户端的连接）；</li><li>服务端收到客户端的 ACK 后，释放从服务端到客户端的连接。</li></ol><h5 id="TCP-为什么要进行四次挥手？"><a href="#TCP-为什么要进行四次挥手？" class="headerlink" title="TCP 为什么要进行四次挥手？"></a>TCP 为什么要进行四次挥手？</h5><p>【问题一】TCP 为什么要进行四次挥手？ / 为什么 TCP 建立连接需要三次，而释放连接则需要四次？</p><p>【答案一】因为 TCP 是全双工模式，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前没传完的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以 TCP 释放连接时服务器的 ACK 和 FIN 是分开发送的（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。</p><p>【问题二】为什么 TCP 连接时可以 ACK 和 SYN 一起发送，而释放时则 ACK 和 FIN 分开发送呢？（ACK 和 FIN 分开是指第二次和第三次挥手）</p><p>【答案二】因为客户端请求释放时，服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）；而连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送。</p><p>【问题三】为什么客户端释放最后需要 TIME-WAIT 等待 2MSL 呢？</p><p>【答案三】</p><ol><li>为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。</li><li>防止已失效的连接请求报文段出现在本连接中。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。</li></ol><h4 id="TCP-有限状态机"><a href="#TCP-有限状态机" class="headerlink" title="TCP 有限状态机"></a>TCP 有限状态机</h4><p>TCP 有限状态机图片</p><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/TCP的有限状态机.png" alt="TCP 的有限状态机"></p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><ul><li>DNS（Domain Name System，域名系统）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS 使用 TCP 和 UDP 端口 53。当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符。</li></ul><p>域名：</p><ul><li><code>域名 ::= {&lt;三级域名&gt;.&lt;二级域名&gt;.&lt;顶级域名&gt;}</code>，如：<code>blog.huihut.com</code></li></ul><h4 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h4><ul><li>FTP（File Transfer Protocol，文件传输协议）是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式，使用 TCP 数据报，提供交互式访问，双向传输。</li><li>TFTP（Trivial File Transfer Protocol，简单文件传输协议）一个小且易实现的文件传输协议，也使用客户-服务器方式，使用UDP数据报，只支持文件传输而不支持交互，没有列目录，不能对用户进行身份鉴定</li></ul><h4 id="TELNET"><a href="#TELNET" class="headerlink" title="TELNET"></a>TELNET</h4><ul><li><p>TELNET 协议是 TCP/IP 协议族中的一员，是 Internet 远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。</p></li><li><p>HTTP（HyperText Transfer Protocol，超文本传输协议）是用于从 WWW（World Wide Web，万维网）服务器传输超文本到本地浏览器的传送协议。</p></li><li><p>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。</p></li><li>Socket 建立网络通信连接至少要一对端口号（Socket）。Socket 本质是编程接口（API），对 TCP/IP 的封装，TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口。</li></ul><h4 id="WWW"><a href="#WWW" class="headerlink" title="WWW"></a>WWW</h4><ul><li>WWW（World Wide Web，环球信息网，万维网）是一个由许多互相链接的超文本组成的系统，通过互联网访问</li></ul><h5 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h5><ul><li>URL（Uniform Resource Locator，统一资源定位符）是因特网上标准的资源的地址（Address）</li></ul><p>标准格式：</p><ul><li><code>协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]</code></li></ul><p>完整格式：</p><ul><li><code>协议类型:[//[访问资源需要的凭证信息@]服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]</code></li></ul><blockquote><p>其中【访问凭证信息@；:端口号；?查询；#片段ID】都属于选填项<br>如：<code>https://github.com/huihut/interview#cc</code></p></blockquote><h5 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h5><p>HTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP 是万维网的数据通信的基础。</p><p>请求方法</p><div class="table-container"><table><thead><tr><th>方法</th><th>意义</th></tr></thead><tbody><tr><td>OPTIONS</td><td>请求一些选项信息，允许客户端查看服务器的性能</td></tr><tr><td>GET</td><td>请求指定的页面信息，并返回实体主体</td></tr><tr><td>HEAD</td><td>类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td>POST</td><td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改</td></tr><tr><td>PUT</td><td>从客户端向服务器传送的数据取代指定的文档的内容</td></tr><tr><td>DELETE</td><td>请求服务器删除指定的页面</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断</td></tr></tbody></table></div><p>状态码（Status-Code）</p><ul><li>1xx：表示通知信息，如请求收到了或正在进行处理<ul><li>100 Continue：继续，客户端应继续其请求</li><li>101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议</li></ul></li><li>2xx：表示成功，如接收或知道了<ul><li>200 OK: 请求成功</li></ul></li><li>3xx：表示重定向，如要完成请求还必须采取进一步的行动<ul><li>301 Moved Permanently: 永久移动。请求的资源已被永久的移动到新 URL，返回信息会包括新的 URL，浏览器会自动定向到新 URL。今后任何新的请求都应使用新的 URL 代替</li></ul></li><li>4xx：表示客户的差错，如请求中有错误的语法或不能完成<ul><li>400 Bad Request: 客户端请求的语法错误，服务器无法理解</li><li>401 Unauthorized: 请求要求用户的身份认证</li><li>403 Forbidden: 服务器理解请求客户端的请求，但是拒绝执行此请求（权限不够）</li><li>404 Not Found: 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置 “您所请求的资源无法找到” 的个性页面</li><li>408 Request Timeout: 服务器等待客户端发送的请求时间过长，超时</li></ul></li><li>5xx：表示服务器的差错，如服务器失效无法完成请求<ul><li>500 Internal Server Error: 服务器内部错误，无法完成请求</li><li>503 Service Unavailable: 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中</li><li>504 Gateway Timeout: 充当网关或代理的服务器，未及时从远端服务器获取请求</li></ul></li></ul><blockquote><p>更多状态码：<a href="http://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener">菜鸟教程 . HTTP状态码</a></p></blockquote><h5 id="其他协议"><a href="#其他协议" class="headerlink" title="其他协议"></a>其他协议</h5><ul><li>SMTP（Simple Main Transfer Protocol，简单邮件传输协议）是在 Internet 传输 Email 的标准，是一个相对简单的基于文本的协议。在其之上指定了一条消息的一个或多个接收者（在大多数情况下被确认是存在的），然后消息文本会被传输。可以很简单地通过 Telnet 程序来测试一个 SMTP 服务器。SMTP 使用 TCP 端口 25。</li><li>DHCP（Dynamic Host Configuration Protocol，动态主机设置协议）是一个局域网的网络协议，使用 UDP 协议工作，主要有两个用途：<ul><li>用于内部网络或网络服务供应商自动分配 IP 地址给用户</li><li>用于内部网络管理员作为对所有电脑作中央管理的手段</li></ul></li><li>SNMP（Simple Network Management Protocol，简单网络管理协议）构成了互联网工程工作小组（IETF，Internet Engineering Task Force）定义的 Internet 协议族的一部分。该协议能够支持网络管理系统，用以监测连接到网络上的设备是否有任何引起管理上关注的情况。</li></ul><h2 id="🌩-网络编程"><a href="#🌩-网络编程" class="headerlink" title="🌩 网络编程"></a>🌩 网络编程</h2><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><blockquote><p><a href="https://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html" target="_blank" rel="noopener">Linux Socket 编程（不限 Linux）</a></p></blockquote><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/socket客户端服务器通讯.jpg" alt="Socket 客户端服务器通讯"></p><h4 id="Socket-中的-read-、write-函数"><a href="#Socket-中的-read-、write-函数" class="headerlink" title="Socket 中的 read()、write() 函数"></a>Socket 中的 read()、write() 函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h5><ul><li>read 函数是负责从 fd 中读取内容。</li><li>当读成功时，read 返回实际所读的字节数。</li><li>如果返回的值是 0 表示已经读到文件的结束了，小于 0 表示出现了错误。</li><li>如果错误为 EINTR 说明读是由中断引起的；如果是 ECONNREST 表示网络连接出了问题。</li></ul><h5 id="write"><a href="#write" class="headerlink" title="write()"></a>write()</h5><ul><li>write 函数将 buf 中的 nbytes 字节内容写入文件描述符 fd。</li><li>成功时返回写的字节数。失败时返回 -1，并设置 errno 变量。</li><li>在网络程序中，当我们向套接字文件描述符写时有俩种可能。</li><li>（1）write 的返回值大于 0，表示写了部分或者是全部的数据。</li><li>（2）返回的值小于 0，此时出现了错误。</li><li>如果错误为 EINTR 表示在写的时候出现了中断错误；如果为 EPIPE 表示网络连接出现了问题（对方已经关闭了连接）。</li></ul><h4 id="Socket-中-TCP-的三次握手建立连接"><a href="#Socket-中-TCP-的三次握手建立连接" class="headerlink" title="Socket 中 TCP 的三次握手建立连接"></a>Socket 中 TCP 的三次握手建立连接</h4><p>我们知道 TCP 建立连接要进行 “三次握手”，即交换三个分组。大致流程如下：</p><ol><li>客户端向服务器发送一个 SYN J</li><li>服务器向客户端响应一个 SYN K，并对 SYN J 进行确认 ACK J+1</li><li>客户端再想服务器发一个确认 ACK K+1</li></ol><p>只有就完了三次握手，但是这个三次握手发生在 Socket 的那几个函数中呢？请看下图：</p><p><img src="http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157467258.png" alt="socket 中发送的 TCP 三次握手"></p><p>从图中可以看出：</p><ol><li>当客户端调用 connect 时，触发了连接请求，向服务器发送了 SYN J 包，这时 connect 进入阻塞状态；  </li><li>服务器监听到连接请求，即收到 SYN J 包，调用 accept 函数接收请求向客户端发送 SYN K ，ACK J+1，这时 accept 进入阻塞状态；  </li><li>客户端收到服务器的 SYN K ，ACK J+1 之后，这时 connect 返回，并对 SYN K 进行确认；  </li><li>服务器收到 ACK K+1 时，accept 返回，至此三次握手完毕，连接建立。</li></ol><h4 id="Socket-中-TCP-的四次握手释放连接"><a href="#Socket-中-TCP-的四次握手释放连接" class="headerlink" title="Socket 中 TCP 的四次握手释放连接"></a>Socket 中 TCP 的四次握手释放连接</h4><p>上面介绍了 socket 中 TCP 的三次握手建立过程，及其涉及的 socket 函数。现在我们介绍 socket 中的四次握手释放连接的过程，请看下图：</p><p><img src="http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157487616.png" alt="socket 中发送的 TCP 四次握手"></p><p>图示过程如下：</p><ol><li>某个应用进程首先调用 close 主动关闭连接，这时 TCP 发送一个 FIN M；</li><li>另一端接收到 FIN M 之后，执行被动关闭，对这个 FIN 进行确认。它的接收也作为文件结束符传递给应用进程，因为 FIN 的接收意味着应用进程在相应的连接上再也接收不到额外数据；</li><li>一段时间之后，接收到文件结束符的应用进程调用 close 关闭它的 socket。这导致它的 TCP 也发送一个 FIN N；</li><li>接收到这个 FIN 的源发送端 TCP 对它进行确认。</li></ol><p>这样每个方向上都有一个 FIN 和 ACK。</p><h2 id="💾-数据库"><a href="#💾-数据库" class="headerlink" title="💾 数据库"></a>💾 数据库</h2><blockquote><p>本节部分知识点来自《数据库系统概论（第 5 版）》</p></blockquote><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>数据（data）：描述事物的符号记录称为数据。</li><li>数据库（DataBase，DB）：是长期存储在计算机内、有组织的、可共享的大量数据的集合，具有永久存储、有组织、可共享三个基本特点。</li><li>数据库管理系统（DataBase Management System，DBMS）：是位于用户与操作系统之间的一层数据管理软件。</li><li>数据库系统（DataBase System，DBS）：是有数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DataBase Administrator DBA）组成的存储、管理、处理和维护数据的系统。</li><li>实体（entity）：客观存在并可相互区别的事物称为实体。</li><li>属性（attribute）：实体所具有的某一特性称为属性。</li><li>码（key）：唯一标识实体的属性集称为码。</li><li>实体型（entity type）：用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。</li><li>实体集（entity set）：同一实体型的集合称为实体集。</li><li>联系（relationship）：实体之间的联系通常是指不同实体集之间的联系。</li><li>模式（schema）：模式也称逻辑模式，是数据库全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。</li><li>外模式（external schema）：外模式也称子模式（subschema）或用户模式，它是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。</li><li>内模式（internal schema）：内模式也称为存储模式（storage schema），一个数据库只有一个内模式。他是数据物理结构和存储方式的描述，是数据库在数据库内部的组织方式。</li></ul><h3 id="常用数据模型"><a href="#常用数据模型" class="headerlink" title="常用数据模型"></a>常用数据模型</h3><ul><li>层次模型（hierarchical model）</li><li>网状模型（network model）</li><li>关系模型（relational model）<ul><li>关系（relation）：一个关系对应通常说的一张表</li><li>元组（tuple）：表中的一行即为一个元组</li><li>属性（attribute）：表中的一列即为一个属性</li><li>码（key）：表中可以唯一确定一个元组的某个属性组</li><li>域（domain）：一组具有相同数据类型的值的集合</li><li>分量：元组中的一个属性值</li><li>关系模式：对关系的描述，一般表示为 <code>关系名(属性1, 属性2, ..., 属性n)</code></li></ul></li><li>面向对象数据模型（object oriented data model）</li><li>对象关系数据模型（object relational data model）</li><li>半结构化数据模型（semistructure data model）</li></ul><h3 id="常用-SQL-操作"><a href="#常用-SQL-操作" class="headerlink" title="常用 SQL 操作"></a>常用 SQL 操作</h3><table>  <tr>    <th>对象类型</th>    <th>对象</th>    <th>操作类型</th>  </tr>  <tr>    <td rowspan="4">数据库模式</td>    <td>模式</td>    <td><code>CREATE SCHEMA</code></td>  </tr>  <tr>    <td>基本表</td>    <td><code>CREATE SCHEMA</code>，<code>ALTER TABLE</code></td>  </tr>    <tr>    <td>视图</td>    <td><code>CREATE VIEW</code></td>  </tr>    <tr>    <td>索引</td>    <td><code>CREATE INDEX</code></td>  </tr>    <tr>    <td rowspan="2">数据</td>    <td>基本表和视图</td>    <td><code>SELECT</code>，<code>INSERT</code>，<code>UPDATE</code>，<code>DELETE</code>，<code>REFERENCES</code>，<code>ALL PRIVILEGES</code></td>  </tr>    <tr>    <td>属性列</td>    <td><code>SELECT</code>，<code>INSERT</code>，<code>UPDATE</code>，<code>REFERENCES</code>，<code>ALL PRIVILEGES</code></td>  </tr></table><blockquote><p>SQL 语法教程：<a href="http://www.runoob.com/sql/sql-tutorial.html" target="_blank" rel="noopener">runoob . SQL 教程</a></p></blockquote><h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><ul><li>基本关系操作：查询（选择、投影、连接（等值连接、自然连接、外连接（左外连接、右外连接））、除、并、差、交、笛卡尔积等）、插入、删除、修改</li><li>关系模型中的三类完整性约束：实体完整性、参照完整性、用户定义的完整性</li></ul><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><ul><li>数据库索引：顺序索引、B+ 树索引、hash 索引</li><li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL 索引背后的数据结构及算法原理</a></li></ul><h3 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h3><ul><li>数据库的完整性是指数据的正确性和相容性。<ul><li>完整性：为了防止数据库中存在不符合语义（不正确）的数据。</li><li>安全性：为了保护数据库防止恶意破坏和非法存取。</li></ul></li><li>触发器：是用户定义在关系表中的一类由事件驱动的特殊过程。</li></ul><h3 id="关系数据理论"><a href="#关系数据理论" class="headerlink" title="关系数据理论"></a>关系数据理论</h3><ul><li>数据依赖是一个关系内部属性与属性之间的一种约束关系，是通过属性间值的相等与否体现出来的数据间相关联系。</li><li>最重要的数据依赖：函数依赖、多值依赖。</li></ul><h4 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h4><ul><li>第一范式（1NF）：属性（字段）是最小单位不可再分。</li><li>第二范式（2NF）：满足 1NF，每个非主属性完全依赖于主键（消除 1NF 非主属性对码的部分函数依赖）。</li><li>第三范式（3NF）：满足 2NF，任何非主属性不依赖于其他非主属性（消除 2NF 非主属性对码的传递函数依赖）。</li><li>鲍依斯-科得范式（BCNF）：满足 3NF，任何非主属性不能对主键子集依赖（消除 3NF 主属性对码的部分和传递函数依赖）。</li><li>第四范式（4NF）：满足 3NF，属性之间不能有非平凡且非函数依赖的多值依赖（消除 3NF 非平凡且非函数依赖的多值依赖）。</li></ul><h3 id="数据库恢复"><a href="#数据库恢复" class="headerlink" title="数据库恢复"></a>数据库恢复</h3><ul><li>事务：是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。</li><li>事物的 ACID 特性：原子性、一致性、隔离性、持续性。</li><li>恢复的实现技术：建立冗余数据 -&gt; 利用冗余数据实施数据库恢复。</li><li>建立冗余数据常用技术：数据转储（动态海量转储、动态增量转储、静态海量转储、静态增量转储）、登记日志文件。</li></ul><h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><ul><li>事务是并发控制的基本单位。</li><li>并发操作带来的数据不一致性包括：丢失修改、不可重复读、读 “脏” 数据。</li><li>并发控制主要技术：封锁、时间戳、乐观控制法、多版本并发控制等。</li><li>基本封锁类型：排他锁（X 锁 / 写锁）、共享锁（S 锁 / 读锁）。</li><li>活锁死锁：<ul><li>活锁：事务永远处于等待状态，可通过先来先服务的策略避免。</li><li>死锁：事物永远不能结束<ul><li>预防：一次封锁法、顺序封锁法；</li><li>诊断：超时法、等待图法；</li><li>解除：撤销处理死锁代价最小的事务，并释放此事务的所有的锁，使其他事务得以继续运行下去。</li></ul></li></ul></li><li>可串行化调度：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同。可串行性时并发事务正确调度的准则。</li></ul><h2 id="📏-设计模式"><a href="#📏-设计模式" class="headerlink" title="📏 设计模式"></a>📏 设计模式</h2><blockquote><p>各大设计模式例子参考：<a href="https://blog.csdn.net/liang19890820/article/details/66974516" target="_blank" rel="noopener">CSDN专栏 . C++ 设计模式</a> 系列博文</p></blockquote><p><a href="DesignPattern">设计模式工程目录</a></p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p><a href="DesignPattern/SingletonPattern">单例模式例子</a></p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p><a href="DesignPattern/AbstractFactoryPattern">抽象工厂模式例子</a></p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p><a href="DesignPattern/AdapterPattern">适配器模式例子</a></p><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p><a href="DesignPattern/BridgePattern">桥接模式例子</a></p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p><a href="DesignPattern/ObserverPattern">观察者模式例子</a></p><h3 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h3><ul><li>单一职责原则（SRP，Single Responsibility Principle）</li><li>里氏替换原则（LSP，Liskov Substitution Principle）</li><li>依赖倒置原则（DIP，Dependence Inversion Principle）</li><li>接口隔离原则（ISP，Interface Segregation Principle）</li><li>迪米特法则（LoD，Law of Demeter）</li><li>开放封闭原则（OCP，Open Close Principle）</li></ul><h2 id="⚙️-链接装载库"><a href="#⚙️-链接装载库" class="headerlink" title="⚙️ 链接装载库"></a>⚙️ 链接装载库</h2><blockquote><p>本节部分知识点来自《程序员的自我修养——链接装载库》</p></blockquote><h3 id="内存、栈、堆"><a href="#内存、栈、堆" class="headerlink" title="内存、栈、堆"></a>内存、栈、堆</h3><p>一般应用程序内存空间有如下区域：</p><ul><li>栈：由操作系统自动分配释放，存放函数的参数值、局部变量等的值，用于维护函数调用的上下文</li><li>堆：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收，用来容纳应用程序动态分配的内存区域</li><li>可执行文件映像：存储着可执行文件在内存中的映像，由装载器装载是将可执行文件的内存读取或映射到这里</li><li>保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称，如通常 C 语言讲无效指针赋值为 0（NULL），因此 0 地址正常情况下不可能有效的访问数据</li></ul><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈保存了一个函数调用所需要的维护信息，常被称为堆栈帧（Stack Frame）或活动记录（Activate Record），一般包含以下几方面：</p><ul><li>函数的返回地址和参数</li><li>临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量</li><li>保存上下文：包括函数调用前后需要保持不变的寄存器</li></ul><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>堆分配算法：</p><ul><li>空闲链表（Free List）</li><li>位图（Bitmap）</li><li>对象池</li></ul><h4 id="“段错误（segment-fault）”-或-“非法操作，该内存地址不能-read-write”"><a href="#“段错误（segment-fault）”-或-“非法操作，该内存地址不能-read-write”" class="headerlink" title="“段错误（segment fault）” 或 “非法操作，该内存地址不能 read/write”"></a>“段错误（segment fault）” 或 “非法操作，该内存地址不能 read/write”</h4><p>典型的非法指针解引用造成的错误。当指针指向一个不允许读写的内存地址，而程序却试图利用指针来读或写该地址时，会出现这个错误。</p><p>普遍原因：</p><ul><li>将指针初始化为 NULL，之后没有给它一个合理的值就开始使用指针</li><li>没用初始化栈中的指针，指针的值一般会是随机数，之后就直接开始使用指针</li></ul><h3 id="编译链接"><a href="#编译链接" class="headerlink" title="编译链接"></a>编译链接</h3><h4 id="各平台文件格式"><a href="#各平台文件格式" class="headerlink" title="各平台文件格式"></a>各平台文件格式</h4><div class="table-container"><table><thead><tr><th>平台</th><th>可执行文件</th><th>目标文件</th><th>动态库/共享对象</th><th>静态库</th></tr></thead><tbody><tr><td>Windows</td><td>exe</td><td>obj</td><td>dll</td><td>lib</td></tr><tr><td>Unix/Linux</td><td>ELF、out</td><td>o</td><td>so</td><td>a</td></tr><tr><td>Mac</td><td>Mach-O</td><td>o</td><td>dylib、tbd、framework</td><td>a、framework</td></tr></tbody></table></div><h4 id="编译链接过程"><a href="#编译链接过程" class="headerlink" title="编译链接过程"></a>编译链接过程</h4><ol><li>预编译（预编译器处理如 <code>#include</code>、<code>#define</code> 等预编译指令，生成 <code>.i</code> 或 <code>.ii</code> 文件）</li><li>编译（编译器进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成、优化，生成 <code>.s</code> 文件）</li><li>汇编（汇编器把汇编码翻译成机器码，生成 <code>.o</code> 文件）</li><li>链接（连接器进行地址和空间分配、符号决议、重定位，生成 <code>.out</code> 文件）</li></ol><blockquote><p>现在版本 GCC 把预编译和编译合成一步，预编译编译程序 cc1、汇编器 as、连接器 ld</p><p>MSVC 编译环境，编译器 cl、连接器 link、可执行文件查看器 dumpbin</p></blockquote><h4 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h4><p>编译器编译源代码后生成的文件叫做目标文件。目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整。</p><blockquote><p>可执行文件（Windows 的 <code>.exe</code> 和 Linux 的 <code>ELF</code>）、动态链接库（Windows 的 <code>.dll</code> 和 Linux 的 <code>.so</code>）、静态链接库（Windows 的 <code>.lib</code> 和 Linux 的 <code>.a</code>）都是按照可执行文件格式存储（Windows 按照 PE-COFF，Linux 按照 ELF）</p></blockquote><h5 id="目标文件格式"><a href="#目标文件格式" class="headerlink" title="目标文件格式"></a>目标文件格式</h5><ul><li>Windows 的 PE（Portable Executable），或称为 PE-COFF，<code>.obj</code> 格式</li><li>Linux 的 ELF（Executable Linkable Format），<code>.o</code> 格式</li><li>Intel/Microsoft 的 OMF（Object Module Format）</li><li>Unix 的 <code>a.out</code> 格式</li><li>MS-DOS 的 <code>.COM</code> 格式</li></ul><blockquote><p>PE 和 ELF 都是 COFF（Common File Format）的变种</p></blockquote><h5 id="目标文件存储结构"><a href="#目标文件存储结构" class="headerlink" title="目标文件存储结构"></a>目标文件存储结构</h5><div class="table-container"><table><thead><tr><th>段</th><th>功能</th></tr></thead><tbody><tr><td>File Header</td><td>文件头，描述整个文件的文件属性（包括文件是否可执行、是静态链接或动态连接及入口地址、目标硬件、目标操作系统等）</td></tr><tr><td>.text section</td><td>代码段，执行语句编译成的机器代码 </td></tr><tr><td>.data section</td><td>数据段，已初始化的全局变量和局部静态变量</td></tr><tr><td>.bss section</td><td>BSS 段（Block Started by Symbol），未初始化的全局变量和局部静态变量（因为默认值为 0，所以只是在此预留位置，不占空间）</td></tr><tr><td>.rodata section</td><td>只读数据段，存放只读数据，一般是程序里面的只读变量（如 const 修饰的变量）和字符串常量</td></tr><tr><td>.comment section</td><td>注释信息段，存放编译器版本信息</td></tr><tr><td>.note.GNU-stack section</td><td>堆栈提示段 </td></tr></tbody></table></div><blockquote><p>其他段略</p></blockquote><h4 id="链接的接口————符号"><a href="#链接的接口————符号" class="headerlink" title="链接的接口————符号"></a>链接的接口————符号</h4><p>在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。</p><p>如下符号表（Symbol Table）：</p><div class="table-container"><table><thead><tr><th>Symbol（符号名）</th><th>Symbol Value （地址）</th></tr></thead><tbody><tr><td>main</td><td>0x100</td></tr><tr><td>Add</td><td>0x123</td></tr><tr><td>…</td><td>…</td></tr></tbody></table></div><h3 id="Linux-的共享库（Shared-Library）"><a href="#Linux-的共享库（Shared-Library）" class="headerlink" title="Linux 的共享库（Shared Library）"></a>Linux 的共享库（Shared Library）</h3><p>Linux 下的共享库就是普通的 ELF 共享对象。</p><p>共享库版本更新应该保证二进制接口 ABI（Application Binary Interface）的兼容</p><h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p><code>libname.so.x.y.z</code></p><ul><li>x：主版本号，不同主版本号的库之间不兼容，需要重新编译</li><li>y：次版本号，高版本号向后兼容低版本号</li><li>z：发布版本号，不对接口进行更改，完全兼容</li></ul><h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>大部分包括 Linux 在内的开源系统遵循 FHS（File Hierarchy Standard）的标准，这标准规定了系统文件如何存放，包括各个目录结构、组织和作用。</p><ul><li><code>/lib</code>：存放系统最关键和最基础的共享库，如动态链接器、C 语言运行库、数学库等</li><li><code>/usr/lib</code>：存放非系统运行时所需要的关键性的库，主要是开发库</li><li><code>/usr/local/lib</code>：存放跟操作系统本身并不十分相关的库，主要是一些第三方应用程序的库</li></ul><blockquote><p>动态链接器会在 <code>/lib</code>、<code>/usr/lib</code> 和由 <code>/etc/ld.so.conf</code> 配置文件指定的，目录中查找共享库</p></blockquote><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><ul><li><code>LD_LIBRARY_PATH</code>：临时改变某个应用程序的共享库查找路径，而不会影响其他应用程序</li><li><code>LD_PRELOAD</code>：指定预先装载的一些共享库甚至是目标文件</li><li><code>LD_DEBUG</code>：打开动态链接器的调试功能</li></ul><h4 id="so-共享库的编写"><a href="#so-共享库的编写" class="headerlink" title="so 共享库的编写"></a>so 共享库的编写</h4><p>使用 CLion 编写共享库</p><p>创建一个名为 MySharedLib 的共享库</p><p>CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(MySharedLib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(MySharedLib SHARED library.cpp library.h)</span><br></pre></td></tr></table></figure><p>library.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYSHAREDLIB_LIBRARY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYSHAREDLIB_LIBRARY_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印 Hello World!</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用可变模版参数求和</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Types&gt;</span><br><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(T first, Types ... rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first + sum&lt;T&gt;(rest...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>library.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"library.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, World!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="so-共享库的使用（被可执行项目调用）"><a href="#so-共享库的使用（被可执行项目调用）" class="headerlink" title="so 共享库的使用（被可执行项目调用）"></a>so 共享库的使用（被可执行项目调用）</h4><p>使用 CLion 调用共享库</p><p>创建一个名为 TestSharedLib 的可执行项目</p><p>CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(TestSharedLib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># C++11 编译</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 头文件路径</span></span><br><span class="line"><span class="keyword">set</span>(INC_DIR /home/xx/code/clion/MySharedLib)</span><br><span class="line"><span class="comment"># 库文件路径</span></span><br><span class="line"><span class="keyword">set</span>(LIB_DIR /home/xx/code/clion/MySharedLib/cmake-build-debug)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;INC_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;LIB_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">link_libraries</span>(MySharedLib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(TestSharedLib main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接 MySharedLib 库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(TestSharedLib MySharedLib)</span><br></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"library.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    hello();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1 + 2 = "</span> &lt;&lt; sum(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1 + 2 + 3 = "</span> &lt;&lt; sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br><span class="line">1 + 2 &#x3D; 3</span><br><span class="line">1 + 2 + 3 &#x3D; 6</span><br></pre></td></tr></table></figure><h3 id="Windows-应用程序入口函数"><a href="#Windows-应用程序入口函数" class="headerlink" title="Windows 应用程序入口函数"></a>Windows 应用程序入口函数</h3><ul><li>GUI（Graphical User Interface）应用，链接器选项：<code>/SUBSYSTEM:WINDOWS</code></li><li>CUI（Console User Interface）应用，链接器选项：<code>/SUBSYSTEM:CONSOLE</code></li></ul><p>_tWinMain 与 _tmain 函数声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Int WINAPI _tWinMain(</span><br><span class="line">    HINSTANCE hInstanceExe,</span><br><span class="line">    HINSTANCE,</span><br><span class="line">    PTSTR pszCmdLine,</span><br><span class="line">    <span class="keyword">int</span> nCmdShow);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(</span><br><span class="line">    <span class="keyword">int</span> argc,</span><br><span class="line">    TCHAR *argv[],</span><br><span class="line">    TCHAR *envp[]);</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>应用程序类型</th><th>入口点函数</th><th>嵌入可执行文件的启动函数</th></tr></thead><tbody><tr><td>处理ANSI字符（串）的GUI应用程序</td><td>_tWinMain(WinMain)</td><td>WinMainCRTSartup</td></tr><tr><td>处理Unicode字符（串）的GUI应用程序</td><td>_tWinMain(wWinMain)</td><td>wWinMainCRTSartup</td></tr><tr><td>处理ANSI字符（串）的CUI应用程序</td><td>_tmain(Main)</td><td>mainCRTSartup</td></tr><tr><td>处理Unicode字符（串）的CUI应用程序</td><td>_tmain(wMain)</td><td>wmainCRTSartup</td></tr><tr><td>动态链接库（Dynamic-Link Library）</td><td>DllMain</td><td>_DllMainCRTStartup </td></tr></tbody></table></div><h3 id="Windows-的动态链接库（Dynamic-Link-Library）"><a href="#Windows-的动态链接库（Dynamic-Link-Library）" class="headerlink" title="Windows 的动态链接库（Dynamic-Link Library）"></a>Windows 的动态链接库（Dynamic-Link Library）</h3><blockquote><p>部分知识点来自《Windows 核心编程（第五版）》</p></blockquote><h4 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h4><ul><li>扩展了应用程序的特性</li><li>简化了项目管理</li><li>有助于节省内存</li><li>促进了资源的共享</li><li>促进了本地化</li><li>有助于解决平台间的差异</li><li>可以用于特殊目的</li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>创建 DLL，事实上是在创建可供一个可执行模块调用的函数</li><li>当一个模块提供一个内存分配函数（malloc、new）的时候，它必须同时提供另一个内存释放函数（free、delete）</li><li>在使用 C 和 C++ 混编的时候，要使用 extern “C” 修饰符</li><li>一个 DLL 可以导出函数、变量（避免导出）、C++ 类（导出导入需要同编译器，否则避免导出）</li><li>DLL 模块：cpp 文件中的 __declspec(dllexport) 写在 include 头文件之前</li><li>调用 DLL 的可执行模块：cpp 文件的 __declspec(dllimport) 之前不应该定义 MYLIBAPI</li></ul><h4 id="加载-Windows-程序的搜索顺序"><a href="#加载-Windows-程序的搜索顺序" class="headerlink" title="加载 Windows 程序的搜索顺序"></a>加载 Windows 程序的搜索顺序</h4><ol><li>包含可执行文件的目录</li><li>Windows 的系统目录，可以通过 GetSystemDirectory 得到</li><li>16 位的系统目录，即 Windows 目录中的 System 子目录</li><li>Windows 目录，可以通过 GetWindowsDirectory 得到</li><li>进程的当前目录</li><li>PATH 环境变量中所列出的目录</li></ol><h4 id="DLL-入口函数"><a href="#DLL-入口函数" class="headerlink" title="DLL 入口函数"></a>DLL 入口函数</h4><p>DllMain 函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(fdwReason)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="comment">// 第一次将一个DLL映射到进程地址空间时调用</span></span><br><span class="line">        <span class="comment">// The DLL is being mapped into the process' address space.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">        <span class="comment">// 当进程创建一个线程的时候，用于告诉DLL执行与线程相关的初始化（非主线程执行）</span></span><br><span class="line">        <span class="comment">// A thread is bing created.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">        <span class="comment">// 系统调用 ExitThread 线程退出前，即将终止的线程通过告诉DLL执行与线程相关的清理</span></span><br><span class="line">        <span class="comment">// A thread is exiting cleanly.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="comment">// 将一个DLL从进程的地址空间时调用</span></span><br><span class="line">        <span class="comment">// The DLL is being unmapped from the process' address space.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (TRUE); <span class="comment">// Used only for DLL_PROCESS_ATTACH</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="载入卸载库"><a href="#载入卸载库" class="headerlink" title="载入卸载库"></a>载入卸载库</h4><p>LoadLibrary、LoadLibraryExA、LoadPackagedLibrary、FreeLibrary、FreeLibraryAndExitThread 函数声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 载入库</span></span><br><span class="line"><span class="function">HMODULE WINAPI <span class="title">LoadLibrary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ LPCTSTR lpFileName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="function">HMODULE <span class="title">LoadLibraryExA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR lpLibFileName,</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hFile,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD  dwFlags</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="comment">// 若要在通用 Windows 平台（UWP）应用中加载 Win32 DLL，需要调用 LoadPackagedLibrary，而不是 LoadLibrary 或 LoadLibraryEx</span></span><br><span class="line"><span class="function">HMODULE <span class="title">LoadPackagedLibrary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCWSTR lpwLibFileName,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD   Reserved</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载库</span></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">FreeLibrary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ HMODULE hModule</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="comment">// 卸载库和退出线程</span></span><br><span class="line"><span class="function">VOID WINAPI <span class="title">FreeLibraryAndExitThread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ HMODULE hModule,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ DWORD   dwExitCode</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="显示地链接到导出符号"><a href="#显示地链接到导出符号" class="headerlink" title="显示地链接到导出符号"></a>显示地链接到导出符号</h4><p>GetProcAddress 函数声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FARPROC <span class="title">GetProcAddress</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HMODULE hInstDll,</span></span></span><br><span class="line"><span class="function"><span class="params">  PCSTR pszSymbolName  <span class="comment">// 只能接受 ANSI 字符串，不能是 Unicode</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="DumpBin-exe-查看-DLL-信息"><a href="#DumpBin-exe-查看-DLL-信息" class="headerlink" title="DumpBin.exe 查看 DLL 信息"></a>DumpBin.exe 查看 DLL 信息</h4><p>在 <code>VS 的开发人员命令提示符</code> 使用 <code>DumpBin.exe</code> 可查看 DLL 库的导出段（导出的变量、函数、类名的符号）、相对虚拟地址（RVA，relative virtual address）。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DUMPBIN -exports D:\mydll.dll</span><br></pre></td></tr></table></figure></p><h4 id="LoadLibrary-与-FreeLibrary-流程图"><a href="#LoadLibrary-与-FreeLibrary-流程图" class="headerlink" title="LoadLibrary 与 FreeLibrary 流程图"></a>LoadLibrary 与 FreeLibrary 流程图</h4><p>LoadLibrary 与 FreeLibrary 流程图</p><h5 id="LoadLibrary"><a href="#LoadLibrary" class="headerlink" title="LoadLibrary"></a>LoadLibrary</h5><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/WindowsLoadLibrary.png" alt="WindowsLoadLibrary"></p><h5 id="FreeLibrary"><a href="#FreeLibrary" class="headerlink" title="FreeLibrary"></a>FreeLibrary</h5><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/cpp_interview/WindowsFreeLibrary.png" alt="WindowsFreeLibrary"></p><h4 id="DLL-库的编写（导出一个-DLL-模块）"><a href="#DLL-库的编写（导出一个-DLL-模块）" class="headerlink" title="DLL 库的编写（导出一个 DLL 模块）"></a>DLL 库的编写（导出一个 DLL 模块）</h4><p>DLL 库的编写（导出一个 DLL 模块）<br>DLL 头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyLib.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MYLIBAPI</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MYLIBAPI 应该在全部 DLL 源文件的 include "Mylib.h" 之前被定义</span></span><br><span class="line"><span class="comment">// 全部函数/变量正在被导出</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个头文件被一个exe源代码模块包含，意味着全部函数/变量被导入</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYLIBAPI extern <span class="meta-string">"C"</span> __declspec(dllimport)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里定义任何的数据结构和符号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义导出的变量（避免导出变量）</span></span><br><span class="line">MYLIBAPI <span class="keyword">int</span> g_nResult;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义导出函数原型</span></span><br><span class="line"><span class="function">MYLIBAPI <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> nLeft, <span class="keyword">int</span> nRight)</span></span>;</span><br></pre></td></tr></table></figure><p>DLL 源文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyLibFile1.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含标准Windows和C运行时头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DLL源码文件导出的函数和变量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYLIBAPI extern <span class="meta-string">"C"</span> __declspec(dllexport)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含导出的数据结构、符号、函数、变量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyLib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将此DLL源代码文件的代码放在此处</span></span><br><span class="line"><span class="keyword">int</span> g_nResult;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> nLeft, <span class="keyword">int</span> nRight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_nResult = nLeft + nRight;</span><br><span class="line">    <span class="keyword">return</span> g_nResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DLL-库的使用（运行时动态链接-DLL）"><a href="#DLL-库的使用（运行时动态链接-DLL）" class="headerlink" title="DLL 库的使用（运行时动态链接 DLL）"></a>DLL 库的使用（运行时动态链接 DLL）</h4><p>DLL 库的使用（运行时动态链接 DLL）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A simple program that uses LoadLibrary and </span></span><br><span class="line"><span class="comment">// GetProcAddress to access myPuts from Myputs.dll. </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(__cdecl *MYPROC)</span><span class="params">(LPWSTR)</span></span>; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    HINSTANCE hinstLib; </span><br><span class="line">    MYPROC ProcAdd; </span><br><span class="line">    BOOL fFreeResult, fRunTimeLinkSuccess = FALSE; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Get a handle to the DLL module.</span></span><br><span class="line"> </span><br><span class="line">    hinstLib = LoadLibrary(TEXT(<span class="string">"MyPuts.dll"</span>)); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// If the handle is valid, try to get the function address.</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (hinstLib != <span class="literal">NULL</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        ProcAdd = (MYPROC) GetProcAddress(hinstLib, <span class="string">"myPuts"</span>); </span><br><span class="line"> </span><br><span class="line">        <span class="comment">// If the function address is valid, call the function.</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != ProcAdd) </span><br><span class="line">        &#123;</span><br><span class="line">            fRunTimeLinkSuccess = TRUE;</span><br><span class="line">            (ProcAdd) (<span class="string">L"Message sent to the DLL function\n"</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Free the DLL module.</span></span><br><span class="line"> </span><br><span class="line">        fFreeResult = FreeLibrary(hinstLib); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// If unable to call the DLL function, use an alternative.</span></span><br><span class="line">    <span class="keyword">if</span> (! fRunTimeLinkSuccess) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Message printed from executable\n"</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行库（Runtime-Library）"><a href="#运行库（Runtime-Library）" class="headerlink" title="运行库（Runtime Library）"></a>运行库（Runtime Library）</h3><h4 id="典型程序运行步骤"><a href="#典型程序运行步骤" class="headerlink" title="典型程序运行步骤"></a>典型程序运行步骤</h4><ol><li>操作系统创建进程，把控制权交给程序的入口（往往是运行库中的某个入口函数）</li><li>入口函数对运行库和程序运行环境进行初始化（包括堆、I/O、线程、全局变量构造等等）。</li><li>入口函数初始化后，调用 main 函数，正式开始执行程序主体部分。</li><li>main 函数执行完毕后，返回到入口函数进行清理工作（包括全局变量析构、堆销毁、关闭I/O等），然后进行系统调用结束进程。</li></ol><blockquote><p>一个程序的 I/O 指代程序与外界的交互，包括文件、管程、网络、命令行、信号等。更广义地讲，I/O 指代操作系统理解为 “文件” 的事物。</p></blockquote><h4 id="glibc-入口"><a href="#glibc-入口" class="headerlink" title="glibc 入口"></a>glibc 入口</h4><p><code>_start -&gt; __libc_start_main -&gt; exit -&gt; _exit</code></p><p>其中 <code>main(argc, argv, __environ)</code> 函数在 <code>__libc_start_main</code> 里执行。</p><h4 id="MSVC-CRT-入口"><a href="#MSVC-CRT-入口" class="headerlink" title="MSVC CRT 入口"></a>MSVC CRT 入口</h4><p><code>int mainCRTStartup(void)</code></p><p>执行如下操作：</p><ol><li>初始化和 OS 版本有关的全局变量。</li><li>初始化堆。</li><li>初始化 I/O。</li><li>获取命令行参数和环境变量。</li><li>初始化 C 库的一些数据。</li><li>调用 main 并记录返回值。</li><li>检查错误并将 main 的返回值返回。</li></ol><h4 id="C-语言运行库（CRT）"><a href="#C-语言运行库（CRT）" class="headerlink" title="C 语言运行库（CRT）"></a>C 语言运行库（CRT）</h4><p>大致包含如下功能：</p><ul><li>启动与退出：包括入口函数及入口函数所依赖的其他函数等。</li><li>标准函数：有 C 语言标准规定的C语言标准库所拥有的函数实现。</li><li>I/O：I/O 功能的封装和实现。</li><li>堆：堆的封装和实现。</li><li>语言实现：语言中一些特殊功能的实现。</li><li>调试：实现调试功能的代码。</li></ul><h4 id="C语言标准库（ANSI-C）"><a href="#C语言标准库（ANSI-C）" class="headerlink" title="C语言标准库（ANSI C）"></a>C语言标准库（ANSI C）</h4><p>包含：</p><ul><li>标准输入输出（stdio.h）</li><li>文件操作（stdio.h）</li><li>字符操作（ctype.h）</li><li>字符串操作（string.h）</li><li>数学函数（math.h）</li><li>资源管理（stdlib.h）</li><li>格式转换（stdlib.h）</li><li>时间/日期（time.h）</li><li>断言（assert.h）</li><li>各种类型上的常数（limits.h &amp; float.h）</li><li>变长参数（stdarg.h）</li><li>非局部跳转（setjmp.h）</li></ul><h2 id="📚-书籍"><a href="#📚-书籍" class="headerlink" title="📚 书籍"></a>📚 书籍</h2><blockquote><p><a href="https://github.com/huihut/CS-Books" target="_blank" rel="noopener">huihut/CS-Books</a>：📚 Computer Science Books 计算机技术类书籍 PDF</p></blockquote><h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><ul><li>《C++ Primer》</li><li>《Effective C++》</li><li>《More Effective C++》</li><li>《深度探索 C++ 对象模型》</li><li>《深入理解 C++11》</li><li>《STL 源码剖析》</li></ul><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><ul><li>《剑指 Offer》</li><li>《编程珠玑》</li><li>《程序员面试宝典》</li></ul><h3 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h3><ul><li>《深入理解计算机系统》</li><li>《Windows 核心编程》</li><li>《Unix 环境高级编程》</li></ul><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul><li>《Unix 网络编程》</li><li>《TCP/IP 详解》</li></ul><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><ul><li>《程序员的自我修养》</li></ul><h2 id="🔱-C-C-发展方向"><a href="#🔱-C-C-发展方向" class="headerlink" title="🔱 C/C++ 发展方向"></a>🔱 C/C++ 发展方向</h2><blockquote><p>C/C++ 发展方向甚广，包括不限于以下方向， 以下列举一些大厂校招岗位要求。</p></blockquote><h3 id="后台-服务器"><a href="#后台-服务器" class="headerlink" title="后台/服务器"></a>后台/服务器</h3><p>【后台开发】</p><ul><li>编程基本功扎实，掌握 C/C++/JAVA 等开发语言、常用算法和数据结构；</li><li>熟悉 TCP/UDP 网络协议及相关编程、进程间通讯编程；</li><li>了解 Python、Shell、Perl 等脚本语言；</li><li>了解 MYSQL 及 SQL 语言、编程，了解 NoSQL, key-value 存储原理；</li><li>全面、扎实的软件知识结构，掌握操作系统、软件工程、设计模式、数据结构、数据库系统、网络安全等专业知识；</li><li>了解分布式系统设计与开发、负载均衡技术，系统容灾设计，高可用系统等知识。</li></ul><h3 id="桌面客户端"><a href="#桌面客户端" class="headerlink" title="桌面客户端"></a>桌面客户端</h3><p>【PC 客户端开发】</p><ul><li>计算机软件相关专业本科或以上学历，热爱编程，基础扎实，理解算法和数据结构相关知识；  </li><li>熟悉 windows 操作系统的内存管理、文件系统、进程线程调度； </li><li>熟悉 MFC/windows 界面实现机制，熟练使用 VC，精通 C/C++，熟练使用 STL，以及 Windows 下网络编程经验；</li><li>熟练掌握 Windows 客户端开发、调试，有 Windows 应用软件开发经验优先；</li><li>对于创新及解决具有挑战性的问题充满激情，具有良好的算法基础及系统分析能力。</li></ul><h3 id="图形学-游戏-VR-AR"><a href="#图形学-游戏-VR-AR" class="headerlink" title="图形学/游戏/VR/AR"></a>图形学/游戏/VR/AR</h3><p>【游戏客户端开发】</p><ul><li>计算机科学/工程相关专业本科或以上学历，热爱编程，基础扎实，理解算法、数据结构、软件设计相关知识；</li><li>至少掌握一种游戏开发常用的编程语言，具 C++/C# 编程经验优先；</li><li>具游戏引擎（如 Unity、Unreal）使用经验者优先；</li><li>了解某方面的游戏客户端技术（如图形、音频、动画、物理、人工智能、网络同步）者优先考虑；</li><li>对于创新及解决具有挑战性的问题充满激情，有较强的学习能力、分析及解决问题能力，具备良好的团队合作意识；</li><li>具阅读英文技术文档能力；</li><li>热爱游戏。</li></ul><h3 id="测试开发"><a href="#测试开发" class="headerlink" title="测试开发"></a>测试开发</h3><p>【测试开发】</p><ul><li>计算机或相关专业本科及以上学历；</li><li>一至两年的 C/C++/Python 或其他计算机语言的编程经验；</li><li>具备撰写测试计划、测试用例、以及实现性能和安全等测试的能力；</li><li>具备实现自动化系统的能力；</li><li>具备定位调查产品缺陷能力、以及代码级别调试缺陷的能力；</li><li>工作主动积极，有责任心，具有良好的团队合作精神。</li></ul><h3 id="网络安全-逆向"><a href="#网络安全-逆向" class="headerlink" title="网络安全/逆向"></a>网络安全/逆向</h3><p>【安全技术】</p><ul><li>热爱互联网，对操作系统和网络安全有狂热的追求，专业不限；</li><li>熟悉漏洞挖掘、网络安全攻防技术，了解常见黑客攻击手法；  </li><li>掌握基本开发能力，熟练使用 C/C++ 语言；</li><li>对数据库、操作系统、网络原理有较好掌握；  </li><li>具有软件逆向，网络安全攻防或安全系统开发经验者优先。</li></ul><h3 id="嵌入式-物联网"><a href="#嵌入式-物联网" class="headerlink" title="嵌入式/物联网"></a>嵌入式/物联网</h3><p>【嵌入式应用开发】</p><ul><li>有良好的编程基础，熟练掌握 C/C++ 语言；</li><li>掌握操作系统、数据结构等软件开发必备知识；</li><li>具备较强的沟通理解能力及良好的团队合作意识；</li><li>有 Linux/Android 系统平台的开发经验者优先。</li></ul><h3 id="音视频-流媒体-SDK"><a href="#音视频-流媒体-SDK" class="headerlink" title="音视频/流媒体/SDK"></a>音视频/流媒体/SDK</h3><p>【音视频编解码】</p><ol><li>硕士及以上学历，计算机、信号处理、数学、信息类及相关专业和方向； </li><li>视频编解码基础扎实，熟常用的 HEVC 或 H264，有较好的数字信号处理基础； </li><li>掌握 C/C++，代码能力强, 熟悉一种汇编语言尤佳； </li><li>较强的英文文献阅读能力； </li><li>学习能力强，具有团队协作精神，有较强的抗压能力。</li></ol><h3 id="计算机视觉-机器学习"><a href="#计算机视觉-机器学习" class="headerlink" title="计算机视觉/机器学习"></a>计算机视觉/机器学习</h3><p>【计算机视觉研究】</p><ul><li>计算机、应用数学、模式识别、人工智能、自控、统计学、运筹学、生物信息、物理学/量子计算、神经科学、社会学/心理学等专业，图像处理、模式识别、机器学习相关研究方向，本科及以上，博士优先；</li><li>熟练掌握计算机视觉和图像处理相关的基本算法及应用；</li><li>较强的算法实现能力，熟练掌握 C/C++ 编程，熟悉 Shell/Python/Matlab 至少一种编程语言；</li><li>在计算机视觉、模式识别等学术会议或者期刊上发表论文、相关国际比赛获奖、及有相关专利者优先。</li></ul><h2 id="💯-复习刷题网站"><a href="#💯-复习刷题网站" class="headerlink" title="💯 复习刷题网站"></a>💯 复习刷题网站</h2><ul><li><a href="http://www.cplusplus.com/" target="_blank" rel="noopener">cplusplus</a></li><li><a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5" target="_blank" rel="noopener">cppreference</a></li><li><a href="http://www.runoob.com/cplusplus/cpp-tutorial.html" target="_blank" rel="noopener">runoob</a></li><li><a href="https://leetcode.com/" target="_blank" rel="noopener">leetcode</a> | <a href="https://leetcode-cn.com/" target="_blank" rel="noopener">leetcode-cn</a></li><li><a href="https://www.lintcode.com/" target="_blank" rel="noopener">lintcode</a></li><li><a href="https://www.nowcoder.net/" target="_blank" rel="noopener">nowcoder</a></li></ul><h2 id="📝-面试题目经验"><a href="#📝-面试题目经验" class="headerlink" title="📝 面试题目经验"></a>📝 面试题目经验</h2><ul><li><a href="https://www.nowcoder.com/discuss/205497" target="_blank" rel="noopener">牛客网 . 2020秋招面经大汇总！（岗位划分）</a></li><li><a href="https://www.nowcoder.com/discuss/197116" target="_blank" rel="noopener">牛客网 . 【备战秋招】2020届秋招备战攻略</a></li><li><a href="https://www.nowcoder.com/discuss/90907" target="_blank" rel="noopener">牛客网 . 2019校招面经大汇总！【每日更新中】</a></li><li><a href="https://www.nowcoder.com/discuss/146655" target="_blank" rel="noopener">牛客网 . 2019校招技术类岗位面经汇总【技术类】</a></li><li><a href="https://www.nowcoder.com/discuss/68802" target="_blank" rel="noopener">牛客网 . 2018校招笔试真题汇总</a></li><li><a href="https://www.nowcoder.com/discuss/12805" target="_blank" rel="noopener">牛客网 . 2017秋季校园招聘笔经面经专题汇总</a></li><li><a href="https://www.nowcoder.com/discuss/25268" target="_blank" rel="noopener">牛客网 . 史上最全2017春招面经大合集！！</a></li><li><a href="https://www.nowcoder.com/discuss/57978" target="_blank" rel="noopener">牛客网 . 面试题干货在此</a></li><li><a href="https://www.zhihu.com/question/29693016" target="_blank" rel="noopener">知乎 . 互联网求职路上，你见过哪些写得很好、很用心的面经？最好能分享自己的面经、心路历程。</a></li><li><a href="https://www.zhihu.com/question/24964987" target="_blank" rel="noopener">知乎 . 互联网公司最常见的面试算法题有哪些？</a></li><li><a href="http://blog.csdn.net/ljzcome/article/details/574158" target="_blank" rel="noopener">CSDN . 全面整理的C++面试题</a></li><li><a href="http://blog.csdn.net/Xiongchao99/article/details/74524807?locationNum=6&amp;fps=1" target="_blank" rel="noopener">CSDN . 百度研发类面试题（C++方向）</a></li><li><a href="http://blog.csdn.net/fakine/article/details/51321544" target="_blank" rel="noopener">CSDN . c++常见面试题30道</a></li><li><a href="http://blog.csdn.net/onever_say_love/article/details/51223886" target="_blank" rel="noopener">CSDN . 腾讯2016实习生面试经验（已经拿到offer)</a></li><li><a href="https://www.cnblogs.com/Y1Focus/p/6707121.html" target="_blank" rel="noopener">cnblogs . C++面试集锦( 面试被问到的问题 )</a></li><li><a href="https://www.cnblogs.com/fangyukuan/archive/2010/09/18/1829871.html" target="_blank" rel="noopener">cnblogs . C/C++ 笔试、面试题目大汇总</a></li><li><a href="https://www.cnblogs.com/LUO77/p/5771237.html" target="_blank" rel="noopener">cnblogs . 常见C++面试题及基本知识点总结（一）</a></li><li><a href="https://segmentfault.com/a/1190000003745529" target="_blank" rel="noopener">segmentfault . C++常见面试问题总结</a></li></ul><h2 id="📆-招聘时间岗位"><a href="#📆-招聘时间岗位" class="headerlink" title="📆 招聘时间岗位"></a>📆 招聘时间岗位</h2><ul><li><a href="https://www.nowcoder.com/school/schedule" target="_blank" rel="noopener">牛客网 . 2020届校招 | 2020 IT名企校招日程</a></li></ul><h2 id="👍-内推"><a href="#👍-内推" class="headerlink" title="👍 内推"></a>👍 内推</h2><ul><li><a href="https://github.com/CyC2018/Job-Recommend" target="_blank" rel="noopener">Github . CyC2018/Job-Recommend</a>：🔎 互联网内推信息（社招、校招、实习）</li><li><a href="https://github.com/amusi/AI-Job-Recommend" target="_blank" rel="noopener">Github . amusi/AI-Job-Recommend</a>：国内公司人工智能方向（含机器学习、深度学习、计算机视觉和自然语言处理）岗位的招聘信息（含全职、实习和校招）</li></ul><h2 id="👬-贡献者"><a href="#👬-贡献者" class="headerlink" title="👬 贡献者"></a>👬 贡献者</h2><p><a href="https://github.com/huihut/interview/graphs/contributors" target="_blank" rel="noopener"><img src="https://opencollective.com/interview/contributors.svg?button=false" /></a></p><h2 id="🍭-支持赞助"><a href="#🍭-支持赞助" class="headerlink" title="🍭 支持赞助"></a>🍭 支持赞助</h2><p><strong><a href="https://store.steampowered.com/app/1137770/Avalive/" target="_blank" rel="noopener">Avalive</a></strong>：一个面部捕捉的虚拟形象扮演软件。</p><h2 id="📜-License"><a href="#📜-License" class="headerlink" title="📜 License"></a>📜 License</h2><p>本仓库遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。</p><p><a href="https://github.com/huihut/interview/blob/master/LICENSE" target="_blank" rel="noopener"><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="CC BY-NC-SA 4.0"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;
        
      
    
    </summary>
    
    
      <category term="攻略" scheme="https://rhythmlian.cn/categories/%E6%94%BB%E7%95%A5/"/>
    
    
      <category term="C++" scheme="https://rhythmlian.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>修改Mac下键盘光标移动速度</title>
    <link href="https://rhythmlian.cn/2020/05/07/MacKeyboardSpeed/"/>
    <id>https://rhythmlian.cn/2020/05/07/MacKeyboardSpeed/</id>
    <published>2020-05-07T08:28:17.000Z</published>
    <updated>2020-05-07T08:48:08.434Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="默认的Mac键盘设置"><a href="#默认的Mac键盘设置" class="headerlink" title="默认的Mac键盘设置"></a>默认的Mac键盘设置</h2><p>Mac总是“自以为是”地为用户配置他们觉得最舒适的使用方案，在默认的键盘设置下，你总是会感觉长按按键时重复速度很慢，而且在开始重复动作前，会有一个起始延迟。尽管一些时候你可以依靠鼠标点击来实现光标的移动，但是在命令行等靠鼠标点击没卵用的地方，长时间的按键延迟很令人抓狂（特别是体验了Linux和Windows命令行下那种顺滑的感觉后）</p><h2 id="通过“键盘”修改配置"><a href="#通过“键盘”修改配置" class="headerlink" title="通过“键盘”修改配置"></a>通过“键盘”修改配置</h2><p><img src="https://i.loli.net/2020/05/07/EC34xkGKQ7lY5wb.png" alt="1"></p><h2 id="更快！"><a href="#更快！" class="headerlink" title="更快！"></a>更快！</h2><ol><li><p>打开“terminal”应用程序</p></li><li><p>执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write NSGlobalDomain KeyRepeat -int 1</span><br></pre></td></tr></table></figure><ul><li>注：通过“键盘配置”设置的最快速度值为2（值越小响应速度越快），0是最快的速度值，但经过测试后速度1更适合使用~</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;
        
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://rhythmlian.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="MacOS" scheme="https://rhythmlian.cn/tags/MacOS/"/>
    
  </entry>
  
  <entry>
    <title>主流性能监测工具及使用</title>
    <link href="https://rhythmlian.cn/2020/05/05/topTools/"/>
    <id>https://rhythmlian.cn/2020/05/05/topTools/</id>
    <published>2020-05-04T16:42:01.000Z</published>
    <updated>2020-05-13T13:21:16.138Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="htop"><a href="#htop" class="headerlink" title="htop"></a>htop</h2><ul><li>传统性能监测工具，在Linux于Mac OS上可以轻松安装；</li><li>运行命令：<code>htop</code></li><li>截图</li></ul><p><img src="https://i.loli.net/2020/05/05/lH4NPLOCWZInJdc.png" alt=""></p><h2 id="gtop"><a href="#gtop" class="headerlink" title="gtop"></a>gtop</h2><ul><li><a href="https://github.com/aksakalli/gtop" target="_blank" rel="noopener">Go语言编写的性能监测工具</a></li><li>运行名令：<code>gtop</code></li><li>GTOP性能监测工具是最花哨的，可以实时为CPU工作状态画折线图、为内存等画空心饼图、为网络状态画滚动柱状图等。</li></ul><h2 id="glances"><a href="#glances" class="headerlink" title="glances"></a>glances</h2><p>glances 可以为 Unix 和 Linux 性能专家提供监视和分析性能数据的功能，其中包括：</p><ul><li>CPU 使用率</li><li>内存使用情况</li><li>内核统计信息和运行队列信息</li><li>磁盘 I/O 速度、传输和读/写比率</li><li>文件系统中的可用空间</li><li>磁盘适配器</li><li>网络 I/O 速度、传输和读/写比率</li><li>页面空间和页面速度</li><li>消耗资源最多的进程</li><li>计算机信息和系统资源</li></ul><p>glances 工具可以在用户的终端上实时显示重要的系统信息，并动态地对其进行更新。这个高效的工具可以工作于任何终端屏幕。另外它并不会消耗大量的 CPU 资源，通常低于百分之二。glances 在屏幕上对数据进行显示，并且每隔两秒钟对其进行更新。您也可以自己将这个时间间隔更改为更长或更短的数值。glances 工具还可以将相同的数据捕获到一个文件，便于以后对报告进行分析和绘制图形。输出文件可以是电子表格的格式 (.csv) 或者 html 格式。</p><div class="table-container"><table><thead><tr><th>标志</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>显示网络连接速度 Byte/ 秒</td></tr><tr><td>-B @IP</td><td>host</td></tr><tr><td>-c @IP</td><td>host</td></tr><tr><td>-C file</td><td>设置配置文件默认是 /etc/glances/glances.conf</td></tr><tr><td>-d</td><td>关闭磁盘 I/O 模块</td></tr><tr><td>-e</td><td>显示传感器温度</td></tr><tr><td>-f file</td><td>设置输出文件（格式是 HTML 或者 CSV）</td></tr><tr><td>-m</td><td>关闭挂载的磁盘模块</td></tr><tr><td>-n</td><td>关闭网络模块</td></tr><tr><td>-p PORT</td><td>设置运行端口默认是 61209</td></tr><tr><td>-P password</td><td>设置客户端 / 服务器密码</td></tr><tr><td>-s</td><td>设置 glances 运行模式为服务器</td></tr><tr><td>-t sec</td><td>设置屏幕刷新的时间间隔，单位为秒，默认值为 2 秒，数值许可范围</td></tr><tr><td>-h</td><td>显示帮助信息</td></tr><tr><td>-v</td><td>显示版本信息</td></tr></tbody></table></div><ul><li>Demo<ul><li>开启性能监测的web服务：<code>glances -w -B 192.168.1.你的主机号 -b</code></li><li>开启C/S模式：<code>glances -s -B 10.0.2.15</code></li></ul></li></ul><h2 id="netdata"><a href="#netdata" class="headerlink" title="netdata!"></a><a href="https://github.com/netdata/netdata" target="_blank" rel="noopener">netdata!</a></h2><p>netdata是当下火热的性能监测工具，它允许你以非常低的资源占用率开启一个性能监控服务，绑定19999号端口，因此你可以在浏览器上查看机器工作情况。不同于glances的是，netdata应用了许多现代化技术，并且提供丰富的图表使得性能监测更加直观。</p><p>运行图：</p><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/netdata.gif" alt="1"></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;
        
      
    
    </summary>
    
    
      <category term="技术分享" scheme="https://rhythmlian.cn/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="攻略" scheme="https://rhythmlian.cn/tags/%E6%94%BB%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>C++ 应用库</title>
    <link href="https://rhythmlian.cn/2020/04/22/cpp-lib/"/>
    <id>https://rhythmlian.cn/2020/04/22/cpp-lib/</id>
    <published>2020-04-22T07:55:39.000Z</published>
    <updated>2020-04-30T17:48:07.537Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>关于 C++ 框架、库和资源的一些汇总列表，内容包括：标准库、Web应用框架、人工智能、数据库、图片处理、机器学习、日志、代码分析等。</p></blockquote><hr><h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a><strong>标准库</strong></h1><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>C++标准库</td><td>包括了STL容器，算法和函数</td></tr><tr><td>C++ Standard Library</td><td>一系列类和函数的集合，使用核心语言编写，也是C++ISO自身标准的一部分</td></tr><tr><td>Standard Template Library</td><td>标准模板库</td></tr><tr><td>C POSIX library</td><td>POSIX系统的C标准库规范</td></tr><tr><td>ISO C++ Standards Committee</td><td>C++标准委员会</td></tr></tbody></table></div><hr><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a><strong>框架</strong></h1><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>C++通用框架和库</td><td></td></tr><tr><td>Apache C++ Standard Library</td><td>一系列算法，容器，迭代器和其他基本组件的集合</td></tr><tr><td>ASL</td><td>Adobe源代码库提供了同行的评审和可移植的C++源代码库</td></tr><tr><td>Boost</td><td>大量通用C++库的集合</td></tr><tr><td>BDE</td><td>来自于彭博资讯实验室的开发环境</td></tr><tr><td>Cinder</td><td>提供专业品质创造性编码的开源开发社区</td></tr><tr><td>Cxxomfort</td><td>轻量级的，只包含头文件的库，将C++ 11的一些新特性移植到C++03中</td></tr><tr><td>Dlib</td><td>使用契约式编程和现代C++科技设计的通用的跨平台的C++库</td></tr><tr><td>EASTL</td><td>EA-STL公共部分</td></tr><tr><td>ffead-cpp</td><td>企业应用程序开发框架</td></tr><tr><td>Folly</td><td>由Facebook开发和使用的开源C++库</td></tr><tr><td>JUCE</td><td>包罗万象的C++类库，用于开发跨平台软件</td></tr><tr><td>libPhenom</td><td>用于构建高性能和高度可扩展性系统的事件框架</td></tr><tr><td>LibSourcey</td><td>用于实时的视频流和高性能网络应用程序的C++11 evented IO</td></tr><tr><td>LibU</td><td>C语言写的多平台工具库</td></tr><tr><td>Loki</td><td>C++库的设计，包括常见的设计模式和习语的实现</td></tr><tr><td>MiLi</td><td>只含头文件的小型C++库</td></tr><tr><td>openFrameworks</td><td>开发C++工具包，用于创意性编码</td></tr><tr><td>Qt</td><td>跨平台的应用程序和用户界面框架</td></tr><tr><td>Reason</td><td>跨平台的框架，使开发者能够更容易地使用Java，.Net和Python，<br />同时也满足了他们对C++性能和优势的需求</td></tr><tr><td>ROOT</td><td>具备所有功能的一系列面向对象的框架，能够非常高效地处理和分析大量的数据<br />（为欧洲原子能研究机构所用）</td></tr><tr><td>STLport</td><td>是STL具有代表性的版本</td></tr><tr><td>STXXL</td><td>用于额外的大型数据集的标准模板库</td></tr><tr><td>Ultimate++</td><td>C++跨平台快速应用程序开发框架</td></tr><tr><td>Windows Template Library</td><td>用于开发Windows应用程序和UI组件的C++库</td></tr><tr><td>Yomm11</td><td>C++11的开放multi-methods.</td></tr></tbody></table></div><hr><h1 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a><strong>人工智能</strong></h1><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>btsk</td><td>游戏行为树启动器工具</td></tr><tr><td>Evolving Objects</td><td>基于模板的，ANSI C++演化计算库，能够帮助你非常快速地编写出自己的随机优化算法</td></tr><tr><td>Neu</td><td>C++11框架，编程语言集，用于创建人工智能应用程序的多用途软件系统</td></tr><tr><td>异步事件循环</td><td></td></tr><tr><td>Boost.Asio</td><td>用于网络和底层I/O编程的跨平台的C++库</td></tr><tr><td>libev</td><td>功能齐全，高性能的时间循环，轻微地仿效libevent，<br />但是不再像libevent一样有局限性，也修复了它的一些bug。</td></tr><tr><td>libevent</td><td>事件通知库</td></tr><tr><td>libuv</td><td>跨平台异步I/O</td></tr></tbody></table></div><hr><h1 id="音频"><a href="#音频" class="headerlink" title="音频"></a><strong>音频</strong></h1><blockquote><p>音频，声音，音乐，数字化音乐库</p></blockquote><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>FMOD</td><td>易于使用的跨平台的音频引擎和音频内容的游戏创作工具</td></tr><tr><td>Maximilian</td><td>C++音频和音乐数字信号处理库</td></tr><tr><td>OpenAL</td><td>开源音频库—跨平台的音频API</td></tr><tr><td>Opus</td><td>一个完全开放的，免版税的，高度通用的音频编解码器</td></tr><tr><td>Speex</td><td>免费编解码器，为Opus所废弃</td></tr><tr><td>Tonic</td><td>C++易用和高效的音频合成</td></tr><tr><td>Vorbis</td><td>Ogg Vorbis是一种完全开放的，非专有的，免版税的通用压缩音频格式</td></tr></tbody></table></div><hr><h1 id="生态学"><a href="#生态学" class="headerlink" title="生态学"></a><strong>生态学</strong></h1><blockquote><p>生物信息，基因组学和生物技术</p></blockquote><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>libsequence</td><td>用于表示和分析群体遗传学数据的C++库</td></tr><tr><td>SeqAn</td><td>专注于生物数据序列分析的算法和数据结构</td></tr><tr><td>Vcflib</td><td>用于解析和处理VCF文件的C++库</td></tr><tr><td>Wham</td><td>直接把联想测试应用到BAM文件的基因结构变异</td></tr></tbody></table></div><hr><h1 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a><strong>压缩</strong></h1><blockquote><p>压缩和归档库</p></blockquote><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>bzip2</td><td>一个完全免费，免费专利和高质量的数据压缩</td></tr><tr><td>doboz</td><td>能够快速解压缩的压缩库</td></tr><tr><td>PhysicsFS</td><td>对各种归档提供抽象访问的库，主要用于视频游戏，设计灵感部分来自于Quake3的文件子系统</td></tr><tr><td>KArchive</td><td>用于创建，读写和操作文件档案（例如zip和 tar）的库，<br />它通过QIODevice的一系列子类，使用gzip格式，提供了透明的压缩和解压缩的数据</td></tr><tr><td>LZ4</td><td>非常快速的压缩算法</td></tr><tr><td>LZHAM</td><td>无损压缩数据库，压缩比率跟LZMA接近，但是解压缩速度却要快得多</td></tr><tr><td>LZMA</td><td>7z格式默认和通用的压缩方法</td></tr><tr><td>LZMAT</td><td>及其快速的实时无损数据压缩库</td></tr><tr><td>miniz</td><td>单一的C源文件，紧缩/膨胀压缩库，使用zlib兼容API，ZIP归档读写，PNG写方式</td></tr><tr><td>Minizip</td><td>Zlib最新bug修复，支持PKWARE磁盘跨越，AES加密和IO缓冲</td></tr><tr><td>Snappy</td><td>快速压缩和解压缩</td></tr><tr><td>ZLib</td><td>非常紧凑的数据流压缩库</td></tr><tr><td>ZZIPlib</td><td>提供ZIP归档的读权限</td></tr></tbody></table></div><hr><h1 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a><strong>并发性</strong></h1><blockquote><p>并发执行和多线程</p></blockquote><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>Boost.Compute</td><td>用于OpenCL的C++GPU计算库</td></tr><tr><td>Bolt</td><td>针对GPU进行优化的C++模板库</td></tr><tr><td>C++React</td><td>用于C++11的反应性编程库</td></tr><tr><td>Intel TBB</td><td>Intel线程构件块</td></tr><tr><td>Libclsph</td><td>基于OpenCL的GPU加速SPH流体仿真库</td></tr><tr><td>OpenCL</td><td>并行编程的异构系统的开放标准</td></tr><tr><td>OpenMP</td><td>OpenMP API</td></tr><tr><td>Thrust</td><td>类似于C++标准模板库的并行算法库</td></tr><tr><td>HPX</td><td>用于任何规模的并行和分布式应用程序的通用C++运行时系统</td></tr><tr><td>VexCL</td><td>用于OpenCL/CUDA 的C++向量表达式模板库</td></tr></tbody></table></div><hr><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a><strong>容器</strong></h1><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>C++ B-tree</td><td>基于B树数据结构，实现命令内存容器的模板库</td></tr><tr><td>Hashmaps</td><td>C++中开放寻址哈希表算法的实现</td></tr></tbody></table></div><hr><h1 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a><strong>密码学</strong></h1><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>Bcrypt</td><td>一个跨平台的文件加密工具，加密文件可以移植到所有可支持的操作系统和处理器中。</td></tr><tr><td>BeeCrypt</td><td></td></tr><tr><td>Botan</td><td>C++加密库</td></tr><tr><td>Crypto++</td><td>一个有关加密方案的免费的C++库</td></tr><tr><td>GnuPG</td><td>OpenPGP标准的完整实现</td></tr><tr><td>GnuTLS</td><td>实现了SSL，TLS和DTLS协议的安全通信库</td></tr><tr><td>Libgcrypt</td><td></td></tr><tr><td>libmcrypt</td><td></td></tr><tr><td>LibreSSL</td><td>免费的SSL/TLS协议，属于2014OpenSSL的一个分支</td></tr><tr><td>LibTomCrypt</td><td>一个非常全面的，模块化的，可移植的加密工具</td></tr><tr><td>libsodium</td><td>基于NaCI的加密库，固执己见，容易使用</td></tr><tr><td>Nettle</td><td>底层的加密库</td></tr><tr><td>OpenSSL</td><td>一个强大的，商用的，功能齐全的，开放源代码的加密库。</td></tr><tr><td>TinyAES128inC</td><td>用C实现的一个小巧，可移植的实现了AES128ESB的加密算法</td></tr></tbody></table></div><hr><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><strong>数据库</strong></h1><blockquote><p>数据库，SQL服务器，ODBC驱动程序和工具</p></blockquote><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>hiberlite</td><td>用于Sqlite3的C++对象关系映射</td></tr><tr><td>Hiredis</td><td>用于Redis数据库的很简单的C客户端库</td></tr><tr><td>LevelDB</td><td>快速键值存储库</td></tr><tr><td>LMDB</td><td>符合数据库四大基本元素的嵌入键值存储</td></tr><tr><td>MySQL++</td><td>封装了MySql的CAPI的C++包装器</td></tr><tr><td>RocksDB</td><td>来自Facebook的嵌入键值的快速存储</td></tr><tr><td>SQLite</td><td>一个完全嵌入式的，功能齐全的关系数据库，只有几百KB，可以正确包含到你的项目中。</td></tr></tbody></table></div><hr><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a><strong>调试</strong></h1><blockquote><p>调试库， 内存和资源泄露检测，单元测试</p></blockquote><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>Boost.Test</td><td>Boost测试库</td></tr><tr><td>Catch</td><td>一个很时尚的，C++原生的框架，只包含头文件，用于单元测试，测试驱动开发和行为驱动开发。</td></tr><tr><td>CppUnit</td><td>由JUnit移植过来的C++测试框架</td></tr><tr><td>CTest</td><td>CMake测试驱动程序</td></tr><tr><td>googletest</td><td>谷歌C++测试框架</td></tr><tr><td>ig-debugheap</td><td>用于跟踪内存错误的多平台调试堆</td></tr><tr><td>libtap</td><td>用C语言编写测试</td></tr><tr><td>MemTrack</td><td>用于C++跟踪内存分配</td></tr><tr><td>microprofile</td><td>跨平台的网络试图分析器</td></tr><tr><td>minUnit</td><td>使用C写的迷你单元测试框架，只使用了两个宏</td></tr><tr><td>Remotery</td><td>用于web视图的单一C文件分析器</td></tr><tr><td>UnitTest++</td><td>轻量级的C++单元测试框架</td></tr></tbody></table></div><hr><h1 id="游戏引擎"><a href="#游戏引擎" class="headerlink" title="游戏引擎"></a><strong>游戏引擎</strong></h1><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>Cocos2d-x</td><td>一个跨平台框架，用于构建2D游戏，互动图书，演示和其他图形应用程序。</td></tr><tr><td>Grit</td><td>社区项目，用于构建一个免费的游戏引擎，实现开放的世界3D游戏。</td></tr><tr><td>Irrlicht</td><td>C++语言编写的开源高性能的实时#D引擎</td></tr><tr><td>Polycode</td><td>C++实现的用于创建游戏的开源框架（与Lua绑定）。</td></tr></tbody></table></div><hr><h1 id="图形用户界面"><a href="#图形用户界面" class="headerlink" title="图形用户界面"></a><strong>图形用户界面</strong></h1><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>CEGUI</td><td>很灵活的跨平台GUI库</td></tr><tr><td>FLTK</td><td>快速，轻量级的跨平台的C++GUI工具包。</td></tr><tr><td>GTK+</td><td>用于创建图形用户界面的跨平台工具包</td></tr><tr><td>gtkmm</td><td>用于受欢迎的GUI库GTK+的官方C++接口。</td></tr><tr><td>imgui</td><td>拥有最小依赖关系的立即模式图形用户界面</td></tr><tr><td>libRocket</td><td>libRocket是一个C++HTML/CSS游戏接口中间件</td></tr><tr><td>MyGUI</td><td>快速，灵活，简单的GUI</td></tr><tr><td>Ncurses</td><td>终端用户界面</td></tr><tr><td>QCustomPlot</td><td>没有更多依赖关系的Qt绘图控件</td></tr><tr><td>Qwt</td><td>用户与技术应用的Qt控件</td></tr><tr><td>QwtPlot3D</td><td>功能丰富的基于Qt/OpenGL的C++编程库，本质上提供了一群3D控件</td></tr><tr><td>OtterUI</td><td>OtterUI是用于嵌入式系统和互动娱乐软件的用户界面开发解决方案</td></tr><tr><td>PDCurses</td><td>包含源代码和预编译库的公共图形函数库</td></tr><tr><td>wxWidgetsC++库</td><td>允许开发人员使用一个代码库可以为widows，MacOSX，Linux和其他平台创建应用程序</td></tr></tbody></table></div><hr><h1 id="图形"><a href="#图形" class="headerlink" title="图形"></a><strong>图形</strong></h1><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>bgfx</td><td>跨平台的渲染库</td></tr><tr><td>Cairo</td><td>支持多种输出设备的2D图形库</td></tr><tr><td>Horde3D</td><td>一个小型的3D渲染和动画引擎</td></tr><tr><td>magnumC++11和OpenGL2D/3D</td><td>图形引擎</td></tr><tr><td>Ogre3D</td><td>用C++编写的一个面向场景，实时，灵活的3D渲染引擎（并非游戏引擎）</td></tr><tr><td>OpenSceneGraph</td><td>具有高性能的开源3D图形工具包</td></tr><tr><td>Panda3D</td><td>用于3D渲染和游戏开发的框架，用Python和C++编写</td></tr><tr><td>Skia</td><td>用于绘制文字，图形和图像的完整的2D图形库</td></tr><tr><td>urho3d</td><td>跨平台的渲染和游戏引擎。</td></tr></tbody></table></div><hr><h1 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a><strong>图像处理</strong></h1><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>Boost.GIL</td><td>通用图像库</td></tr><tr><td>CImg</td><td>用于图像处理的小型开源C++工具包</td></tr><tr><td>CxImage</td><td>用于加载，保存，显示和转换的图像处理和转换库，可以处理的图片格式包括BMP,JPEG,GIF,PNG,TIFF,MNG,ICO,PCX,TGA,WMF,WBMP,JBG,J2K。</td></tr><tr><td>FreeImage</td><td>开源库，支持现在多媒体应用所需的通用图片格式和其他格式。</td></tr><tr><td>GDCM</td><td>GrassrootsDICOM库</td></tr><tr><td>ITK</td><td>跨平台的开源图像分析系统</td></tr><tr><td>Magick++</td><td>ImageMagick程序的C++接口</td></tr><tr><td>MagickWnd</td><td>ImageMagick程序的C++接口</td></tr><tr><td>OpenCV</td><td>开源计算机视觉类库</td></tr><tr><td>tesseract-ocr</td><td>OCR引擎</td></tr><tr><td>VIGRA</td><td>用于图像分析通用C++计算机视觉库</td></tr><tr><td>VTK</td><td>用于3D计算机图形学，图像处理和可视化的开源免费软件系统。</td></tr></tbody></table></div><hr><h1 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a><strong>国际化</strong></h1><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>gettext</td><td>GNU`gettext’</td></tr><tr><td>IBMICU</td><td>提供Unicode和全球化支持的C、C++和Java库</td></tr><tr><td>libiconv</td><td>用于不同字符编码之间的编码转换库</td></tr></tbody></table></div><hr><h1 id="Jason"><a href="#Jason" class="headerlink" title="Jason"></a><strong>Jason</strong></h1><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>frozen</td><td>C/C++的Jason解析生成器</td></tr><tr><td>Jansson</td><td>进行编解码和处理Jason数据的C语言库</td></tr><tr><td>jbson</td><td>C++14中构建和迭代BSONdata,和Json文档的库</td></tr><tr><td>JeayeSON</td><td>非常健全的C++JSON库，只包含头文件</td></tr><tr><td>JSON++</td><td>C++JSON解析器</td></tr><tr><td>json-parser</td><td>用可移植的ANSIC编写的JSON解析器，占用内存非常少</td></tr><tr><td>json11</td><td>一个迷你的C++11JSON库</td></tr><tr><td>jute</td><td>非常简单的C++JSON解析器</td></tr><tr><td>ibjson</td><td>C语言中的JSON解析和打印库，很容易和任何模型集成。</td></tr><tr><td>libjson</td><td>轻量级的JSON库</td></tr><tr><td>PicoJSON</td><td>C++中JSON解析序列化，只包含头文件</td></tr><tr><td>qt-json</td><td>用于JSON数据和QVariant层次间的相互解析的简单类</td></tr><tr><td>QJson</td><td>将JSON数据映射到QVariant对象的基于Qt的库</td></tr><tr><td>RapidJSON</td><td>用于C++的快速JSON解析生成器，包含SAX和DOM两种风格的API</td></tr><tr><td>YAJL</td><td>C语言中快速流JSON解析库</td></tr></tbody></table></div><hr><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a><strong>日志</strong></h1><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>Boost.Log</td><td>设计非常模块化，并且具有扩展性</td></tr><tr><td>easyloggingpp</td><td>C++日志库，只包含单一的头文件。</td></tr><tr><td>Log4cpp</td><td>一系列C++类库，灵活添加日志到文件，系统日志，IDSA和其他地方。</td></tr><tr><td>templog</td><td>轻量级C++库，可以添加日志到你的C++应用程序中</td></tr></tbody></table></div><hr><h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a><strong>机器学习</strong></h1><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>Caffe</td><td>快速的神经网络框架</td></tr><tr><td>CCV</td><td>以C语言为核心的现代计算机视觉库</td></tr><tr><td>mlpack</td><td>可扩展的C++机器学习库</td></tr><tr><td>OpenCV</td><td>开源计算机视觉库</td></tr><tr><td>Recommender</td><td>使用协同过滤进行产品推荐/建议的C语言库。</td></tr><tr><td>SHOGUN</td><td>Shogun机器学习工具</td></tr><tr><td>sofia-ml</td><td>用于机器学习的快速增量算法套件</td></tr></tbody></table></div><hr><h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a><strong>数学</strong></h1><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>Armadillo</td><td>高质量的C++线性代数库，速度和易用性做到了很好的平衡。语法和MatlAB很相似</td></tr><tr><td>blaze</td><td>高性能的C++数学库，用于密集和稀疏算法。</td></tr><tr><td>ceres-solver</td><td>来自谷歌的C++库，用于建模和解决大型复杂非线性最小平方问题。</td></tr><tr><td>CGal</td><td>高效，可靠的集合算法集合</td></tr><tr><td>cml</td><td>用于游戏和图形的免费C++数学库</td></tr><tr><td>Eigen</td><td>高级C++模板头文件库，包括线性代数，矩阵，向量操作，数值解决和其他相关的算法。</td></tr><tr><td>GMTL</td><td>数学图形模板库是一组广泛实现基本图形的工具。</td></tr><tr><td>GMP</td><td>用于个高精度计算的C/C++库，处理有符号整数，有理数和浮点数。</td></tr></tbody></table></div><hr><h1 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a><strong>多媒体</strong></h1><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>GStreamer</td><td>构建媒体处理组件图形的库</td></tr><tr><td>LIVE555StreamingMedia</td><td>使用开放标准协议(RTP/RTCP,RTSP,SIP)的多媒体流库</td></tr><tr><td>libVLC</td><td>libVLC(VLCSDK)媒体框架</td></tr><tr><td>QtAv</td><td>基于Qt和FFmpeg的多媒体播放框架，能够帮助你轻而易举地编写出一个播放器</td></tr><tr><td>SDL</td><td>简单直控媒体层</td></tr><tr><td>SFML</td><td>快速，简单的多媒体库</td></tr></tbody></table></div><hr><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a><strong>网络</strong></h1><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>ACE</td><td>C++面向对象网络变成工具包</td></tr><tr><td>Boost.Asio</td><td>用于网络和底层I/O编程的跨平台的C++库</td></tr><tr><td>Casablanca</td><td>C++RESTSDK</td></tr><tr><td>cpp-netlib</td><td>高级网络编程的开源库集合</td></tr><tr><td>Dyad.c</td><td>C语言的异步网络</td></tr><tr><td>libcurl</td><td>多协议文件传输库</td></tr><tr><td>Mongoose</td><td>非常轻量级的网络服务器</td></tr><tr><td>Muduo</td><td>用于Linux多线程服务器的C++非阻塞网络库</td></tr><tr><td>net_skeleton</td><td>C/C++的TCP客户端/服务器库</td></tr><tr><td>nope.c</td><td>基于C语言的超轻型软件平台，用于可扩展的服务器端和网络应用。对于C编程人员，可以考虑node.js</td></tr><tr><td>Onion</td><td>C语言HTTP服务器库，其设计为轻量级，易使用。</td></tr><tr><td>POCO</td><td>用于构建网络和基于互联网应用程序的C++类库，可以运行在桌面，服务器，移动和嵌入式系统。</td></tr><tr><td>RakNet</td><td>为游戏开发人员提供的跨平台的开源C++网络引擎。</td></tr><tr><td>Tufo</td><td>用于Qt之上的C++构建的异步Web框架。</td></tr><tr><td>WebSocket++</td><td>基于C++/BoostAiso的websocket客户端/服务器库</td></tr><tr><td>ZeroMQ</td><td>高速，模块化的异步通信库</td></tr></tbody></table></div><hr><h1 id="物理学"><a href="#物理学" class="headerlink" title="物理学"></a><strong>物理学</strong></h1><blockquote><p>动力学仿真引擎</p></blockquote><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>Box2D</td><td>2D的游戏物理引擎。</td></tr><tr><td>Bullet</td><td>3D的游戏物理引擎。</td></tr><tr><td>Chipmunk</td><td>快速，轻量级的2D游戏物理库</td></tr><tr><td>LiquidFun</td><td>2D的游戏物理引擎</td></tr><tr><td>ODE</td><td>开放动力学引擎-开源，高性能库，模拟刚体动力学。</td></tr><tr><td>ofxBox2d</td><td>Box2D开源框架包装器。</td></tr><tr><td>Simbody</td><td>高性能C++多体动力学/物理库，模拟关节生物力学和机械系统，像车辆，机器人和人体骨骼。</td></tr></tbody></table></div><hr><h1 id="机器人学"><a href="#机器人学" class="headerlink" title="机器人学"></a><strong>机器人学</strong></h1><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>MOOS-IvP</td><td>一组开源C++模块，提供机器人平台的自主权，尤其是自主的海洋车辆。</td></tr><tr><td>MRPT</td><td>移动机器人编程工具包</td></tr><tr><td>PCL</td><td>点云库是一个独立的，大规模的开放项目，用于2D/3D图像和点云处理。</td></tr><tr><td>RoboticsLibrary(RL)</td><td>一个独立的C++库，包括机器人动力学，运动规划和控制。</td></tr><tr><td>RobWork</td><td>一组C++库的集合，用于机器人系统的仿真和控制。</td></tr><tr><td>ROS</td><td>机器人操作系统，提供了一些库和工具帮助软件开发人员创建机器人应用程序。</td></tr></tbody></table></div><hr><h1 id="科学计算"><a href="#科学计算" class="headerlink" title="科学计算"></a><strong>科学计算</strong></h1><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>FFTW:用一维或者多维计算DFT的C语言库。</td><td></td></tr><tr><td>GSL</td><td>GNU科学库。</td></tr></tbody></table></div><hr><h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a><strong>脚本</strong></h1><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>ChaiScript</td><td>用于C++的易于使用的嵌入式脚本语言。</td></tr><tr><td>Lua</td><td>用于配置文件和基本应用程序脚本的小型快速脚本引擎。</td></tr><tr><td>luacxx</td><td>用于创建Lua绑定的C++11API</td></tr><tr><td>SWIG</td><td>一个可以让你的C++代码链接到JavaScript，Perl，PHP，Python，Tcl和Ruby的包装器/接口生成器</td></tr><tr><td>V7</td><td>嵌入式的JavaScript引擎。</td></tr><tr><td>V8</td><td>谷歌的快速JavaScript引擎，可以被嵌入到任何C++应用程序中。</td></tr></tbody></table></div><hr><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a><strong>序列化</strong></h1><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>Cap’nProto</td><td>快速数据交换格式和RPC系统。</td></tr><tr><td>cereal</td><td>C++11序列化库</td></tr><tr><td>FlatBuffers</td><td>内存高效的序列化库</td></tr><tr><td>MessagePack</td><td>C/C++的高效二进制序列化库，例如JSON</td></tr><tr><td>protobuf</td><td>协议缓冲，谷歌的数据交换格式。</td></tr><tr><td>protobuf-c</td><td>C语言的协议缓冲实现</td></tr><tr><td>SimpleBinaryEncoding</td><td>用于低延迟应用程序的对二进制格式的应用程序信息的编码和解码。</td></tr><tr><td>Thrift</td><td>高效的跨语言IPC/RPC，用于C++，Java，Python，PHP，C#和其它多种语言中，最初由Twitter开发。</td></tr></tbody></table></div><hr><h1 id="视频"><a href="#视频" class="headerlink" title="视频"></a><strong>视频</strong></h1><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>libvpx</td><td>VP8/VP9编码解码SDK</td></tr><tr><td>FFmpeg</td><td>一个完整的，跨平台的解决方案，用于记录，转换视频和音频流。</td></tr><tr><td>libde265</td><td>开放的h.265视频编解码器的实现。</td></tr><tr><td>OpenH264</td><td>开源H.364编解码器。</td></tr><tr><td>Theora</td><td>免费开源的视频压缩格式。</td></tr></tbody></table></div><hr><h1 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a><strong>虚拟机</strong></h1><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>CarpVM</td><td>C中有趣的VM，让我们一起来看看这个。</td></tr><tr><td>MicroPython</td><td>旨在实现单片机上Python3.x的实现</td></tr><tr><td>TinyVM</td><td>用纯粹的ANSIC编写的小型，快速，轻量级的虚拟机。</td></tr></tbody></table></div><hr><h1 id="Web应用框架"><a href="#Web应用框架" class="headerlink" title="Web应用框架"></a><strong>Web应用框架</strong></h1><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>Civetweb</td><td>提供易于使用，强大的，C/C++嵌入式Web服务器，带有可选的CGI，SSL和Lua支持。</td></tr><tr><td>CppCMS</td><td>免费高性能的Web开发框架（不是CMS）.</td></tr><tr><td>Crow</td><td>一个C++微型web框架（灵感来自于PythonFlask）</td></tr><tr><td>Kore</td><td>使用C语言开发的用于web应用程序的超快速和灵活的web服务器/框架。</td></tr><tr><td>libOnion</td><td>轻量级的库，帮助你使用C编程语言创建web服务器。</td></tr><tr><td>QDjango</td><td>使用C++编写的，基于Qt库的web框架，试图效仿DjangoAPI，因此得此名。</td></tr><tr><td>Wt</td><td>开发Web应用的C++库。</td></tr></tbody></table></div><hr><h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a><strong>XML</strong></h1><blockquote><p>XML就是个垃圾，xml的解析很烦人，对于计算机它也是个灾难。这种糟糕的东西完全没有存在的理由了。-Linus Torvalds</p></blockquote><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>Expat</td><td>用C语言编写的xml解析库</td></tr><tr><td>Libxml2</td><td>Gnome的xmlC解析器和工具包</td></tr><tr><td>libxml++</td><td>C++的xml解析器</td></tr><tr><td>PugiXML</td><td>用于C++的，支持XPath的轻量级，简单快速的XML解析器。</td></tr><tr><td>RapidXml</td><td>试图创建最快速的XML解析器，同时保持易用性，可移植性和合理的W3C兼容性。</td></tr><tr><td>TinyXML</td><td>简单小型的C++XML解析器，可以很容易地集成到其它项目中。</td></tr><tr><td>TinyXML2</td><td>简单快速的C++CML解析器，可以很容易集成到其它项目中。</td></tr><tr><td>TinyXML++</td><td>TinyXML的一个全新的接口，使用了C++的许多许多优势，模板，异常和更好的异常处理。</td></tr><tr><td>Xerces-C++</td><td>用可移植的C++的子集编写的XML验证解析器。</td></tr></tbody></table></div><hr><h1 id="多项混杂"><a href="#多项混杂" class="headerlink" title="多项混杂"></a><strong>多项混杂</strong></h1><blockquote><p>一些有用的库或者工具，但是不适合上面的分类，或者还没有分类。</p></blockquote><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>C++Format</td><td>C++的小型，安全和快速格式化库</td></tr><tr><td>casacore</td><td>从aips++派生的一系列C++核心库</td></tr><tr><td>cxx-prettyprint</td><td>用于C++容器的打印库</td></tr><tr><td>DynaPDF</td><td>易于使用的PDF生成库</td></tr><tr><td>gcc-poison</td><td>帮助开发人员禁止应用程序中的不安全的C/C++函数的简单的头文件。</td></tr><tr><td>googlemock</td><td>编写和使用C++模拟类的库</td></tr><tr><td>HTTPParser</td><td>C的http请求/响应解析器</td></tr><tr><td>libcpuid</td><td>用于x86CPU检测盒特征提取的小型C库</td></tr><tr><td>libevil</td><td>许可证管理器</td></tr><tr><td>libusb</td><td>允许移动访问USB设备的通用USB库</td></tr><tr><td>PCRE</td><td>正则表达式C库，灵感来自于Perl中正则表达式的功能。</td></tr><tr><td>RemoteCallFramework</td><td>C++的进程间通信框架。</td></tr><tr><td>Scintilla</td><td>开源的代码编辑控件</td></tr><tr><td>SerialCommunicationLibrary</td><td>C++语言编写的跨平台，串口库。</td></tr><tr><td>SDS</td><td>C的简单动态字符串库</td></tr><tr><td>SLDR</td><td>超轻的DNS解析器</td></tr><tr><td>SLRE</td><td>超轻的正则表达式库</td></tr><tr><td>Stage</td><td>移动机器人模拟器</td></tr><tr><td>VarTypes</td><td>C++/Qt4功能丰富，面向对象的管理变量的框架。</td></tr><tr><td>ZBar</td><td>‘条形码扫描器’库，可以扫描照片，图片和视频流中的条形码，并返回结果。</td></tr><tr><td>CppVerbalExpressions</td><td>易于使用的C++正则表达式</td></tr><tr><td>QtVerbalExpressions</td><td>基于C++VerbalExpressions库的Qt库</td></tr><tr><td>PHP-CPP</td><td>使用C++来构建PHP扩展的库</td></tr><tr><td>BetterString</td><td>C的另一个字符串库，功能更丰富，但是没有缓冲溢出问题，还包含了一个C++包装器。</td></tr></tbody></table></div><hr><h1 id="软件"><a href="#软件" class="headerlink" title="软件"></a><strong>软件</strong></h1><p>用于创建开发环境的软件</p><hr><h1 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a><strong>编译器</strong></h1><blockquote><p>C/C++编译器列表</p></blockquote><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>Clang</td><td>由苹果公司开发的</td></tr><tr><td>GCC</td><td>GNU编译器集合</td></tr><tr><td>IntelC++Compiler</td><td>由英特尔公司开发</td></tr><tr><td>LLVM</td><td>模块化和可重用编译器和工具链技术的集合</td></tr><tr><td>MicrosoftVisualC++</td><td>MSVC，由微软公司开发</td></tr><tr><td>OpenWatCom</td><td>Watcom，C，C++和Fortran交叉编译器和工具</td></tr><tr><td>TCC</td><td>轻量级的C语言编译器</td></tr></tbody></table></div><hr><h1 id="在线编译器"><a href="#在线编译器" class="headerlink" title="在线编译器"></a><strong>在线编译器</strong></h1><blockquote><p>在线C/C++编译器列表</p></blockquote><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>codepad</td><td>在线编译器/解释器，一个简单的协作工具</td></tr><tr><td>CodeTwist</td><td>一个简单的在线编译器/解释器，你可以粘贴的C,C++或者Java代码，在线执行并查看结果</td></tr><tr><td>coliru</td><td>在线编译器/shell，支持各种C++编译器</td></tr><tr><td>CompilerExplorer</td><td>交互式编译器，可以进行汇编输出</td></tr><tr><td>CompileOnline</td><td>Linux上在线编译和执行C++程序</td></tr><tr><td>Ideone</td><td>一个在线编译器和调试工具，允许你在线编译源代码并执行，支持60多种编程语言。</td></tr></tbody></table></div><hr><h1 id="调试器"><a href="#调试器" class="headerlink" title="调试器"></a><strong>调试器</strong></h1><blockquote><p>C/C++调试器列表</p></blockquote><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>Comparisonofdebuggers</td><td>来自维基百科的调试器列表</td></tr><tr><td>GDB</td><td>GNU调试器</td></tr><tr><td>Valgrind</td><td>内存调试，内存泄露检测，性能分析工具。</td></tr></tbody></table></div><hr><h1 id="集成开发环境（IDE）"><a href="#集成开发环境（IDE）" class="headerlink" title="集成开发环境（IDE）"></a><strong>集成开发环境（IDE）</strong></h1><blockquote><p>C/C++集成开发环境列表</p></blockquote><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>AppCode</td><td>构建与JetBrains’IntelliJIDEA平台上的用于Objective-C，C,C++，Java和Java开发的集成开发环境</td></tr><tr><td>CLion</td><td>来自JetBrains的跨平台的C/C++的集成开发环境</td></tr><tr><td>Code::Blocks</td><td>免费C，C++和Fortran的集成开发环境</td></tr><tr><td>CodeLite</td><td>另一个跨平台的免费的C/C++集成开发环境</td></tr><tr><td>Dev-C++</td><td>可移植的C/C++/C++11集成开发环境</td></tr><tr><td>EclipseCDT</td><td>基于Eclipse平台的功能齐全的C和C++集成开发环境</td></tr><tr><td>Geany</td><td>轻量级的快速，跨平台的集成开发环境。</td></tr><tr><td>IBMVisualAge</td><td>来自IBM的家庭计算机集成开发环境。</td></tr><tr><td>Irony-mode</td><td>由libclang驱动的用于Emacs的C/C++微模式</td></tr><tr><td>KDevelop</td><td>免费开源集成开发环境</td></tr><tr><td>MicrosoftVisualStudio</td><td>来自微软的集成开发环境</td></tr><tr><td>NetBeans</td><td>主要用于Java开发的的集成开发环境，也支持其他语言，尤其是PHP，C/C++和HTML5。</td></tr><tr><td>QtCreator</td><td>跨平台的C++，Javascript和QML集成开发环境，也是QtSDK的一部分。</td></tr><tr><td>rtags</td><td>C/C++的客户端服务器索引，用于跟基于clang的emacs的集成</td></tr><tr><td>Xcode</td><td>由苹果公司开发</td></tr><tr><td>YouCompleteMe</td><td>一个用于Vim的根据你敲的代码快速模糊搜索并进行代码补全的引擎。</td></tr></tbody></table></div><hr><h1 id="构建系统"><a href="#构建系统" class="headerlink" title="构建系统"></a><strong>构建系统</strong></h1><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>Bear</td><td>用于为clang工具生成编译数据库的工具</td></tr><tr><td>Biicode</td><td>基于文件的简单依赖管理器。</td></tr><tr><td>CMake</td><td>跨平台的免费开源软件用于管理软件使用独立编译的方法进行构建的过程。</td></tr><tr><td>CPM</td><td>基于CMake和Git的C++包管理器</td></tr><tr><td>FASTBuild</td><td>高性能，开源的构建系统，支持高度可扩展性的编译，缓冲和网络分布。</td></tr><tr><td>Ninja</td><td>专注于速度的小型构建系统</td></tr><tr><td>Scons</td><td>使用Pythonscipt配置的软件构建工具</td></tr><tr><td>tundra</td><td>高性能的代码构建系统，甚至对于非常大型的软件项目，也能提供最好的增量构建次数。</td></tr><tr><td>tup</td><td>基于文件的构建系统，用于后台监控变化的文件。</td></tr></tbody></table></div><hr><h1 id="静态代码分析"><a href="#静态代码分析" class="headerlink" title="静态代码分析"></a><strong>静态代码分析</strong></h1><blockquote><p>提高质量，减少瑕疵的代码分析工具列表</p></blockquote><div class="table-container"><table><thead><tr><th>库</th><th>说明</th></tr></thead><tbody><tr><td>Cppcheck</td><td>静态C/C++代码分析工具</td></tr><tr><td>include-what-you-use</td><td>使用clang进行代码分析的工具，可以#include在C和C++文件中。</td></tr><tr><td>OCLint</td><td>用于C，C++和Objective-C的静态源代码分析工具，用于提高质量，减少瑕疵。</td></tr><tr><td>ClangStaticAnalyzer</td><td>查找C，C++和Objective-C程序bug的源代码分析工具</td></tr><tr><td>Listoftoolsforstaticcodeanalysis</td><td>来自维基百科的静态代码分析工具列表</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;
        
      
    
    </summary>
    
    
      <category term="攻略" scheme="https://rhythmlian.cn/categories/%E6%94%BB%E7%95%A5/"/>
    
    
      <category term="C++" scheme="https://rhythmlian.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>使用NATAPP内网穿透！</title>
    <link href="https://rhythmlian.cn/2020/04/14/nat/"/>
    <id>https://rhythmlian.cn/2020/04/14/nat/</id>
    <published>2020-04-13T16:58:39.000Z</published>
    <updated>2020-04-13T17:47:28.060Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><h3 id="什么是内网穿透？"><a href="#什么是内网穿透？" class="headerlink" title="什么是内网穿透？"></a>什么是内网穿透？</h3><p>&emsp;【百度百科】：内网穿透，即NAT穿透，网络连接时术语，<a href="https://baike.baidu.com/item/计算机/140338" target="_blank" rel="noopener">计算机</a>是局域网内时，外网与内网的计算机节点需要连接通信，有时就会出现不支持内网穿透。就是说<a href="https://baike.baidu.com/item/映射端口" target="_blank" rel="noopener">映射端口</a>，能让外网的电脑找到处于内网的电脑，提高下载速度。不管是内网穿透还是其他类型的网络穿透，都是网络穿透的统一方法来研究和解决。</p><p>&emsp;通俗来讲，就是你可以将你本地的http服务映射到公网上，这样你就可以办到许多骚操作：</p><ul><li>临时挂载个测试网站供大家访问</li><li>开启文件服务，向某人分享文件（私密且带宽受自己控制）</li><li><p>甚至你可以利用这个双向的隧道操作服务器~</p></li><li><p>…</p></li></ul><h3 id="有哪些内网穿透工具？"><a href="#有哪些内网穿透工具？" class="headerlink" title="有哪些内网穿透工具？"></a>有哪些内网穿透工具？</h3><ol><li><a href="https://u.tools" target="_blank" rel="noopener">utools</a></li><li><a href="https://ngrok.com/" target="_blank" rel="noopener">Ngrok</a></li><li><a href="https://natapp.cn/" target="_blank" rel="noopener">NATAPP</a></li></ol><p>&emsp;Ngrok我暂时还没用过，剩下两款中：</p><ul><li>utools功能一般但是完全免费，使用utools的域名，带宽约1M；</li><li>NATAPP完全免费，但是可以选择付费方案，支持绑定自定义域名，带宽最高可调至100M；</li></ul><h2 id="NATAPP部署"><a href="#NATAPP部署" class="headerlink" title="NATAPP部署"></a>NATAPP部署</h2><h3 id="如何在Mac上配置NATAPP？"><a href="#如何在Mac上配置NATAPP？" class="headerlink" title="如何在Mac上配置NATAPP？"></a>如何在Mac上配置NATAPP？</h3><ol><li>进入官网注册，创建一条免费隧道；并下载对应的zip压缩包，解压后，会生成一个<code>natapp</code>的可执行文件。</li><li><code>mv natapp /usr/local/bin/</code> 将它挪到PATH包含的某条路径下</li><li>调整<code>.bashrc</code>或者<code>.zshrc</code>，追加下面内容：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> natapp=<span class="string">"natapp -authtoken=你的免费token"</span></span><br><span class="line"><span class="comment">#如果你有付费隧道</span></span><br><span class="line"><span class="built_in">alias</span> natapp-hk=<span class="string">"natapp -authtoken=你的香港主机付费token"</span></span><br></pre></td></tr></table></figure><p> <strong>其他系统请自行百度</strong></p><h3 id="如何开启文件共享？"><a href="#如何开启文件共享？" class="headerlink" title="如何开启文件共享？"></a>如何开启文件共享？</h3><ol><li>本质上，你需要先占用<code>127.0.0.1:你的端口</code>来开启本地的http服务（<strong>切记使用创建隧道时约定的ip及端口号</strong>）<ul><li>有许多种方式开启本地的http服务，比如：</li><li><code>sudo qs -ftp</code></li><li><code>hexo s</code></li><li>…</li></ul></li><li>如果你能在本地访问你的http服务，那么开始运行<code>natapp</code>或者<code>natapp-hk</code></li></ol><p><img src="https://i.loli.net/2020/04/14/yB85vIEtLTJPz4K.png" alt=""></p><ul><li>此时，你在<code>127.0.0.1:80</code>端口开启的http服务将被映射到<code>http://n6vit4.natappfree.cc</code>上。</li><li>（至于http服务具体做什么，你可以按自己的喜好来。）</li></ul><ol><li>如想开启文件共享，再开一个终端，在想要共享内容的文件夹下运行<code>sudo qs -ftp</code>即可。（什么是qs？<a href="https://rhythmlian.cn/2020/02/14/QuickStart-Rhy/">QuickStart-Rhy</a> ）</li></ol><h4 id="运行成功："><a href="#运行成功：" class="headerlink" title="运行成功："></a>运行成功：</h4><p><img src="https://i.loli.net/2020/04/14/nAYIgDkoHiN9dwm.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;
        
      
    
    </summary>
    
    
      <category term="技术分享" scheme="https://rhythmlian.cn/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="随笔" scheme="https://rhythmlian.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>小王子读后感</title>
    <link href="https://rhythmlian.cn/2020/04/04/kingson/"/>
    <id>https://rhythmlian.cn/2020/04/04/kingson/</id>
    <published>2020-04-04T12:15:45.000Z</published>
    <updated>2020-09-01T11:37:27.329Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;起初我比较好奇是怎样的一本书被命名成了”小王子”，我花了若干个小时的时间通篇读了下来，发现作者是以描写异域星球小王子来描写自己的成长历程和人生感悟。我也从书中引发了如下若干方面的领悟。</p><h2 id="折翼的梦想"><a href="#折翼的梦想" class="headerlink" title="折翼的梦想"></a>折翼的梦想</h2><p>&emsp;&emsp;小时候，每个人都有梦想。这些梦想寄托了我们对世界人生最早、最美好的想象。不过可惜。这些梦想往往萌芽不久就被大人击碎,于是我们逐渐忘记发梦。大人告诉我们，这叫成长；而成长的另一个名字叫<strong>认清现实</strong>，叫<strong>循规蹈矩</strong>，还叫<strong>识时务者为俊杰</strong>。</p><p>&emsp;&emsp;《小王子》的作者圣埃克苏佩里就有类似的经历，他在书的开始就告诉我们，他小时候热爱创作，曾绘画了两幅蟒蛇吞大象的抽象作品并渴望得到大人的欣赏，可谁知：</p><blockquote><p>&emsp;大人建议我把肚皮开开或闭着的蟒蛇图搁在一边，还是把兴趣放在地理、历史、算术、文法上面吧。于是我在六岁的时候，就这么放弃了美好的画家生涯。</p><div class="table-container"><table><thead><tr><th style="text-align:center"><img src="https://i.loli.net/2020/04/04/3daefx4KgB2QGZX.png" style="zoom:90%;" /></th><th style="text-align:center"><img src="https://i.loli.net/2020/04/04/HJ1c4MIKlB3ks7e.png" alt=""></th></tr></thead><tbody><tr><td style="text-align:center"><strong>图1</strong></td><td style="text-align:center"><strong>图2</strong></td></tr></tbody></table></div></blockquote><p>&emsp;&emsp;这段经历彻底改变了作者后来的人生，并给他的心灵带来了难以磨灭的影响。</p><p>&emsp;&emsp;所谓梦想，通常有两层含义：</p><p>&emsp;&emsp;1. <em>对当事人非常重要，是他十分在意且极具价值的目标。</em><br>&emsp;&emsp;2. <em>梦想和现实有相当的距离，需要付出许多努力才能实现。</em></p><p>&emsp;&emsp;由此见，大人们不鼓励小孩子发梦，要么认为这个梦不该发，要么认为这个梦不能实现。那大人们为什么不赞成小圣埃克苏佩里梦想是绘画呢？<strong>没前途。</strong>为什么？因为绘画不能上好的学校，不能找到有出息的工作，更不能在周围人中间赢得赞赏。谈到这里，大家就懂了：小孩子再怎么百般辩解都无效了。</p><p>&emsp;&emsp;我是赞成“龙生龙，凤生凤，老鼠儿子会打洞”这个说法的。一个孩子成长起来，最大的影响因素是他的抚养人们，其次才是其他的因素，比如他的兴趣、教育背景等。我喜欢敲代码，尽管它现在还算有前途，但我不可能敲一辈子代码，我总是会有许许多多其他的事情要去处理而不能一门心思的敲代码。如果我那时仍想继续敲代码该怎么办呢？恐怕我也只能像圣埃克苏佩里一样，把爱好当做享受，就像他拿起画笔就是纯粹自然地享受一样，享受创作本身，享受通过code实现神奇功能的喜悦。</p><p>&emsp;&emsp;为什么会享受？是因为，这世上本没有这样一幅画，但现在因为我，它存在了，它灌注了我的技艺、思想、甚至是情感和想象力。当我眼中所见、脑里所思都被表达出来时，这个自由表达的过程可以让我得到难以言喻的满足，这份满足本就是一份很好的汇报。</p><p>&emsp;&emsp;成长，也可以看做一个折翼梦想的过程。孩子会渐渐失去童真、想象力和好奇心。所以，问题的根源不在于他无法成为一个伟大的画家，而是在于他失去了发梦和追梦的心。只有在沙漠里遇到了小王子，才从小王子身上寻回了失去童年的自己。</p><p>&emsp;&emsp;我想，每个人或多或少都有和作者童年类似的经历。总是有些前辈以为你好之名，行折翼之事，不过是因你的成长不足以成为他们酒局饭桌上的谈资。有的时候，他们说起你，甚至和你的处境没什么关系，你的某个想法不和他们的观念，就是不成熟的；其实争辩是无意义的，关系本就不对等，他们不过图个面子或<strong>嗨点</strong>罢了。这些所谓的前辈，水平参差不齐，往往水平越低越像个教育家。其实不是抱怨什么，这是每个人成长时都会遇到的经历。我想说的是，人从小成长起来，本质上是经历若干凶险的考验（劫难），它们直接或间接的作用在你的思想、心理、性格，甚至有可能决定你的智力。有的你看得见，有的你看不见；你看得见的，不一定躲得开；你看不见的，有可能成就你的人生。因此，尽快拥有自己的价值观和独立思想是至关重要的，向长辈学习，要取其精华去其糟粕。</p><h2 id="驯服与责任"><a href="#驯服与责任" class="headerlink" title="驯服与责任"></a>驯服与责任</h2><p>&emsp;&emsp;&emsp;《小王子》中，玫瑰花影射为人的爱情。初恋是稚嫩且脆弱的，像风暴里漂浮的一叶扁舟。年少时，我也曾认为，真正的爱情不能只求曾经拥有，而应求天长地久。逐渐成长后，我开始思考，小王子离开他的玫瑰花是不是有某种必然性。</p><p>&emsp;&emsp;显然，小王子离开B612不是因为玫瑰不够美，小王子甚至认为玫瑰是宇宙中独一无二，最迷人的花儿。那是因为厌倦吗？小王子临走一刻仍在悉心照料玫瑰，没有半点不耐烦。是他们不够相爱吗？也不是，分别那一刻玫瑰向小王子表白：</p><blockquote><p><em>是的，我是爱你的。你一点都不知道，都怪我。</em></p></blockquote><p><img src="https://i.loli.net/2020/04/04/QK8YsgA6Nj5l39M.png" style="zoom:50%;" /></p><p>&emsp;&emsp;从玫瑰的角度看，她如此在乎小王子，希望得到爱护，却不懂如何表达，于是越爱越怕失去，越怕失去就越自卑。（她夸口四根刺可以抵御老虎，出身又足够高贵。）那小王子呢？小王子是如此在乎玫瑰，以至于越在乎就越敏感，越无法忍受对方的半点不好。</p><p>&emsp;&emsp;小王子是不快乐的，玫瑰也知道，她不希望小王子不快乐。道别时，玫瑰轻轻说出：</p><blockquote><p><em>我以前真傻，请你原谅我。你要快快乐乐的。</em></p></blockquote><p>&emsp;&emsp;初恋的脆弱，在于双方都渴望美好的爱，缺没有恰当的方式维护关系。小王子后来有一段忏悔：</p><blockquote><p><em>当时我什么都不懂！我应该根据她的行为，而不是她的言语来评断她。她芬芳了我的生活，照亮了我的生命。我真不该离开她！我早该猜到，在她那可笑的装腔作势后头，暗藏着柔情蜜意。花儿总是如此言不由衷！可惜当时我太小了，不懂得好好爱她。</em></p></blockquote><p>&emsp;&emsp;直到那一刻，小王子明白他错过了什么，失去了什么。真正的痛其实在于领悟之后，他意识到自己对玫瑰的责任，并为年少无知生出无尽的歉疚。人在初恋前和初恋后的心境是不一样的，曾经沧海难为水嘛~</p><p>&emsp;&emsp;后来文末时，小王子义无反顾地踏了出去，被毒蛇送回他的故乡。简单来看，小王子想这样做，是要对玫瑰负责，因驯服而生的责任，是小王子孤注一掷地走上这条路的重要原因。</p><blockquote><p><em>你知道……我的花儿……我对她有责任！她偏偏又是那么弱不禁风！她偏偏又是那么天真烂漫。她只有四根微不足道的刺，一点也不能保护她对抗外界……</em></p></blockquote><p>&emsp;&emsp;小王子在这里交代的十分清楚，他有责任回去照顾玫瑰。他不确定中毒后会如何，但是要尚有一线机会，他仍愿冒死一试。对玫瑰的责任，是小王子活着的主要动力。责任从何来？从狐狸来，狐狸说生命的价值必须建立在驯服关系上，而驯服伴随着责任：</p><blockquote><p><em>可是你不该忘记，你现在永远都得对你驯服过的一切负责。你要对你的玫瑰负责…</em></p></blockquote><p>&emsp;&emsp;责任其实是个道德概念，我们多数人都有类似的道德成长。罗尔斯的说法是，<em>人的道德发展有三个主要阶段：权威的道德、社群的道德和原则的道德。在儿童时期，小孩会基于对父母的爱和信任，服从他们发出的道德指令；及后年纪稍长，人们进入各类社群，拥有不同身份，并愿意服从这些社群根据不同角色而界定的各种规则，例如家庭、学校、教会等；最后，当人的道德能力发展成熟，他就会成为能够做独立的道德判断且愿意服从道德原则的人。如果他不能善尽自己的责任，他的道德情感就会令他产生强烈的道德歉疚。</em></p><p>&emsp;&emsp;其实责任不仅由爱产生，爱只是算一种“驯服”方式。这本书想告诉我们的是，驯服与责任之间并不是两样不相干的东西。责任伴随信服而来，并内在于驯服的关系。这一重一重的责任构成人的自我，赋予生活的意义，决定我们的行动。当然，作为一个道德概念，一些责任是可以拒绝的，但小王子无法放弃他的责任，放弃责任等于放弃驯服，他就再不是他自己。</p><h2 id="权力、财富——孤独"><a href="#权力、财富——孤独" class="headerlink" title="权力、财富——孤独"></a>权力、财富——孤独</h2><p>&emsp;&emsp;小王子离开B612游历时，遇到过奇怪的国王、商人。他们多为社会上人们的一种影射。有人为权，有人为钱；可权钱是空洞无物的，国王统治着宇宙内全部的星球，目光之所及莫非他土，他觉得他的命令都是恰当的，可没有他也是恰当的，自诩集全部权力于一身，反过来被权力架空，让他不再能拥有任何东西。</p><p>&emsp;&emsp;商人觉得他有目光之所及一切的占有权，他设计个表，里面记满了他发现的星球们，有了星球，他就能去买别的星球，然后得到更多的星球，他忙于“正事”，却忽视身边真正重要的东西，并视若无物。小王子告诉商人：</p><blockquote><p><em>我啊，要是我拥有一条围巾，我会把它绕在脖子上，围着它到处走。我啊，要是我拥有一朵花儿，我就可以摘下我的花儿，走到哪都带着她。可是你又不能摘下星星！……</em></p><p><em>我拥有一朵花儿，我每天都帮她浇水。我拥有三座火山，我每个礼拜都帮它们疏通，我连其中那座死火山也疏通。</em></p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center"><img src="https://img04.sogoucdn.com/app/a/100520146/dbf1e18b617a75a640a01ee96a829afa" style="zoom:80%;" /></th><th style="text-align:center"><img src="https://api-img.alapi.cn/image/2020/09/01/5b2aa3addf37b60a2293c8de2e2066f8.png" style="zoom:55%;" /></th></tr></thead><tbody><tr><td style="text-align:center"><strong>国王</strong></td><td style="text-align:center"><strong>商人</strong></td></tr></tbody></table></div><p>&emsp;&emsp;真正属于你的，是你能为它负责的，人和人拥有的东西是相互成就的。东西因人而被赋予意义，寄托情感；人因东西而满足，幸福。小王子路过了五千朵玫瑰的花园，但他拥有的那一朵玫瑰与花园中五千朵玫瑰都不同。他真的拥有一朵玫瑰，而五千朵玫瑰从未属于过他；一朵玫瑰就可以让小王子甘愿赴死，五千朵玫瑰却无一人赋予意义。有人说厚德载物，我想也是从另一角度说得如此道理，那些属于你的，将一直伴随你；那些不属于你的，终将离你而去。这“德”既是能力也是责任。</p><p>&emsp;&emsp;如果我们愿意诚实一点面对自己，我们也或多或少是小王子眼中奇怪的大人。为什么奇怪？因为大人将生命虚耗在一些不重要的事情上面。这些大人和小王子做不得朋友，大家的世界观完全不一样。其实作者对这些大人有很深的怜悯之意，因为他们都很孤独却不知如何面对。不仅这些大人孤独，小王子也很孤独，他找不到人愿意和他做朋友。在地球上，蛇对他说：</p><blockquote><p><em>就是到了有人的地方，也一样孤独。</em></p></blockquote><p>&emsp;&emsp;在概念上，驯服是孤独的对立面。所以孤独的出路也在于驯服，只有用心建立起来的各种驯服关系，并在这其中找到爱与责任，人才不会孤独。</p><h2 id="其他的领悟"><a href="#其他的领悟" class="headerlink" title="其他的领悟"></a>其他的领悟</h2><ul><li>人生充满选择，人要有自由选择的权利，并愿意为此承担责任。</li><li><em>驯服的，就是政治的</em>。 —— 引用自《小王子的领悟》 周保松</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;
        
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://rhythmlian.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="读后感" scheme="https://rhythmlian.cn/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>qs的文件下载策略</title>
    <link href="https://rhythmlian.cn/2020/03/23/qs-dl/"/>
    <id>https://rhythmlian.cn/2020/03/23/qs-dl/</id>
    <published>2020-03-23T09:57:34.000Z</published>
    <updated>2020-04-03T10:40:37.137Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><ul><li>基于Python的小文件下载是非常简单的：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dl</span><span class="params">(url)</span>:</span></span><br><span class="line">    r = requests.get(self.url, stream=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">with</span> open(self.name, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> r.iter_content(<span class="number">8192</span>):</span><br><span class="line">            f.write(chunk)</span><br></pre></td></tr></table></figure><ul><li>但在实际应用时，这样的简单文件下载往往不满足生产需要。比如，<code>单线程下载速度慢</code>，<code>IO频繁</code>。<del>玄学的是有时候这个可能比多线程下载要快一些。</del></li></ul><h2 id="普通文件下载策略"><a href="#普通文件下载策略" class="headerlink" title="普通文件下载策略"></a>普通文件下载策略</h2><h3 id="如何分配线程数？"><a href="#如何分配线程数？" class="headerlink" title="如何分配线程数？"></a>如何分配线程数？</h3><ul><li>在使用qs下载时，首先判断当前系统的<code>CPU</code>状态，保证在调用<code>min(CPU核心数*4, 16) + max(CPU核心数/2, 2)</code>的线程数情况下，平稳下载。其中，<code>max</code>部分是<a href="/2020/02/14/QuickStart-Rhy/#ThreadTools">写文件线程池</a>，用于处理频繁的文件IO。</li></ul><h3 id="如何针对一个文件并行下载？"><a href="#如何针对一个文件并行下载？" class="headerlink" title="如何针对一个文件并行下载？"></a>如何针对一个文件并行下载？</h3><ul><li>利用http通讯协议，在http头部信息添加<code>range: bytes=from-to</code>信息，对一个文件分块下载。</li><li>既然可以分块，块与块之间又没有依赖，就可以进行并行优化。并且，得益于文件操作的位置不同，<strong>甚至不需要针对下载文件设置读写锁</strong>。</li><li>当然，这样下载有一个前提，就是<strong>需要预先知道待下载的文件具体有多大。</strong>所以，在无法预知文件大小时，qs仍然会采用<code>最朴素的下载方法</code>（也就是开篇的那个算法）</li></ul><h3 id="如何设定块大小？"><a href="#如何设定块大小？" class="headerlink" title="如何设定块大小？"></a>如何设定块大小？</h3><ul><li>经过反复测试，我认为相对性能较好的块大小区间：<script type="math/tex">500KB\le BlockSize\le1MB</script></li><li><strong>很多时候，下载的文件其实并没有很大，针对大小不足<code>5M</code>的文件，qs不会启用多线程下载。</strong></li></ul><h3 id="下载中途可能的问题"><a href="#下载中途可能的问题" class="headerlink" title="下载中途可能的问题"></a>下载中途可能的问题</h3><ul><li><strong>针对块下载时可能遇到的意外错误，<code>qs</code>将无限制的重试下去。如果重试次数达到一定数量，每次重试时qs将小憩一段时间。</strong></li><li><strong>在一些并不稳定的下载过程中，遇到网络波动下载进程终止是很麻烦的事情，但是，你不用为qs担心，在启动多线程下载时，qs会将下载过的块进行标记并将信息存储在以<code>.qs_dl</code>结尾的文件里，当你重新进行文件下载时，qs可以实现<code>断点续下载</code>。</strong></li><li><del>一个比较玄学的事情是，重运行任务总是比<code>qs</code>自动重试要更有效率一些。</del></li></ul><h3 id="qs下载的优势"><a href="#qs下载的优势" class="headerlink" title="qs下载的优势"></a>qs下载的优势</h3><ul><li><code>断点续下载</code></li><li>得益于分块策略，可以大幅提速</li><li><code>不会被意外的网络问题中断下载任务</code></li><li><code>qs针对每一块下载都设置了超时重试，这意味着网络状态突然改变时，qs性能不会一直受到影响。</code></li></ul><h3 id="将尝试的优化"><a href="#将尝试的优化" class="headerlink" title="将尝试的优化"></a>将尝试的优化</h3><ol><li>动态调整块大小。</li><li>增强程序健壮性</li></ol><h3 id="部分源码"><a href="#部分源码" class="headerlink" title="部分源码"></a>部分源码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Downloader</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.size &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.ctn:</span><br><span class="line">                <span class="keyword">with</span> open(self.name, <span class="string">"wb"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">                    fp.truncate(self.size)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, self.size, self.fileBlock):</span><br><span class="line">                <span class="keyword">if</span> self.ctn <span class="keyword">and</span> i <span class="keyword">in</span> self.ctn:</span><br><span class="line">                    self.cur_sz += min(i + self.fileBlock, self.size) - i</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.job_queue.put(i)</span><br><span class="line">            retry_cnt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> self.job_queue.empty():</span><br><span class="line">                self.futures.clear()</span><br><span class="line">                <span class="keyword">while</span> <span class="keyword">not</span> self.job_queue.empty():</span><br><span class="line">                    cur = self.job_queue.get()</span><br><span class="line">                    <span class="keyword">if</span> cur <span class="keyword">not</span> <span class="keyword">in</span> self.ctn:</span><br><span class="line">                        self.futures.append(self.pool.submit(self._dl, cur))</span><br><span class="line">                wait(self.futures)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> self.job_queue.empty() <span class="keyword">and</span> retry_cnt &gt; <span class="number">2</span>:</span><br><span class="line">                    print(<span class="string">'\r[INFO] Exists File Block Lost, Retrying after 0.5 sec'</span>)</span><br><span class="line">                    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">                retry_cnt += <span class="number">1</span></span><br><span class="line">            self.writers.wait()</span><br><span class="line">            self.ctn_file.close()</span><br><span class="line">            os.remove(self.name + <span class="string">'.qs_dl'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._single_dl()</span><br><span class="line">        print(<span class="string">'[INFO] %s download done!'</span> % self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normal_dl</span><span class="params">(url)</span>:</span></span><br><span class="line">    Downloader(url, min(<span class="number">16</span>, core_num * <span class="number">4</span>)).run()</span><br></pre></td></tr></table></figure><h2 id="流媒体下载策略"><a href="#流媒体下载策略" class="headerlink" title="流媒体下载策略"></a>流媒体下载策略</h2><ul><li>经常开车的小伙们总会需要下载一些流媒体，其视频信息往往存储在以<code>.m3u8</code>结尾的索引文件中；</li><li>qs可以识别出这类文件，并启用线程池并行下载索引文件中的所有<code>.ts</code>文件，并帮助你把<code>.ts</code>文件们合并（但是并不保证这个过程一定没有错误，可能会造成你转换视频格式时出现问题）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;
        
      
    
    </summary>
    
    
      <category term="开发" scheme="https://rhythmlian.cn/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="技术分享" scheme="https://rhythmlian.cn/tags/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Mac上的网络仿真工具GNS3</title>
    <link href="https://rhythmlian.cn/2020/03/20/gns3/"/>
    <id>https://rhythmlian.cn/2020/03/20/gns3/</id>
    <published>2020-03-20T06:32:04.000Z</published>
    <updated>2020-03-27T16:38:37.770Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="GNS3"><a href="#GNS3" class="headerlink" title="GNS3"></a>GNS3</h2><p><strong>最近需要做计算机网络实验，可惜我的WIndows本给放在学校了，导致eNSP用不了；通过一番查找，发现GNS3可以作为eNSP的替代软件（似乎比eNSP还高大上一点？</strong></p><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><h3 id="官网下载"><a href="#官网下载" class="headerlink" title="官网下载"></a><a href="https://www.gns3.com/software/download" target="_blank" rel="noopener">官网下载</a></h3><ul><li>你需要先注册一个账户才能够下载</li><li>官网设置了防盗链，因此你无法通过多线程下载工具下载</li><li>下载速度比较慢，需<strong>耐心等待</strong></li></ul><h3 id="通过我的资源站高速下载"><a href="#通过我的资源站高速下载" class="headerlink" title="通过我的资源站高速下载"></a>通过我的<a href="/source">资源站</a>高速下载</h3><ol><li>点击文章尾部的<code>打赏</code>按钮，扫描<code>支付宝</code>二维码</li><li>扫码支付<code>两元</code>，在备注信息上注明<code>GNS3 你的邮箱地址</code></li><li><code>下载链接</code>将通过电子邮件发送至你的邮箱</li><li><strong>下载链接有效期为1天，请及时下载</strong></li></ol><h2 id="VIX-API"><a href="#VIX-API" class="headerlink" title="VIX API"></a>VIX API</h2><ul><li><code>GNS3</code>安装完毕后，初次运行时会报如下错误：</li></ul><blockquote><p>VMware vmrun tool could not be found, VMware or the VIX API (required for VMware player) is probably not installed. You can download it from <a href="https://www.vmware.com/support/developer/vix-api/" target="_blank" rel="noopener">https://www.vmware.com/support/developer/vix-api/</a>. After installation you need to restart GNS3.</p></blockquote><ul><li>点击进入上方链接下载<code>VIX API</code>；选择<code>Linux</code>包下载即可。</li><li><font color='red'>如果您通过我的资源站下载，VIX API的高速下载链接将随邮件一并发送</font></li></ul><h2 id="成功运行"><a href="#成功运行" class="headerlink" title="成功运行"></a>成功运行</h2><ul><li>创建工程后</li></ul><p><img src="https://i.loli.net/2020/03/20/tnxrG1fK4bmTuI8.png" alt="pic"></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;
        
      
    
    </summary>
    
    
      <category term="攻略" scheme="https://rhythmlian.cn/categories/%E6%94%BB%E7%95%A5/"/>
    
    
      <category term="MacOS" scheme="https://rhythmlian.cn/tags/MacOS/"/>
    
  </entry>
  
  <entry>
    <title>Electron-Vue问题与解决方案</title>
    <link href="https://rhythmlian.cn/2020/03/14/elec-vue-issues/"/>
    <id>https://rhythmlian.cn/2020/03/14/elec-vue-issues/</id>
    <published>2020-03-13T19:26:52.000Z</published>
    <updated>2020-05-04T08:43:23.229Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><h3 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init simulatedgreg/electron-vue <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h3 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜ WebstormProjects $ vue init simulatedgreg/electron-vue <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">? Application Name <span class="built_in">test</span></span><br><span class="line">? Application Id com.example.yourapp</span><br><span class="line">? Application Version 0.0.1</span><br><span class="line">? Project description An electron-vue project</span><br><span class="line">? Use Sass / Scss? No</span><br><span class="line">? Select <span class="built_in">which</span> Vue plugins to install (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selectio</span><br><span class="line">n)axios, vue-electron, vue-router, vuex, vuex-electron</span><br><span class="line">? Use linting with ESLint? No</span><br><span class="line">? Set up unit testing with Karma + Mocha? No</span><br><span class="line">? Set up end-to-end testing with Spectron + Mocha? No</span><br><span class="line">? What build tool would you like to use? builder</span><br><span class="line">? author 连浩丞 &lt;RhythmLian@outlook.com&gt;</span><br></pre></td></tr></table></figure><h3 id="正常运行"><a href="#正常运行" class="headerlink" title="正常运行"></a>正常运行</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p><img src="https://tx-rhythm-1257451806.cos.ap-beijing.myqcloud.com/ev-cover.png" alt=""></p><h2 id="初次运行时错误"><a href="#初次运行时错误" class="headerlink" title="初次运行时错误"></a>初次运行时错误</h2><h3 id="npm-run-dev"><a href="#npm-run-dev" class="headerlink" title="npm run dev"></a><code>npm run dev</code></h3><h4 id="错误信息"><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ERROR in Template execution failed: ReferenceError: process is not defined</span><br><span class="line"></span><br><span class="line">ERROR in   ReferenceError: process is not defined</span><br><span class="line">  </span><br><span class="line">  - index.ejs:11 eval</span><br><span class="line">    [.]&#x2F;[html-webpack-plugin]&#x2F;lib&#x2F;loader.js!.&#x2F;src&#x2F;index.ejs:11:2</span><br><span class="line">  </span><br><span class="line">  - index.ejs:16 module.exports</span><br><span class="line">    [.]&#x2F;[html-webpack-plugin]&#x2F;lib&#x2F;loader.js!.&#x2F;src&#x2F;index.ejs:16:3</span><br><span class="line">  </span><br><span class="line">  - index.js:284 </span><br><span class="line">    [test]&#x2F;[html-webpack-plugin]&#x2F;index.js:284:18</span><br><span class="line">  </span><br><span class="line">  - runMicrotasks</span><br><span class="line">  </span><br><span class="line">  - task_queues.js:97 processTicksAndRejections</span><br><span class="line">    internal&#x2F;process&#x2F;task_queues.js:97:5</span><br></pre></td></tr></table></figure><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>修改<code>.electron-vue/webpack.web.config.js</code> 和<code>.electron-vue/webpack.renderer.config.js</code>中的<code>plugins &gt; HtmlWebpackPlugin</code>为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">  filename: <span class="string">'index.html'</span>,</span><br><span class="line">  template: path.resolve(__dirname, <span class="string">'../src/index.ejs'</span>),</span><br><span class="line">  templateParameters(compilation, assets, options) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      compilation: compilation,</span><br><span class="line">      webpack: compilation.getStats().toJson(),</span><br><span class="line">      webpackConfig: compilation.options,</span><br><span class="line">      htmlWebpackPlugin: &#123;</span><br><span class="line">        files: assets,</span><br><span class="line">        options: options</span><br><span class="line">      &#125;,</span><br><span class="line">      process,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  minify: &#123;</span><br><span class="line">    collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">    removeAttributeQuotes: <span class="literal">true</span>,</span><br><span class="line">    removeComments: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  nodeModules: process.env.NODE_ENV !== <span class="string">'production'</span> ? path.resolve(__dirname, <span class="string">'../node_modules'</span>) : <span class="literal">false</span></span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure><h3 id="npm-run-build"><a href="#npm-run-build" class="headerlink" title="npm run build"></a><code>npm run build</code></h3><h4 id="错误信息-1"><a href="#错误信息-1" class="headerlink" title="错误信息"></a>错误信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Error: Exit code: 2. Command failed: /usr/bin/perl /private/var/folders/26/qgv4hgzj1pl_9bv96jqn476r0000gn/T/t-ciIudV/1-dmgProperties.pl</span><br><span class="line">Can't locate Mac/Memory.pm in @INC (you may need to install the Mac::Memory module) (@INC contains: /Library/Perl/5.18/darwin-thread-multi-2level /Library/Perl/5.18 /Network/Library/Perl/5.18/darwin-thread-multi-2level /Network/Library/Perl/5.18 /Library/Perl/Updates/5.18.4 /System/Library/Perl/5.18/darwin-thread-multi-2level /System/Library/Perl/5.18 /System/Library/Perl/Extras/5.18/darwin-thread-multi-2level /System/Library/Perl/Extras/5.18 .) at /private/var/folders/26/qgv4hgzj1pl_9bv96jqn476r0000gn/T/t-ciIudV/1-dmgProperties.pl line 4.</span><br><span class="line">BEGIN failed--compilation aborted at /private/var/folders/26/qgv4hgzj1pl_9bv96jqn476r0000gn/T/t-ciIudV/1-dmgProperties.pl line 4.</span><br><span class="line"></span><br><span class="line">Can't locate Mac/Memory.pm in @INC (you may need to install the Mac::Memory module) (@INC contains: /Library/Perl/5.18/darwin-thread-multi-2level /Library/Perl/5.18 /Network/Library/Perl/5.18/darwin-thread-multi-2level /Network/Library/Perl/5.18 /Library/Perl/Updates/5.18.4 /System/Library/Perl/5.18/darwin-thread-multi-2level /System/Library/Perl/5.18 /System/Library/Perl/Extras/5.18/darwin-thread-multi-2level /System/Library/Perl/Extras/5.18 .) at /private/var/folders/26/qgv4hgzj1pl_9bv96jqn476r0000gn/T/t-ciIudV/1-dmgProperties.pl line 4.</span><br><span class="line">BEGIN failed--compilation aborted at /private/var/folders/26/qgv4hgzj1pl_9bv96jqn476r0000gn/T/t-ciIudV/1-dmgProperties.pl line 4.</span><br></pre></td></tr></table></figure><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm i electron-builder@latest -S</span><br></pre></td></tr></table></figure><ul><li><strong><em>将electron-builder更新到最新版本</em></strong></li></ul><h2 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h2><h3 id="向后台发送JSON数据"><a href="#向后台发送JSON数据" class="headerlink" title="向后台发送JSON数据"></a>向后台发送JSON数据</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">'request-promise'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    submit()&#123;</span><br><span class="line">      request(&#123;</span><br><span class="line">        uri: api,</span><br><span class="line">        method: <span class="string">'POST'</span>,</span><br><span class="line">        headers:&#123;</span><br><span class="line">          <span class="string">'User-Agent'</span>: <span class="string">'Request-Promise'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        json: fm <span class="comment">// json表单</span></span><br><span class="line">      &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(res.status)&#123;</span><br><span class="line">          <span class="keyword">this</span>.$message(&#123;</span><br><span class="line">            message: <span class="string">"Register Success!"</span>,</span><br><span class="line">            type: <span class="string">'success'</span></span><br><span class="line">          &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">this</span>.$message.error(<span class="string">"Register Failed! With message: "</span> + res.msg);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题与修复"><a href="#问题与修复" class="headerlink" title="问题与修复"></a>问题与修复</h2><h4 id="错误信息：TypeError-handler-call-is-not-a-function"><a href="#错误信息：TypeError-handler-call-is-not-a-function" class="headerlink" title="错误信息：TypeError: handler.call is not a function"></a>错误信息：TypeError: handler.call is not a function</h4><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><p>*.vue中，<code>mounted: {}</code> 改为 <code>mount(){}</code></p><h4 id="错误信息：Element-ui不显示Table"><a href="#错误信息：Element-ui不显示Table" class="headerlink" title="错误信息：Element-ui不显示Table"></a>错误信息：Element-ui不显示Table</h4><h4 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h4><p>将<code>.electron-vue/webpack.renderer.config.js</code>中<code>whiteListedModules</code>修改为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> whiteListedModules = [<span class="string">'vue'</span>, <span class="string">'element-ui'</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;
        
      
    
    </summary>
    
    
      <category term="开发" scheme="https://rhythmlian.cn/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="攻略" scheme="https://rhythmlian.cn/tags/%E6%94%BB%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>中国境内配置谷歌广告联盟</title>
    <link href="https://rhythmlian.cn/2020/03/13/google-ads/"/>
    <id>https://rhythmlian.cn/2020/03/13/google-ads/</id>
    <published>2020-03-12T18:18:04.000Z</published>
    <updated>2020-09-01T11:48:58.148Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="收益"><a href="#收益" class="headerlink" title="收益"></a>收益</h2><ul><li><p>我昨天的收益：</p><p><img src="https://vip1.loli.net/2020/03/13/ZublDKqV2vJL8UF.jpg" alt=""></p></li><li><p>一般的话，个人博客，自己访问比较勤的，每天多设备刷新和偶尔点击广告都可以获得收入。<code>约0.5美元/天</code></p></li><li><p>如果你的博客每天可以有五十个人进进出出，偶尔点击广告，收益大概在<code>1.5美元/天</code>。</p></li></ul><h2 id="如何配置"><a href="#如何配置" class="headerlink" title="如何配置"></a>如何配置</h2><h3 id="获取Google-AdSense账户"><a href="#获取Google-AdSense账户" class="headerlink" title="获取Google AdSense账户"></a>获取Google AdSense账户</h3><ul><li><p>中国大陆用户需要翻墙访问<a href="https://www.google.com/adsense/" target="_blank" rel="noopener">Google Adsense</a>进行相关注册和审核。</p></li><li><p>不过，<code>Google Chrome</code>支持<code>Google Access Helper</code>浏览器扩展，它可以帮助你无需翻墙即可访问Google的相关网站。</p><ol><li><p>下载：<a href="http://cos.rhythmlian.cn/google-access-helper-2.zip" target="_blank" rel="noopener">Google Adsense Helper</a></p></li><li><p>打开Chrome，进入<code>设置</code>，选择侧边栏中<code>扩展程序</code></p></li><li><p>选择左上角<code>加载已解压的扩展程序</code>，选择刚刚下载并解压的文件夹即可</p></li></ol></li></ul><h3 id="添加网站"><a href="#添加网站" class="headerlink" title="添加网站"></a>添加网站</h3><ul><li>首先你需要申请一个用于识别你的id，一般以<code>ca-pub</code>开头，你需要将如下的代码添加到站点的头部信息中：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">(adsbygoogle = <span class="built_in">window</span>.adsbygoogle || []).push(&#123;</span></span><br><span class="line"><span class="actionscript">  google_ad_client: <span class="string">'你的id'</span>,</span></span><br><span class="line"><span class="actionscript">  enable_page_level_ads: <span class="string">'true'</span></span></span><br><span class="line">&#125;);<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>设置好后，提交审核，大概要一周左右的时间。</li><li>一般情况下，Google AdSense还会提供一个<code>ads.txt</code>文件，你需要将它放到网站根目录下。</li><li>如果审核成功，你的Google AdSense主页左侧栏会全部激活，你可以针对广告内容或格式做调整。</li></ul><h3 id="调整广告"><a href="#调整广告" class="headerlink" title="调整广告"></a>调整广告</h3><ol><li><p>在<code>广告</code>&gt;<code>概览</code>中，选择编辑你已添加的站点</p></li><li><p>建议进行如下配置：</p><p><img src="https://vip1.loli.net/2020/03/13/lAvmDxMOUfsu2ch.png" style="zoom:50%;" /></p></li><li><p>你可以在此基础上进行额外的更改，直至广告位置基本令你满意。</p></li></ol><h2 id="如何领钱"><a href="#如何领钱" class="headerlink" title="如何领钱"></a>如何领钱</h2><p>由于广告收益以美元形式发放，所以谷歌广告联盟提供<code>西联汇款</code>和<code>电汇</code>两种方式领取广告收益。</p><ul><li><code>西联汇款</code>无手续费；<code>电汇</code>一般手续费在<code>12刀</code>。</li></ul><p><code>西联汇款</code>支持国内多家银行，比如<code>光大银行</code>，<code>中国建设银行</code>等，你可以查询附近网点，带齐手续去网点领钱即可（<code>身份证</code>一定要带）</p><h3 id="视频说明"><a href="#视频说明" class="headerlink" title="视频说明"></a>视频说明</h3><iframe frameborder="0" src="https://v.qq.com/txp/iframe/player.html?vid=k0740udilg0" allowFullScreen="true" width=500 height=300></iframe>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;
        
      
    
    </summary>
    
    
      <category term="技术分享" scheme="https://rhythmlian.cn/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="攻略" scheme="https://rhythmlian.cn/tags/%E6%94%BB%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>加速git clone</title>
    <link href="https://rhythmlian.cn/2020/03/11/opt-git-clone/"/>
    <id>https://rhythmlian.cn/2020/03/11/opt-git-clone/</id>
    <published>2020-03-11T13:23:11.000Z</published>
    <updated>2020-03-11T13:58:40.308Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="为什么GitHub-Clone速度慢？"><a href="#为什么GitHub-Clone速度慢？" class="headerlink" title="为什么GitHub Clone速度慢？"></a>为什么GitHub Clone速度慢？</h2><ul><li>从GitHub直接clone仓库时，需要访问海外服务器，甚至可能要绕路到<strong>亚马逊云</strong>上</li><li>通常，访问海外服务器网咯并不流畅。一般的解决方案是修改hosts，但是并不一定管用。。</li></ul><h2 id="Gitee（码云）"><a href="#Gitee（码云）" class="headerlink" title="Gitee（码云）"></a>Gitee（码云）</h2><h3 id="如何实现加速？"><a href="#如何实现加速？" class="headerlink" title="如何实现加速？"></a>如何实现加速？</h3><p>既然本地节点直接访问海外服务器拉取仓库很慢，我们可以考虑<strong>通过别人（平台）访问海外服务器，再从这个平台的节点拉取数据。</strong>Gitee平台就恰好可以干这个！你可以先将<code>http</code>的<code>git地址</code>填到Gitee上，再通过Gitee的<code>git地址</code>直接用<code>git clone</code>命令拉取项目。</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><h4 id="1-注册并登录Gitee"><a href="#1-注册并登录Gitee" class="headerlink" title="1. 注册并登录Gitee"></a>1. 注册并登录<a href="https://gitee.com" target="_blank" rel="noopener">Gitee</a></h4><h4 id="2-新建仓库"><a href="#2-新建仓库" class="headerlink" title="2. 新建仓库"></a>2. 新建仓库</h4><ul><li><p>点击右上角的加号<code>+</code>，选择<code>从GitHub/GitLab导入仓库</code></p><p><img src="https://vip1.loli.net/2020/03/11/uYNoKvIAW3hLa1E.png" alt=""></p></li><li><p>在<code>URL</code>处填写<code>GitHub上的git地址</code>并导入</p><p><img src="https://vip1.loli.net/2020/03/11/C24W78clFp1OGIK.png" alt="">稍等片刻，等待Gitee克隆好</p><p><img src="https://vip1.loli.net/2020/03/11/PsIKkfjAHtdVZYF.png" alt=""></p></li></ul><h4 id="3-从Gitee克隆"><a href="#3-从Gitee克隆" class="headerlink" title="3. 从Gitee克隆"></a>3. 从Gitee克隆</h4><p>点击右上角<code>克隆/下载</code>，选择复制<code>HTTPS</code>下的<code>Git地址</code></p><p>在合适的位置运行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitee.com/RhythmLian/QuickStart.git</span><br></pre></td></tr></table></figure><h4 id="4-关联地址重定向"><a href="#4-关联地址重定向" class="headerlink" title="4. 关联地址重定向"></a>4. 关联地址重定向</h4><p>修改<code>.git/config</code>文件中的<code>[remote &quot;origin&quot;]</code>键值下的<code>url</code>值为<code>GitHub项目的git地址</code>即可。</p><p>也可以通过命令设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin &lt;url&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;
        
      
    
    </summary>
    
    
      <category term="技术分享" scheme="https://rhythmlian.cn/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="随笔" scheme="https://rhythmlian.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>我们这一代人</title>
    <link href="https://rhythmlian.cn/2020/02/26/jotting1/"/>
    <id>https://rhythmlian.cn/2020/02/26/jotting1/</id>
    <published>2020-02-25T16:45:37.000Z</published>
    <updated>2020-02-25T19:01:25.808Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="“90后”"><a href="#“90后”" class="headerlink" title="“90后”"></a>“90后”</h2><h3 id="人口红利影响"><a href="#人口红利影响" class="headerlink" title="人口红利影响"></a>人口红利影响</h3><p>​        中国近二十年的高速发展，离不开人口增长带来的爆发式<strong>人口红利</strong>。而从长远看，人口持续性高增长率是一定起严重副作用的，所以我国在90年代有一个<strong>计划生育</strong>的”急刹车“。我们这一代人，就恰好是这急刹车里诞生的幸运儿~</p><p>​        中国在00年时，70年代的人正值青壮年，种群年龄结构恰似一个立起来的椭圆形，这意味着我国有更多的劳动力；那时候中国以经济建设为中心，外贸行业繁荣，东北地区一是靠工农业生产、二是依靠俄罗斯搞外贸，也是这个时期冒出来了”倒爷“这批人；其余地区有矿的开矿，有点钱的开制造厂，有技术的搞技术，小商小贩也想着法搞小生意…尽管后来外贸玩不动了，但这段时间中国经济的高速发展还是催出来很多资产过千万的人，下面跟着一大批”中产阶级“，似乎只要你勤劳肯干、脑子不蠢就能依靠这一波人口红利爬上去。紧跟着，靠着稳定安逸的工作，大部分人都能顺利买下房子、车子，甚至还能有闲钱拿出来自己搞搞创业、或者玩玩房地产、玩玩投资。这”钱轮子“一转起来，一是内需上去了，二是外资引进来了，带着经济接着往上冲。</p><p>​        所以，很多老一辈人评判事业好坏时就认准一个词：”稳定“。10年代初，兴考公务员，进事业单位，贷款买房子，虽然后来电商跟着互联网窜起来了，带了一波节奏，但人们内心深处对于”稳定“的观念，始终扎根在潜意识里。然而今时不同往日，人口红利期眼看着就过去了，种群年龄结构即将走向”上下都宽、唯独中间窄“的<strong>“还债”</strong>阶段，再依靠贩卖劳动力赚苦钱就不现实了。老爷们聪明着，盯着90后的一批人疯狂教改（自始至终都搞得是同一拨人）；鼓励创新创业（钱不够分了，想办法自己赚吧，什么？你赚不来？那和我有什么关系）；搞环保（别想着走老路，这矿那矿的都给我停了）。</p><h3 id="“稳定”"><a href="#“稳定”" class="headerlink" title="“稳定”"></a>“稳定”</h3><p>​        计算机技术窜了起来相对出乎老爷们的意料，电商+搜索+社交混着搞，带着互联网和计算机行业成为时代风口，又看到隔壁鹰酱玩起了信息战，这下可一点都不敢马虎了。再过几年，鹰酱家的阿尔法狗依靠算力利用蒙特卡罗树下起了围棋，AI、高性能计算、大数据等计算机行业又一次站在了时代风口；最近的5G冒出来了，这玩意多少和计算机是沾边的，也算是又点了一次计算机行业。</p><p>​        计算机技术大红大紫，慢慢冒出来个高薪职业：程序员。毕竟是新兴产业，法律监管不严，所以这两年经济稍微不好的时候，就能看到“996”，“007”，“251”等大跌人眼镜的操作。就这个环境，一名普通985/211毕业的本科生，最多搞10年相关岗位，10后35岁，企业和你都不傻（企业想裁你换年轻人，你想多捞点补偿好做下一步打算），这就注定了我们这一代人，很少是“稳定”的。</p><h2 id="咋办？"><a href="#咋办？" class="headerlink" title="咋办？"></a>咋办？</h2><h3 id="搞钱、结婚"><a href="#搞钱、结婚" class="headerlink" title="搞钱、结婚"></a>搞钱、结婚</h3><p>​        想搞钱，不能一门心思靠工资，不然永远也别想着靠自己买出一套400w以上的房子，没得房子就没得老婆，没得老婆就没得家，没得家就抬不起头。要么你够牛，去国外企业工作，顺路移民过去，压力没那么大。否则就只能在国内苦钱。你嫌累，你想想你老婆和孩子都在家等着你呢（哦不，可能你没机会让他们等你）。</p><p>​        家境好的，“啃一波老”整个首付，顺着门当户对的条件（难度：史诗），女方出辆车总不算为难人，这家就快小成了，后面根据双方能力看看愿意花几个十万整个体面的婚礼，也就完成人生一项任务了。你松了口气，过上了一两年快活日子，接着老婆就生了娃，辞掉了工作照看孩子和家里，你负责在外面搞钱养家，这个时候，你是上有老下有小，晚上一闭眼就得想着第二天家里那么多张嘴指望着你吃饭，不仅要“吃得体面”，还得攒下存款。你在领导面前越来越怂，领导骂你越来越起劲~</p><p>​        就这，还不是人人都受的到这个罪，首先你得是“985/211计算机相关专业本科毕业、硕士毕业”才行，附加条件：“家境尚可”。</p><h3 id="可这就是人生"><a href="#可这就是人生" class="headerlink" title="可这就是人生"></a>可这就是人生</h3><p>​        尽管人生苦，但是人大多还是喜欢这个世界的。你也喜欢这个世界，就首先要孝敬好父母，再维系好家庭，给子女好的教育…</p><p>​        下面瞎BB：</p><p>​        <strong>养育之恩岂止于爱</strong>，你对你伴侣的爱和你对孩子的感情绝对是不一样的。父母生你，从来就不需要征得你的同意，可是生娃真就出于自身的利益考虑吗？2020年的今天，有太多种比养个娃收益高的投资了，扪心自问，养儿防老吗？你家地位越高，你的教育成本就不会低，几十万几百万砸下去培养起来的人，出了家门才年入十几万，还不够养活自己的？你知道，有这几百万，哪怕你给个傻子理财经理，他每年至少能帮你赚出10%，养你需要20年，这个时间足够几百万翻六七倍了。这还只是钱呢，那期间为你付出的精力呢？</p><p>​        <strong>你毕业几年能把养你的本钱赚出来？拿什么去抵父母花在你身上的精力？</strong>没有人会单纯因为爱付出这么多利益。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;
        
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://rhythmlian.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://rhythmlian.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
